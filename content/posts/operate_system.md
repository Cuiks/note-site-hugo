---
title: "计算机操作系统"
date: 2021-05-27T15:22:39+08:00
tags: ["计算机操作系统"]
draft: false
---

- 操作系统之基础
- 操作系统之提升
- 操作系统实践

<!--more-->

## 操作系统之基础篇

### 操作系统概览

#### What

管理硬件、提供用户交互的软件系统

- 操作系统是管理计算机硬件和软件资源的计算机程序
- 管理配置内存、决定资源供需顺序、控制输入输出设备等
- 操作系统提供让用户和系统交互的操作界面

#### Why

- 我们不能直接操作计算机硬件
- 设备种类繁多复杂，需要统一界面
- 操作系统的简易性使得更多人能够使用计算机

#### 操作系统的基本功能

- 操作系统统一管理着计算机资源
  - 处理器资源、IO设备资源、存储器资源、文件资源
- 操作系统实现了对计算机资源的抽象
  - 用户无需面向硬件接口编程
  - IO设备管理软件，提供读写接口
  - 文件管理软件，提供操作文件接口
- 操作系统提供了用户与计算机之间的接口
  - 图像窗口形式
  - 命令形式
  - 系统调用形式

#### 操作系统相关概念

- 并发性
  - 并行是指两个或多个事件可以在同一个时刻发生
  - 并发是指两个或多个事件可以在同一个时间间隔发生
- 共享性
  - 共享性表现为操作系统中的资源可供多个并发的程序共同使用，这种共同使用的形式成为资源共享
  - 互斥共享形式
  - 同时访问形式
- 虚拟性
  - 虚拟性表现为把一个物理实体转变为若干个逻辑实体
  - 物理实体是真实存在的，逻辑实体是虚拟的
  - 虚拟的技术主要由时分复用技术和空分复用技术
  - 时分复用技术
    - 资源在时间上进行复用，不同程序并发使用
    - 多道程序分时使用计算机的硬件资源
    - 提高资源利用率
    - ![](https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210510160931.png)
  - 空分复用技术
    - 空分复用技术用来实现虚拟磁盘、虚拟内存等
    - 提高资源的利用率，提升编程效率
    - ![](https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210510161135.png)
- 异步性
  - 在多道程序环境下，允许多个进程并发执行
  - 进程在使用资源时可能需要等待或放弃
  - 进程的执行不是一气呵成的，而是以走走停停的形式推进

### 进程管理之进程实体

#### 为什么需要进程

- 进程是系统进行资源分配和调度的基本单位
- 进程作为程序独立运行的载体保障程序正常执行
- 进程的存在使得操作系统资源的利用率大幅提升

#### 进程的实体

- 主存中的进程形态
  - 进程标识符
  - 处理机状态
  - 处理调度信息
  - 进程控制信息
  - 
  - 进程控制块
    - 标识符：唯一标记一个进程，用于区别其他进程
    - 状态：标记进程的进程状态，如：运行态
    - 程序计数器：进程即将被执行的下一条指令的地址
    - 内存指针：程序代码、进程数据相关指针
    - 上下文数据：进程执行时处理器存储的数据
    - IO状态信息：被进程IO操作所占用的文件列表
    - 记账信息：使用处理器时间、时钟数总和等
  - 进程控制块(PCB)
    - 用于描述和控制进程运行的通用数据结构
    - 记录进程当前状态和控制进程运行的全部信息
    - PCB使得进程是能够独立运行的基本单位
    - PCB是操作系统进行调度经常会被读取的信息
    - PCB是常驻内存的，存放在系统专门开辟的PCB区域内
- 进程与线程
  - 进程(Process)
    - 进程是系统进行资源分配和调度的基本单位
  - 线程(Thread)
    - 线程是操作系统进行运行调度的最小单位
    - 包含在进程之中，是进程中实际运行工作的单位
    - 一个进程可以并发多个线程，每个线程执行不同的任务
    - 线程共享进程的资源
  - 一个进程可以有一个或多个线程
  - ![](https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210510171848.png)


### 进程管理之五状态模型

- 就绪状态
  - 当进程被分配到除CPU以外的所有必要的资源后，只要再获取CPU的使用权，就可以立即运行。其他资源都准备好、只差CPU资源的状态为就绪状态。
- 执行状态
  - 进行获得CPU，其程序正在执行成为执行状态。在单处理机中，在某个时刻只能有一个进程是出于执行状态。
- 阻塞状态
  - 进程因某种原因(例如:其他设备未就绪而无法继续执行)从而放弃CPU的状态成为阻塞状态
- ![](https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210510205110.png)
- 创建状态
  - 创建进程时拥有PCB但其他资源尚未就绪的状态成为创建状态
  - 操作系统提供fork函数接口创建进程
- 终止状态
  - 进程结束由系统清理或者归还PCB的状态称为终止状态
- ![](https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210510205415.png)


### 进程管理之进程同步

#### 为什么需要进程间同步

- 对竞争资源在多进程间进行使用次序的协调
- 使得并发执行的多个进程之间可以有效使用资源和相互合作
- 
- 生产者-消费者问题
- 哲学家就餐问题

#### 进程间同步的原则

临界资源

- 临界资源指的是一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可重新竞争使用共享资源。

同步原则：

- 空闲让进：资源无占用，允许使用
- 忙则等待：资源有占用，请求进程等待
- 有限等待：保证有限等待时间能够使用资源
- 让权等待：等待时，进程需要让出CPU

进程同步方法：

- 消息队列
- 共享存储
- 信号量

#### 线程同步

进程内多线程也需要同步

线程同步方法：

- 互斥量
- 读写锁
- 自旋锁
- 条件变量


### Linux的进程管理

Linux进程的相关概念

- 进程的类型
  - 前台进程
    - 具有终端，可以和用户交互的进程
  - 后台进程
    - 与前台进程相对，没有占用终端的就是后台进程
    - 后台程序基本上不和用户交互，优先级比前台进程低
    - 将需要执行的命令以“&”符号结束
  - 守护进程
    - 守护(daemon)进程是特殊的后台进程
    - 很多守护进程在系统引导的时候启动，一直运行到系认关闭
    - Linux有很多典型的守护进程
    - 进程名字以"d"结尾的一般都是守护进程
      - crond、sshd、httpd、mysqld
- 进程的标记
  - 进程ID
    - 进程ID是进程的唯一标记，每个进程拥有不同的ID
    - 进程ID表现为一个非负整数，最大值由操作系统限定
    - 父子进程关系可以通过`pstree`命令查看
    - ID为0的进程为idle进程，是系统创建的第一个进程
    - ID为1的进程为init进程，是0号进程的子进程，完成系统初始化
    - Init进程是所有用户进程的祖先进程
  - 进程的状态标记
    - `man ps`查看进程各种状态的含义
    - ![](https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210510212907.png)

操作Linux进程的相关命令

- ps命令
  - ps -u root 查看root用户的进程
  - ps -axu|grep 'python'
  - ps -ef --forest  查看进程树
  - ps -aux --sort=-pcpu/pmeme   根据cpu/内存使用频率倒序
- top命令
- kill命令


### 作业管理之进程调度

进程调度概述

- 进程调度是指计算机通过决策决定哪个就绪进程可以获得CPU使用权
- 调度过程
  - 保留旧进程的运行信息，清楚旧进程（收拾包袱）
  - 选择新进程，准备运行环境并分配CPU（新进驻）
- 调度机制
  - 就绪队列的排队机制
    - 将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程
  - 选择运行进程的委派机制
    - 调度程序以一定的策略选择就绪进程，将CPU资源分配给他
  - 新老进程的上下文切换机制
    - 保存当前进程的上下文信息，装入被委派执行进程的运行上下文
- 调度方式
  - 非抢占式的调度
    - 处理器一旦分配给某个进程，就让该进程一直使用下去
    - 调度程序不以任何原因抢占正在被使用的处理器
    - 直到进程完成工作或因为IO阻塞才会让出处理器
  - 抢占式的调度
    - 允许调度程序以一定的策略暂停当前运行的进程
    - 保存好旧进程的上下文信息，分配处理器给新进程
  - ![](https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210510214847.png)

进程调度算法

- 先来先服务调度算法
- 短进程优先调度算法
  - 调度程序优先选择就绪队列中估计运行时间最短的进程
  - 短进程优先调度算法不利于长作业进程的执行
- 高优先权优先调度算法
  - 进程附带优先权，调度程序优先选择权重很高的进程
  - 高优先权优先调度算法使得紧迫的任务可以优先处理
- 时间片轮转调度算法
  - 按照先来先服务的原则排列就绪进程
  - 每次从队列头部取出待执行进程，分配一个时间片执行
  - 是相对公平的调度算法，但不能保证及时响应用户


### 作业管理之死锁

死锁：两个或者两个以上的进程在执行过程中，由于经这个资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，他们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远处于互相等待的进程成为死锁进程。

- 死锁的产生
  - 竞争资源
    - 共享资源数量不满足各个进程需求，各个进程之间发生资源竞争导致死锁
  - 进程调度顺序不当
  - 死锁的四个必要条件
    - 互斥条件
      - 进程对资源的使用是排他性的使用
      - 某资源只能由一个进程使用，其他进程需要使用只能等待
    - 请求保持条件
      - 进程至少保持一个资源，又提出新的资源请求
      - 新资源被占用，请求被阻塞
      - 被阻塞的进程不释放自己保持的资源
    - 不可剥夺条件
      - 进程获得的资源在未完成使用前不能被剥夺
      - 获得的资源只能由进程自身释放
    - 环路等待条件
      - 发生死锁时，必然存在进程-资源环形链
- 死锁的处理
  - 预防死锁的方法
    - 摒弃请求保持条件
      - 系统规定进程运行之前，一次性申请所有需要的资源，进程在运行期间不会提出资源请求，从而摒弃请求保持条件
    - 摒弃不可剥夺条件
      - 当一个进程请求新的资源得不到满足时，必须释放占有的资源。进程运行时占有的资源可以被释放，意味着可以剥夺
    - 摒弃环路等待条件
      - 可用资源线性排序，申请必须按照需要递增申请。线性申请不再形成环路，从而摒弃了环路等待条件
  - 银行家算法
    - 简介
      - 是一个可操作的著名的避免死锁的算法。以银行借贷系统分配策略为基础的算法
    - 策略基础
      - 客户申请的贷款是有限的，每次申请需声明最大资金量
      - 银行家在能够满足贷款时，都应该给用户贷款
      - 客户在使用贷款后，能够及时归还贷款
    - 算法
      - 所需资源表
      - 已分配资源表
      - 还需分配资源表 = 所需资源表 - 已分配资源变
      - 可分配资源表
      - 比较 可分配资源变 和 还需分配资源表

### 存储管理之内存分配与回收

#### 内存分配与回收目的

- 确保计算机有足够的内存处理数据
- 确保程序可以从可用内存中获取一部分内存使用
- 确保程序可以归还使用后的内存以供其他程序使用

#### 内存分配的过程

- 单一连续分配
  - 最简单的内存分配方式
  - 只能在单用户、单进程的操作系统中使用
- 固定分区分配
  - 固定分区分配是支持多道程序的最简单存储分配方式
  - 内存空间被划分为若干固定大小的区域
  - 每个分区只提供给一个程序使用，互不干扰
- 动态分区分配
  - 根据进程实际需要，动态分配内存空间
  - 相关数据结构
    - 动态分区空闲表数据结构
      - ![](https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210511161444.png)
    - 动态分区空闲链数据结构
      - ![](https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210511161614.png)
  - 动态内存分配算法
    - 首次适应算法（FF算法）
      - 分配内存是从开始顺序查找适合内存区
      - 若没有合适的空闲区，则该次分配失败
      - 每次都从头部开始，使得头部地址空间不断被划分
      - 首次适应算法改进 -- 循环适应算法
        - 不从头部开始，从上一次位置继续查找
    - 最佳适应算法（BF算法）
      - 要求空闲区链表按照容量大小排序
      - 遍历空闲区链表找到最合适空闲区
    - 快速适应算法（QF算法）
      - 要求有多个空闲区链表
      - 每个空闲区链表存储一种容量的空闲区

#### 内存回收的过程

- 空闲区位于回收区前面
  - 不需要新建空闲区链表节点，只需要把空闲区1的容量增大为空闲区即可
- 空闲区位于回收区后面
  - 将回收区与空闲区合并
  - 新的空闲区使用回收区的地址
- 回收区位于两个空闲区之间
  - 将空闲区1、空闲区2和回收区合并，新的空闲区使用空闲区1的地址
- 回收区没有邻接空闲区
  - 为回收区创建新的空闲节点
  - 插入到响应的空闲区链表中去

### 存储管理之段页式存储管理

#### 页式存储管理

- 将进程逻辑空间等分成若干大小的页面
- 响应的吧物理内存空间分成页面大小的物理块
- 以页面为单位吧进程空间装进物理内存中分散的物理块
- 
- 页面大小应该适中，过大难以分配，过小内存碎片过多
- 页面大小通常是512B~8K
- 页表记录进程逻辑空间与物理空间的映射

#### 段式存储管理

- 将进程逻辑空间划分为若干段（非等分）
- 段的长度由连续逻辑的长度决定
- 主函数MAIN、子程序段X、子函数Y等

段式存储和页式存储都离散的管理了进程的逻辑空间

- 页是物理单位，段是逻辑单位
- 分页是为了合理利用空间，分段是满足用户要求
- 页大小由硬件固定，段长度可动态变化
- 页表信息是一维的，段表信息是二维的

#### 段页式存储管理

- 先将逻辑空间按段式管理分成若干段
- 再把段内空间按页式管理等分成若干页

### 存储管理之虚拟内存

虚拟内存概述

- 有些进程实际需要的内存很大，超过物理内存的容量
- 多道程序设计，使得每个进程可用物理内存更加稀缺
- 不可能无限增加物理内存，物理内存总有不够的时候
- 虚拟内存是操作系统内存管理的关键技术
- 使得多道程序运行和大程序运行成为现实
- 把程序使用内存划分，将程序暂时不使用的内存放置在辅存

程序的局部性原理

- 局部性原理是指CPU访问存储器的时候，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。
- 程序运行时，无需全部装入内存，装在部分即可
- 如果访问页不在内存，则发出缺页中断，发起页面置换
- 从用户层面，程序拥有很大的空间，即是虚拟内存
- 虚拟内存实际是对物理内存的扩充，速度接近于内存，成本接近于辅存

虚拟内存的置换算法

- 先进先出算法（FIFO）
- 最不经常使用算法（LFU）
- 最近最少使用算法（LRU）


### Linux的存储管理

#### Buddy内存管理算法

- 经典的内存管理算法
- 基于计算机处理二进制的优势具有极高的效率
- 主要是为了解决内存碎片的问题

页内碎片：内存碎片是已经被分配出去的内存空间大于请求所需的内存空间，不能被利用的内存空间就是内部碎片。

页外碎片：外部碎片是指还没有分配出去，但是由于大小而无法分配给申请内存空间的新进程的内存空闲快。

Buddy算法：

- 向上取整为2的幂大小
- 伙伴系统
  - “伙伴”指的是内存的“伙伴”
  - 一片连续内存的“伙伴”是相邻的另一片大小一样的连续内存
- 创建流程
  - 创建一系列空闲快链表，每一个都是2的幂大小
  - 分配内存块时，将剩余的空间补充回空闲快链表
- 回收流程
  - 判断是否存在伙伴，存在即合并


#### Linux交换空间

- 交换空间（Swap）是磁盘的一个分区
- Linux物理内存满时，会把一些内存交换至Swap空间
- Swap空间是初始化系统时配置的
- 冷启动内存依赖
- 系统睡眠依赖
- 大进程空间依赖

### 操作系统的文件管理

#### 文件的逻辑结构

- 逻辑结构的文件类型
  - 有结构文件
    - 文本文件、文档、媒体文件
    - 文件内容由定长记录和可变长记录组成
    - 定长记录存储文件格式、文件描述等结构化数据项
    - 可变长记录存储文件具体内容
  - 无结构文件
    - 二进制文件、链接库
    - 也称为流式文件
    - 文件内容长度以字节为单位
    - exe文件、dll文件、so文件
- 顺序文件
  - 按照顺序存放在存储介质中的文件
  - 磁带的存储特性使得磁带文件只能存储顺序文件
  - 顺序文件是所有逻辑文件当中存储效率最高的
- 索引文件
  - 可变长文件不适合使用顺序文件格式存储
  - 索引文件是为了解决可变长文件存储而发明的一种文件格式
  - 索引文件需要配合索引表完成存储的操作

#### 辅存的存储空间分配

- 辅存的分配方式
  - 连续分配
    - 顺序读取文件内容非常容易，速度很快
    - 对存储要求高，要求满足容量的连续存储空间
  - 链接分配
    - 链接分配可以将文件存储在离散的盘块中
    - 需要额外的存储空间存储文件的盘块链接顺序
      - 按照额外存储空间不同，分为：
        - 隐式链接
          - 隐式分配的下一个链接指向存储在当前盘块内
          - 适合顺序访问，随机访问效率很低
          - 可靠性差，任何一个链接出问题都会影响整个文件
        - 显式链接
          - 单独使用表记录物理块及下一盘块的地址（FAT: File Allocation Table）
          - 不支持高效的直接存储（FAT记录项多）
          - 检索式FAT表占用较大的存储空间（需要将整个FAT加载到内存）
  - 索引分配
    - 把文件的所有盘块集中存储（索引）
    - 读取某个文件时，将文件索引读取进内存即可
    - 优势
      - 每个文件拥有一个索引快，记录所有盘块信息
      - 索引分配方式支持直接访问盘块
      - 文件较大时，索引分配方式具有明显优势
- 存储空间管理
  - 空闲表
    - ![](https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210512100519.png)
    - 空闲盘区的分配与内存分配类似
    - 首次适应算法、循环适应算法等
    - 回收过程也与内存回收类似
  - 空闲链表
    - 吧所有空闲盘区组成一个空闲链表
    - 每个链表节点存储空闲盘块和空闲的数目
  - 位示图
    - ![](https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210512100833.png)
    - 位示图维护成本很低
    - 位示图可以非常容易找到空闲盘块
    - 位示图使用0/1比特位，占用空间小

#### 目录管理

目录树

- ![](https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210512101010.png)
- 任何文件或目录都只有唯一路径


### linux文件基本操作

Linux目录

- 一切皆文件
- ![](https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210512161131.png)
- 相对路径、绝对路径
  Linux文件常用操作
- 目录/文件 创建、删除、读取、写入
  Linux文件类型
- 套接字(s)
- 普通文件(-)
- 目录文件(d)
- 符号链接(l)
- 设备文件(b、c)
- FIFO(p)

### Linux的文件系统

#### 文件系统概览

- FAT（File Allocation Table）
  - FAT16、FAT32等，微软Dos/Windows使用的文件系统
  - 使用一张表保存盘块的信息
- NTFS（New Technology File System）
  - WindowsNT环境的文件系统
  - NTFS对FAT进行了改进，取代了旧的文件系统
- EXT2/3/4 （Extended file syatem）:扩展文件系统
  - Linux的文件系统
  - EXT2/3/4数字表示第几代

#### Ext文件系统

- ![](https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210512163034.png)
- Inode Table
  - 存放文件Inode的地方
  - 每一个文件（目录）都有一个Inode
  - 是每一个文件（目录）的索引节点
- Inode
  - 文件类型
  - 文件权限
  - 文件物理地址
  - 文件长度
  - 文件连接计数
  - 文件存取时间
  - 索引节点编号
  - 文件状态
  - 访问技术
  - 链接指针
  - ...
  - 文件名不是存放在Inode节点上的，而是存放在目录的inode节点
  - 列出目录文件的时候无需加载文件的Inode
- Inode bitmap(位示图)
  - Inode的位示图
  - 记录已分配的Inode和未分配的Inode
  - ![](https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210512163547.png)
- Data block
  - 存放文件内容的地方
  - 每个block都有唯一的编号
  - 文件的block记录在文件的Inode上
- Block bitmap
  - Block的位示图
  - 记录Data block的使用情况
- superblock
  - 记录整个文件系统相关信息的地方
  - Block和Inode的使用情况
  - 时间信息、控制信息等


### 操作系统的设备管理

#### 广义的IO设备

- 对CPU而言，凡是对CPU进行数据输入的都是输入设备
- 对CPU而言，凡是CPU进行数据输出的都是输出设备
- 按使用特性分类
  - 存储设备：U盘、内存、磁盘
  - 交互IO设备：键盘、显示器、鼠标
- 按设备的共享属性分类
  - 独占设备
  - 共享设备
  - 虚拟设备
- 按信息交换的单位分类
  - 块设备：磁盘、SD卡
  - 字符设备：打印机、Shell终端
- 按传输速率分类
  - 低速设备
  - 中速设备
  - 高速设备

#### IO设备的缓冲区

- 减少CPU处理IO请求的频率
- 提高CPU与IO设备之间的并行性
- 
- 专用缓冲区只适用于特定的IO进程，当这样的IO进程比较多时，对内存的消耗也很大。
- 操作系统划出可供多个进程使用的公共缓冲区，成为缓冲池

#### SPOLing技术

- 是关于慢速字符设备如何与计算机主机交换信息的一种技术
- 利用高速共享设备将低速的独享设备模拟为高速的共享设备
- 逻辑上，系统为每一个用户都分配了一台独立的高速独享设备
- 虚拟设备技术

SPOOLing技术把同步调用低速设备改为异步调用
![](https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210512165846.png)

- 在输入、输出之间增加了排队转储环节（输入井、输出井）
- SPOOLing负责输入（出）井与低速设备之间的调度
- 逻辑上，进程直接与高速设备交互，减少了进程的


## 操作系统之提升篇

### 线程同步之互斥量

原子性

- 原子性是指一系列操作不可被中断的特性。这一些类操作要么全部执行完成，要么全部没有执行，不存在部分执行部分未执行的情况
- 互斥量是最简单的线程同步的方法
- 互斥量（互斥锁），处于两态之一的变量：解锁和加锁
- 两个状态可以保证资源访问的串行


### 线程同步之自旋锁

- 自旋锁也是一种多线程同步的变量
- 使用自旋锁会反复检查锁变量是否可用
- 自旋锁不会让出CPU，是一种忙等待状态
- 死循环等待锁被释放

特点：

- 自旋锁避免了进程或线程上下文切换的开销
- 操作系统内部很多地方使用的是自旋锁
- 自旋锁不适合在单核CPU使用


### 线程同步之读写锁

- 读写锁是一种特殊的自旋锁
- 允许多个读者同事访问资源以提高读性能
- 对于写操作则是互斥的


### 线程同步之条件变量

- 条件变量是一种相对复杂的线程同步方法
- 条件变量允许线程睡眠，知道满足某种条件
- 当满足条件时，可以像该线程发送信号，通知唤醒

### 线程同步方法对比

![](https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210513160338.png)


### 使用fork系统调用创建进程

- fork系统调用是用于创建进程的
- fork创建的进程初始状态与父进程一样
- 系统会为fork的进程分配新的资源
- fork系统调用无参数
- fork会返回两次，分别返回子进程id和0
- 返回子进程id的是父进程，返回0的是子进程


### 进程同步之共享内存

- 在某种程度上，多进程是共同使用武力内存的
- 由于操作系统的进程管理，进程间的内存空间是独立的
- 进程默认是不能访问进程空间之外的内存空间的
- 共享存储允许不相关的进程访问同一片物理内存
- 共享内存是两个进程之间共享和传递数据最快的方式
- 共享内存未提供同步机制，需要借助其他机制管理访问

使用步骤：

- 申请共享内存
- 连接到进程空间
- 使用共享内存
- 脱离进程空间&删除


### 进程同步之Unix域套接字

- 域套接字是一种高级的进程间通信的方法
- Unix域套接字可以用于同一机器的进程间通信
- 套接字（socket）原是网络通信中使用的术语
- Unix系统提供的域套接字提供了网络套接字类似的功能

服务端流程：

- 创建套接字
- 绑定(bind)套接字
- 监听(listen)套接字
- 接收&处理信息

客户端流程：

- 创建套接字
- 连接套接字
- 发送信息

优势：

- 提供了单机简单可靠的进程通信同步服务
- 只能在单机使用，不能跨机器使用


## 操作系统实践

- 实现支持异步任务的线程池

### Python同步原语

- 互斥锁

```python
lock = threading.Lock()
lock.acquire()
lock.release()
```

- 条件变量

```python
condition = threading.Condition()
condition.acquire()
condition.release()

condition.wait() # 等待
condition.notify() # 通知
```

### 实现线程安全的队列Queue

- 队列用于存放多个元素，是存放各种元素的“池”
- 队列可能有多个线程同时操作，因此需要保证线程安全

### 实现基本任务对象Task

任务处理逻辑

- 实现基本对象
  - 任务参数
  - 任务唯一标记uuid
  - 任务具体的执行逻辑


### 线程池简介

#### 什么是线程池

- 线程池是存放多个线程的容器
- CPU调度线程执行后不会销毁线程
- 将线程放回线程池重复利用

#### 为什么使用线程池

- 线程是稀缺资源，不应该频繁创建和销毁
- 架构解耦，线程创建和业务处理解耦，更加优雅
- 线程池是使用线程的最佳实践


### 实现任务处理线程ProcessThread

- 任务处理线程需要不断的从任务队列里取任务执行
- 任务处理线程需要有一个标记，标记线程什么时候应该停止

实现任务处理线程

- 基本属性（任务队列、标记）
- 线程执行的逻辑（run）
- 线程停止（stop）

### 实现任务处理线程池Pool

### 编写测试用例

### 实现异步任务处理AsyncTask

- 不知道任务什么时候执行
- 不知道任务什么时候执行完成

操作

- 给任务添加一个标记，任务完成后，则标记为已完成
- 任务完成时，可直接获取任务运行结果
- 任务未完成时，获取任务结果，会阻塞获取线程

实现AsyncTask

- 设置运行结果（set_result）
- 获取运行结果（get_result）



代码：https://github.com/Cuiks/review