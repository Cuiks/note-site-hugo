[{"categories":null,"content":" 分布式系统中出现哪些故障会导致数据不一致 分布式理论基础 常见的分布式解决方案 ","date":"2021-07-18","objectID":"/distributed-system/:0:0","tags":["分布式"],"title":"分布式系统基础","uri":"/distributed-system/"},{"categories":null,"content":"分布式系统中出现哪些故障会导致数据不一致 网络问题 - 硬件故障、网络抖动、网络拥塞 消息发送失败 消息发送成功，接收返回失败 程序出错 代码异常 宕机，服务器异常 断电 系统问题，磁盘满了等 ","date":"2021-07-18","objectID":"/distributed-system/:0:1","tags":["分布式"],"title":"分布式系统基础","uri":"/distributed-system/"},{"categories":null,"content":"分布式理论基础cap理论 cap理论是分布式系统的理论基石 Consistency（一致性） “all nodes see the same data at the same time”。 更新操作成功并放回客户端后，所有节点在同一时间的数据完全一致，这就是分布式的一致性。 对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。 从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。 Availability（可用性） “reads and writes always succeed” 服务一致可用，而且正常响应。 Partition Tolerance（分区容错性） 分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。 分区容错性要求能够使应用虽然是一个分布式系统，而看上去好像是一个可以运转正常的整体。 取舍策略 CA： 如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的 但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，违背分布式系统设计初衷 Oracle、MySQL CP： 不要求A（可用），相当于每个请求都需要在服务器之间保持强一致性。而P（分区）会导致同步时间无限延长。 最典型的就是分布式数据，如Redis、HBase等，对于这些分布式数据库，数据一致性是最基本的要求 NoSQL、Mongo DB、HBase、Redis AP： 高可用并允许分区，则需分放弃一致性 一旦分区发生，节点之前可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致 NoSQL、Coach DB、Cassandra、DynamoDB Base理论 BASE是Basically Available（基本可用）、Soft state（软状态）、Eventually consistent（最终一致性） BASE理论是对CAP中一致性和可用性权衡的结果，是基于CAP理论逐步演化而来的 BASE理论核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 BASE理论三要素： 基本可用 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但不等价于系统不可用 软状态 软状态是指允许系统中的数据存在中间状态，并认为该中间状态的存在不影响系统整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。 最终一致性 最终一致性强调的是所有数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。 总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事务ACID特性是相反的，它通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一直状态。 同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。 ","date":"2021-07-18","objectID":"/distributed-system/:0:2","tags":["分布式"],"title":"分布式系统基础","uri":"/distributed-system/"},{"categories":null,"content":"常见的分布式解决方案两阶段提交（2PC，Two-phase Commit） 两阶段提交又称2PC，2PC是一个非常经典的中心化的原子提交协议 中心化是指协议中有两类节点：一个是中心化协调者节点（coordinator）和N个参与者节点（partcipant） 两个阶段 第一阶段：投票阶段 第二阶段：提交/执行阶段 举例： 订单服务A，需要调用支付服务B去支付，支付成功则处理购物订单状态为待发货状态，否则就需要将购物订单处理为失败状态。 第一阶段：投票阶段 第一阶段分为三步 事务询问： 协调者向所有的参与者发送事务预处理请求，称为Prepare，并开始等待各参与者的响应 执行本地食物： 各个参与者执行本地事务操作，但是执行完成后不会真正的提交数据库本身事务（commit），而是先向协调者报告说：是否可以处理 各参与着向协调者反馈事务询问的响应： 如果参与者成功执行事务，则反馈Yes，表示事务可以执行，否则返回No。 第一阶段执行完后，有两种可能：1、都返回Yes 2、有一个或者多个返回No 第二阶段：提交/执行阶段（前提：第一阶段都返回Yes） 第二阶段分为两步 所有参与者返回Yes，那么就会执行事务提交 协调者向所有参与者发出Commit请求 事务提交 参与者收到Commit请求之后，就会正式执行本地食物Commit操作，并在完成提交之后释放整个事务执行期间占用资源 第二阶段：提交/执行阶段（第一阶段有参与者返回No，或者等待超时之后，没有返回） 异常流程第二阶段也分为两步 发送回滚请求 协调者向所有参与者节点发出RollBack请求 事务回滚 参与者收到RollBack请求，回滚本地事务 2PC缺点 性能问题 所有参与者资源和协调者字段都是被锁住的，只有当所有节点准备完毕，事务协调者才会通知全局提交 单节点故障 由于协调者重要性，一旦协调者发生故障，参与者会一直阻塞下去 尤其在第二阶段，协调者故障，会导致所有参与者出于锁定事务资源的状态中，而无法继续完成事务操作 2PC出现单点问题的三种情况 协调者正常，参与者宕机 由于协调者无法收集到参与者的反馈，会陷入阻塞情况 解决方案 引入超时机制 协调者宕机，参与者正常 无论出于那个阶段，协调者宕机，无法发送提交请求，所有处于未提交状态的参与者都会陷入阻塞的情况 解决方案 引入协调者备份，同时协调者需记录操作日志 协调者和参与者都宕机 发生在第一阶段：因为所有参与者都没有真正执行Commit，所以只要重新在剩余的参与这种选举一个协调者，继续执行 发生在第二阶段，并且挂了的参与者在挂掉之前没有收到协调者的指令：新的协调者需要重新执行第一阶段和第二阶段 发生在第二阶段，并且部分参与者以及执行完commit操作：2PC无法解决。 TCC补偿模式 场景：一个订单支付之后，我们需要做下面的步骤： 更改订单的状态为“已支付” 扣减商品库存 给会员增加积分 创建销售出库单通知仓库发货 即 订单服务-修改订单状态 库存服务-扣减库存 积分服务-增加积分 仓储服务-创建销售出库单。 TCC实现阶段一：Try 订单服务把订单状态改为UPDATING，表示修改中的意思，而不是支付成功 库存服务也不是直接扣减库存，而是冻结库存，库存表添加一个冻结库存字段 积分服务不直接给用户增加积分，而是积分表里加一个与增加积分字段 仓储服务也添加一个中间状态 TCC实现阶段二：Confirm 订单服务增加Confirm逻辑，把订单正式修改为“已支付” 库存服务吧冻结库存减为0 积分服务类似 仓储服务把出库单修改状态位“已创建” TCC实现阶段三：Cancel 如果以上操作出现异常： 订单服务需要提供Cancel逻辑可以把订单修改为“CANCELED” 库存服务提供逻辑把冻结库存归还 积分服务取消预增加积分 仓储服务吧出库修改为“CANCELED” TCC优点 解决了跨服务的业务操作原子性问题 TCC的本质原理是把数据库的二阶段提交上升到微服务来实现，避免了数据库二阶段中锁冲突的长事务低性能风险 TCC异步性能高 TCC缺点 对微服务的侵入性强，微服务每个事务都必须实现try、confirm、cancel等3个方法，开发及维护改造成本高 为了达到事务的一致性要求，try、confirm、cancel接口必须实现等幂性操作（定时器+重试） 有序事务管理器要记录事务日志，必定会损耗一定的性能，并使得整个TCC事务时间拉长，建议采用redis的方式来记录事务日志 tcc需要通过锁来确保数据一致性，会导致性能不高 给予本地消息表最终一致性 该方案核心是通过本地事务摆正数据业务操作和消息的一致性，最后通过定时任务将消息发送至消息中间件，待确认消息发送给消费方成功再将消息删除 以注册积分为例 用户注册 用户服务在本地新增用户和增加“消息基本日志”。（用户表和消息表通过本地事务保持一致） 本地数据库操作与存储积分消息日志出于同一事务中，本地数据库操作与记录消息日志操作具备原子性 定时任务扫描日志 定时对消息日志表中的消息进行扫描并发送至消息中间件，在消息中间件反馈成功后删除消息 消费消息 可以使用MQ的ack(确认消息)机制，消费者监听MQ，如果消费者接收到消息并且业务处理完成后向MQ发送ack，说明消费者正常消费消息完成，MQ将不再向消费者推送消息，否则会不断重试向消费者来发送消息 上述方案基本避免了分布式事务，实现了“最终一致性” 但是关系型数据的吞吐量和性能方面存在瓶颈，频繁的读写消息回给数据库造成压力。所以，在真正的高并发场景下，该方案也存在瓶颈和限制 最大努力通知 充值例子 交互流程 账户系统调用充值系统接口 充值系统完成支付处理向账户系统发起充值结果通知，若通知失败，则充值系统按策略进行重复通知 账户系统接收到充值结果通知修改充值状态。 账户系统未接收到通知会主动调用充值系统的接口查询充值结果。 目标 发起通知方通过一定的机制最大努力将业务处理结果通知到接收方 具体包括 有一定的消息重复通知机制。因为接收通知方可能没有接收到通知，此时要有一定的机制对消息重复通知。 消息校对机制。如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求。 最大努力通知与可靠消息一致性有什么不同？ 解决方案思想不同 可靠消息一致性，发起通知方需要保证将消息发出去，并且将消息发到接收通知方，消息的可靠性关键由发起通知方来保证。 最大努力通知，发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，通知的可靠性关键在接收通知方。 两者的业务应用场景不同 可靠消息一致性关注的是交易过程的事务一致，以异步的方式完成交易 最大努力通知关注的是交易后的通知事务，即将交易结果可靠的通知出去 技术解决方向不同 可靠消息一致性要解决消息从发出到接收的一致性，即消息发出并且被接收到。 最大努力通知无法保证消息从发出到接收的一致性，只提供消息接收的可靠性机制。可靠机制是，最大努力的将消息通知给接收方，当消息无法被接收方接收时，由接收方主动查询消息（业务处理结果） 解决方案 采用MQ的ack机制就可以实现最大努力通知 方案1 利用MQ的ack机制由MQ向接收通知方发送通知 发起通知方将通知发给MQ。使用普通消息机制将通知发给MQ。 接收通知方监听 MQ。 接收通知方接收消息，业务处理完成回应ack。 接收通知方若没有回应ack则MQ会重复通知。（MQ会按照间隔1min、5min、10min、30min、1h、2h、5h、10h的方式，逐步拉大通知间隔 ，直到达到通知要求的时间窗口上限。） 接收通知方可通过消息校对接口来校对消息的一致性。 方案2 利用MQ的ack机制，与方案1不同的是应用程序向接收通知方发送通知 发起通知方将通知发给MQ。 通知程序监听 MQ，接收MQ的消息。（方案1中接收通知方直接监听MQ，方案2中由通知程序监听MQ。通知程序若没有回应ack则MQ会重复通知。） 通知程序通过互联网接口协议（如http、webservice）调用接收通知方案接口，完成通知。通知程序调用接收通知方接口成功就表示通知成功，即消费MQ消息成功，MQ将不再向通知程序投递通知消息。 接收通知方可通过消息校对接口来校对消息的一致性。 方案1和方案2的不同点： 方案1中接收通知方与MQ接口，即接收通知方案监听 MQ，此方案主要应用与内部应用之间的通知。 方案2中由通知程序与MQ接口，通知程序监听MQ，收到MQ的消息后由通知程序通过互联网接口协议调用接收通知方。此方案主要应用于外部应用之间的通知，例如支付宝、微信的支付结果通知。 基于可靠消息最终一致性方案 RocketMQ事务消息设计则主要是为了解决Producer端的消息发送与本地事务执行的原子性问题，RocketMQ的设计中broker与producer端的双向通信能力，使得broker天生可以作为一个事务协调者存在 RocketMQ本身提供的存储机制为事务消息提供了持久化能力；RocketMQ的高可用机制以及可靠消息设计则为事务消息在系统发生异常时依然能够保证达成事务的最终一致性 在RocketMQ 4.3后实现了完整的事务消息，实际上其实是对本地消息表的一个封装，将本地消息表移动到了MQ内部，解决Producer端的消息发送与本地事务执行的原子性问题。 以注册送积分为例。Producer即MQ发送方，本例中是用户服务，负责新增用户。MQ订阅方即消息消费方，本例中是积分服务，负责新增积分。 Producer发送事","date":"2021-07-18","objectID":"/distributed-system/:0:3","tags":["分布式"],"title":"分布式系统基础","uri":"/distributed-system/"},{"categories":null,"content":" 内部数据结构 内存映射数据结构 Redis数据类型 功能的实现 内部运作机制 ","date":"2021-07-14","objectID":"/redis_design_and_implement/:0:0","tags":["redis","读书笔记"],"title":"Redis设计与实现","uri":"/redis_design_and_implement/"},{"categories":null,"content":"1、内部数据结构1.1 简单动态字符串1.1.1 sds的用途 sds（Simple Dynamic String）简单动态字符串 Redis底层所使用的的字符串表示 用途 实现字符串对象 用作char*类型替代品 1.1.2 Redis中的字符串 sds的实现 typedef char *sds struct sdshdr { int len; // buf已占用长度 int free; // bug剩余可用长度 char buf[]; //实际保存字符串数据的地方 } 1.1.3 优化追加操作 如果free空间足够，无须再分配空间。如果不够计算新字符串的总长度。 如果追加字符串小于1M，分配多余所需空间一倍(新字符串长度1倍)的空间。否则，额外多分配1MB。 1.1.4 sds模块的API 1.1.5小结 Redis的字符串表示为sds，而不是C字符串（以\\0结尾的char*） 对比C字符串，sds有以下特性 可以高效计算长度 可以高效执行追加操作 二进制安全 sds为追加操作进行优化：加快追加操作速度，并降低内存分配的次数。代价是多占用内存，并且这些内存不会被主动释放 1.2 双端链表1.2.1 双端链表的应用 实现Redis的列表类型 Redis列表使用两种数据结构作为底层实现 双端链表 压缩列表 创建新的列表键时，优先考虑使用压缩列表，在有需要的时候在转换为双端链表 Redis自身功能的构建 事务模块保存命令 服务器模块保存多个客户端 订阅/发送模块保存订阅模式的多个客户端 事件模块保存时间事件 。。。 1.2.2 双端链表的实现双端链表的实现由listNode和list两个数据结构构成 listNode是双端链表的节点 typedef struct listNode{ struct listNode *prev; // 前驱结点 struct listNode *next; // 后继节点 void *value; // 值 } listNode; value的属性是void *，说明对保存的值的类型不做限制 list是双端链表本身 typedef struct list{ listNode *head; //表头指针 listNode *tail; //表尾指针 unsigned long len; // 节点数量 void *(*dup)(void *ptr); // 复制函数 void (*free)(void *ptr); // 释放函数 int (*match)(void *ptr, void *key); // 比对函数 } list; 双端链表API 1.2.3 迭代器Redis为双端链表实现了一个迭代器，可以从两个方向进行迭代 沿着next指针从表头向表尾 沿着prev指针从表尾向表头 结构定义： typedef struct listIter { listNode *next; //下一节点 int direction; // 迭代方向 } listIter; direction选项 adlist.h/AL_START_HEAD 从表头到表尾 adlist.h/AL_START_TAIL 从表尾到表头 迭代器API ![image-20210708163935798](/Users/cks/Library/Application Support/typora-user-images/image-20210708163935798.png) 1.2.4 小结 Redis实现了自己的双端链表 双端链表的主要作用 列表类型的底层实现之一 作为通用数据结构，被其他功能模块使用 双端链表及其节点的性能特性 访问前驱结点和后继节点复杂度都是O(1)，并且对链表的迭代可以从表头和表尾两个方式开始 对表头和表尾处理的复杂度为O(1) 计算链表长度复杂度O(1) 1.3 字典1.3.1 字典的应用字典应用广泛 实现数据库键空间 数据库中键值对由字典保存，每个数据库都有一个与之相对的字典，成为键空间 用作Hash类型键的一种底层实现 Redis的Hash类型键使用两种数据结构作为底层实现 字典 压缩列表 创建新的Hash键时,默认使用压缩列表作为底层实现，有需要再转换字典 1.3.2 字典的实现实现方法有多种： 最简单，使用链表或数组，但是只适用于元素个数不多的情况 兼顾高效和简单，使用哈希表 最求稳定性并且希望高效地实现排序，可以使用平衡树 Redis选择了高效且简繁的哈希表作为字典的底层实现。 typedef struct dict { dictType *type; // 特定于类型的处理函数 void *privdata; // 类型处理函数的私有数据 dictht ht[2]; // 哈希表(2个) int rehashidx; // 记录rehash进度的标志，值为-1表示rehash未进行 int iterators; // 当前正在运作的安全迭代器数量 } dict; dict的API 哈希表的实现 // dict.h/dicht typedef struct dictht { dictEntry **table; // 哈希表节点指针数组（俗称桶，bucket） unsigned long size; // 指针数组的大小 unsigned long sizemask; // 指针数组的长度掩码，用于计算索引值 unsigned long used; // 哈希表现有的节点数量 } dictht; table属性是一个数组，数组每个元素都是一个指向dictEntry结构的指针。 每个dictEntry都保存着一个键值对，以及一个指向另一个dictEntry结构的指针： typedef struct dictEntry { void *key; // 键 union { void *val; uint64_t u64; int64_t s64; } v; // 值 struct dictEntry *next; // 链往后继节点 } 整个字典结构： 哈希算法 Redis使用两种不同的哈希算法 MurmurHash2 32 bit 算法 https://github.com/aappleby/smhasher 基于djb算法实现的一个大小写无关散列算法 http://www.cse.yorku.ca/~oz/hash.html 使用哪种算法取决于具体应用所处理的数据： 命令表以及Lua脚本缓存使用算法2 数据库、集群、哈希键、阻塞操作等功能使用算法1 1.3.3 创建新字典dict *d = dictCreate(\u0026hash_type, NULL) 1.3.4 添加键值对到字典添加流程： 如果字典未初始化(即字典的0号哈希表的table属性为空)，那么程序需要对0号哈希表进行初始化 如果在插入时发生了键碰撞，那么程序需要处理碰撞 如果插入新元素使得字典满足rehash条件，那么需要启动响应的rehash程序 1.3.5 添加新元素到空白字典当第一次往空字典里添加键值对时，程序会根据dict.h/DICT_HT_INITIAL_SIZE里指定的大小为d-\u003eht[0]-\u003etable分配空间（目前为值4）。 1.3.6 添加新键值对时发生碰撞处理使用链地址法，将新的键值对链接到存在的键值对上。 1.3.7 添加新键值对时触发了rehash操作 对于使用链地址法来解决碰撞问题的哈希表，性能依赖于它的大小(size属性)和它所保存的节点的数量(used属性)之间的比率： 比率1:1，哈希表性能最好 如果节点数量比哈希表大小要大很多，哈希表就会退化成多个链表，性能优势不再存在 为了保证性能，字典需要对所使用的的哈希表(ht[0])进行rehash操作：在不修改任何键值对的情况下，对哈希表进行扩容，尽量将比率维持在1:1左右。 每次向字典添加新键值对都会进行检查，对于ht[0]的size和used属性，ratio = used/size满足一下任何一个条件，激活rehash: 自然rehash： ratio \u003e= 1， 且变量dict_can_resize为真 在BGSAVE、BGREWRITEAOF时，dict_can_resize会暂时设为假，为了最大化利用系统的copy on write机制，减少程序对内存的碰撞。 强制rehash：ratio大于变量dict_force_resize_ratio(目前默认为5)。 1.3.8 rehash执行过程执行步骤： 创建一个比ht[0]-\u003etable更大的ht[1]-\u003etable 为ht[1]-\u003etable分配空间至少是ht[0]-\u003eused的两倍 将ht[0]-\u003etable中的键值对迁移到ht[1]-\u003etable 将原有的ht[0]的数据清空，并将ht[1]替换为新的ht[0] 释放ht[0]的空间 用ht[1]来代替ht[0] 创建新的哈希表，设置为ht[1] 将字典的rehashidx属性设置为-1，标识rehash已停止 1.3.9 渐进式rehash rehash程序不是在激活只会就马上执行知道完成的，而是分多次、渐进式地完成 添加键值对触发rehash需要用户等很久不合理 服务器阻塞不可接受 渐进式rehash由_dictRehashStep和 dictRehashMilliseconds两个函数进行 _dictRehashStep用于对数据库字典、以及哈希表的字典进行被动rehash dictRehashMilliseconds由Redis服务器常规任务程序(server ","date":"2021-07-14","objectID":"/redis_design_and_implement/:0:1","tags":["redis","读书笔记"],"title":"Redis设计与实现","uri":"/redis_design_and_implement/"},{"categories":null,"content":"2、内存映射数据结构 虽然内部数据结构非常强大，但是耗费内存。对于元素本身体积不大，代价昂贵。 Redis允许使用内存映射数据结构来代替内部数据结构 内存映射数据是一系列经过特殊编码的字节序列，节省大量内存 因为内存映射数据结构复杂得多，所以占用CPU时间要多 2.1 整数集合 整数集合（ineset）用于有序、无重复地保存多个整数值。会根据元素的值，自动选择(调整)该用什么长度的整数类型保存数据。 2.1.1 整数集合的应用Intset是集合键的底层实现之一，如果一个集合满足： 只保存整数数据 元素数量不多 2.2.2 数据结构和主要操作 定义 // intset.h/intset typedef struct intset { uint32_t encoding; // 保存元素所使用的的类型的长度 uint32_t length; // 元素个数 int8_t contents[]; // 保存元素的数组 } intset; encoding的值： // intset.c # define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t)) content数组是实际保存数据的地方，特性： 没有重复元素 元素在数组中从小到大排列 content数组的int8_t类型声明做为占位符使用。程序根据encoding的值，对content进行类型转换和指针运算。 inset主要操作 2.1.3 intset 运行实例 创建新inset intset *is = intsetNew(); // intset.c/intsetNew 添加新元素到intset。intset.c/intsetAdd 处理情况 元素已存在，不做动作 元素不存在，并且添加新元素不需要升级 元素不存在，需要升级后，才能添加元素 intsetAdd需要维持intset-\u003econtents的以下性质 没有重复元素 从小到大排序 2.1.4 升级 intsetAdd发现新元素不能用现有编码方式保存，就会使用intsetUpgradeAndAdd函数升级 intsetUpgradeAndAdd任务 检测新元素需要编码类型 设置encoding属性为新编码类型，根据新编码类型对整个contents数组进行内存重分配 调整contents数组原有元素在内存中排列方式，从旧编码调整为新编码 将新元素添加到集合 2.1.5 关于升级 从较短整数到较长整数的转换，并不会更改元素里面的值 集合编码元素的方式，由元素中长度最大的那个值来决定 2.1.6 关于元素移动 元素移动不仅出现在升级(intsetUpgradeAndAdd)操作中，还出现在对contents数组的增删(intsetAdd和intsetRemove)操作上。复杂度都不低于O(n) 2.1.7 其他操作 读取 _intsetGet：接受一个索引pos，根据intset-\u003eencoding的值进行指针运算，计算出给定索引的值。 intsetSearch 二分查找，判断元素的索引 写入 _intsetSet：接受一个索引pos以及一个new_value，将pos位置设置为new_value 删除 intsetRemove：删除单个元素。先intsetSearch获取需要删除元素索引，然后济宁内存移位操作，最后通过内存重新分配，调整数组长度 降级 Intset不支持降级操作 2.1.8 小结 Intset用于有序、无重复地保存多个整数值，它会根据元素的值，自动选择该用什么长度 的整数类型来保存元素。 当一个位长度更长的整数值添加到 intset 时，需要对 intset 进行升级，新 intset 中每个 元素的位长度都等于新添加值的位长度，但原有元素的值不变。 升级会引起整个 intset 进行内存重分配，并移动集合中的所有元素，这个操作的复杂度 为 O(N) 。 Intset只支持升级，不支持降级。 Intset 是有序的，程序使用二分查找算法来实现查找操作，复杂度为 O(lg N) 。 2.2 压缩列表 Ziplist是由一系列特殊编码的内存块构成的列表 一个ziplist可以包含多个节点entry 每个节点可以保存一个长度首先的字符数组或者整数 字符数组 长度小于等于 63 （2 6− 1）字节的字符数组 长度小于等于 16383 （2 14− 1）字节的字符数组 长度小于等于 4294967295 （2 32− 1）字节的字符数组 整数 4 位长，介于 0 至 12 之间的无符号整数 1 字节长，有符号整数 3 字节长，有符号整数 int16_t 类型整数 int32_t 类型整数 int64_t 类型整数 因为ziplist节省内存。被哈希键、列表建、有序集合键作为初始化的底层实现来使用 2.2.1 ziplist的构成 ziplist宏： 操作ziplist的函数 2.2.2 节点的构成 pre_entry_length 记录了前一个节点的长度。通过这个值可以进行指针运算，从而跳转到上一个节点 encoding content部分数据类型 length content部分数据长度 content 保存节点内容 2.2.3 创建新 ziplist ziplistNew 2.2.4 将节点添加到末端 记录到达末端所需的偏移量 根据需要保存的值，计算所需的空间大小以及编码它前一个节点的长度所需的空间大小，然后进行内存重分配 设置新节点的各项属性 更新ziplist的各项属性 2.2.5 将节点添加到某个/某些节点的前面 为新节点扩大ziplist的空间 设置新节点的各项属性 更新新节点到ziplist。更新next节点的pre_entry_length pre_entry_length正好够新元素的长度 pre_entry_length只有1字节长，新元素需要5字节 pre_entry_length有5字节长，新元素需要1字节 1、3情况，直接更新pre_entry_length。2情况需要对ziplist进行内存重分配，从next开始往后逐个判断是否扩展长度。所以复杂度为O(n^2) 更新ziplist各项属性 2.2.6 删除节点 定位目标节点，计算节点的空间长度 进行内存移位覆盖原本数据，然后内存重新分配，收缩多余空间 检查next、next+1等后续节点是否满足新前驱节点的编码。类似添加操作，也会引起连锁更新。 2.2.7 遍历 可以对ziplist进行从前向后的遍历，或者从后向前的遍历。 2.2.8 查找元素，根据值定位节点 类似遍历原理 2.2.9 小结 ziplist 是由一系列特殊编码的内存块构成的列表，它可以保存字符数组或整数值，它还是 哈希键、列表键和有序集合键的底层实现之一。 ziplist 的结构 ziplist 的节点entry结构 添加和删除ziplist 节点有可能会引起连锁更新，因此最坏复杂度O(n^2)。不过连锁更新概率不高，所以可以视为O(n) ","date":"2021-07-14","objectID":"/redis_design_and_implement/:0:2","tags":["redis","读书笔记"],"title":"Redis设计与实现","uri":"/redis_design_and_implement/"},{"categories":null,"content":"3、Redis数据类型3.1 对象处理机制 问题 Redis必须让每个键都带有类型信息，使得程序可以检查键的类型，并为它选择合适的处理方式 需要根据数据类型的不同编码进行多态处理 为了解决上述问题，Redis构建了自己的类型系统，主要功能： redisObject对象 基于redisObject对象的类型检查 基于redisObject对象的显式多态函数 对redisObject进行分配、共享和销毁的机制 3.1.1 redisObject数据结构，以及Redis的数据类型 定义 // redis.h typedef struct redisObject { unsigned type:4; // 类型 unsigned notused:2; // 对齐位 unsigned encoding:4; // 编码方式 unsigned lru:22; // LRU时间(相对于 server.lruclock) unsigned refcount; // 引用计数 void *ptr; // 指向对象的值 } robj; type记录了对象所保存的值的类型 #define REDIS_STRING 0 // 字符串 #define REDIS_LIST 1 // 列表 #define REDIS_SET 2 // 集合 #define REDIS_ZSET 3 // 有序集 #define REDIS_HASH 4 // 哈希表 encoding记录了对象所保存的值的编码 #define REDIS_ENCODING_RAW 0 // 编码为字符串 #define REDIS_ENCODING_INT 1 // 编码为整数 #define REDIS_ENCODING_HT 2 // 编码为哈希表 #define REDIS_ENCODING_ZIPMAP 3 // 编码为 zipmap #define REDIS_ENCODING_LINKEDLIST 4 // 编码为双端链表 #define REDIS_ENCODING_ZIPLIST 5 // 编码为压缩列表 #define REDIS_ENCODING_INTSET 6 // 编码为整数集合 #define REDIS_ENCODING_SKIPLIST 7 // 编码为跳跃表 ptr是一个指针，指向实际保存值的数据结构，这个数据结构由type属性和encoding属性决定 3.1.2 命令的类型检查和多态 当执行一个处理数据类型的命令时： 根据给定的key，在数据字典查找redisObject，如果没找到返回NULL 检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误 根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构 返回数据结构的操作结果作为命令的返回值 3.1.3 对象共享 Flyweight 模式 通过预分配一个常见的值对象，并在多个数据结构之间共存这些对象，避免重复分配，也节约CPU时间 Redis预分配的值对象 各种命令的返回值。OK、ERROR等 包括0在不，小于redis.h/REDIS_SHARED_INTEGERS的所有整数。（默认10000） 共享对象只能被带指针的数据结构使用。 3.1.4 引用计数以及对象的销毁 问题 redisObject用作数据库的键或者值，生命周期非常长，C语言本身没有自动释放内存的相关机制 对象的引用次数问题 解决方案。使用引用计数技术负责维持和销毁对象 每个redisObject都有一个refcount属性，记录被引用次数 新建对象，refcount值为1 对一个对象进行共享时， refcount加一 当用完一个对象之后，或者取消引用之后，程序对对象的refcount减一 当对象的refcount降至0时，这个redisObject以及它所引用的数据结构的内存，就会被释放 3.1.5 小结 Redis使用自己实现的对象机制来实现类型判断、命令多态和基于引用计数的垃圾回收。 一种 Redis 类型的键可以有多种底层实现 Redis 会预分配一些常用的数据对象，并通过共享这些对象来减少内存占用，和避免频繁 地为小对象分配内存。 3.2 字符串 REDIS_STRING是Redis使用最广泛的数据类型 3.2.1 字符串编码 字符串类型分别使用REDIS_ENCODING_INT和REDIS_ENCODING_RAW两种编码 REDIS_ENCODING_INT使用long类型来保存long类型值 REDIS_ENCODING_RAW使用sdshdr结构来保存sds(char *)、long long、double、long double类型 3.2.2 编码的选择 新创建的字符串默认使用REDIS_ENCODING_RAW编码 在字符串作为键或者值保存进数据库时，会尝试转为REDIS_ENCODING_INT 3.2.3 字符串命令的实现 通过包装sds数据结构的操作函数来实现 3.3 哈希表 REDIS_HASH是HSET、HLEN等命令的操作对象，它使用REDIS_ENCODING_ZIPLIST (压缩列表)和 REDIS_ENCODING_HT (字典)两种编码方式 3.3.1 字典编码的哈希表 当使用字典编码时，程序将哈希表的键保存为字典的键，哈希表的值保存为字典的值 3.3.2 压缩列表编码的哈希表 程序将键和值一同推入压缩列表，从而形成保存哈希表所需的键值对结构 新添加的键值对会被添加到压缩列表的表尾 当进行查找/删除或者更新操作时，程序先定位到键的位置，然后在通过对键的位置来定位值的位置 3.3.3 编码的选择 创建空白哈希表，默认使用REDIS_ENCODING_ZIPLIST。 满足以下任何一个条件，编码会切换为REDIS_ENCODING_HT： 哈希表中的某个键或者某个值的长度大于server.hash_max_ziplist_value(默认64) 压缩列表中的节点数量大于server.hash_max_ziplist_entries (默认512) 3.3.4 哈希命令的实现 对字典和压缩列表操作函数的封装，以及在两种编码之间进行转换的函数 3.4 列表 REDIS_LIST是LPUSH、LRANGE等命令的操作对象，它使用REDIS_ENCODING_ZIPLIST 和 REDIS_ENCODING_LINKEDLIST这两种方式编码 3.4.1 编码的选择 默认使用REDIS_ENCODING_ZIPLIST 满足以下任一条件，会转换为REDIS_ENCODING_LINKEDLIST 新增字符串长度超过server.list_max_ziplist_value (默认64) ziplist包含的节点超过 server.list_max_ziplist_entries (默认值512) 3.4.2 列表命令的实现 两种底层实现的抽象方式和列表的抽象方式非常接近，所以列表命令几乎就是通过一对一 地映射到底层数据结构的操作来实现的 3.4.3 阻塞的条件 BLPOP 、BRPOP 和 BRPOPLPUSH三个命令都可能造成客户端被阻塞，以下将这些命令统 称为列表的阻塞原语。 阻塞原语并不是一定会造成客户端阻塞： 只有当这些命令并用于空列表时，才会阻塞客户端 如果被处理的列表不为空，就执行物阻塞版本的LPOP 、RPOP或RPOPLPUSH命令 3.4.4 阻塞 当一个阻塞原语的处理目标为空键时，执行该阻塞原语的客户端就会被阻塞 阻塞一个客户端需要执行的步骤 将客户端设置为“正在阻塞”，并记录阻塞客户端的各个键以及阻塞的最长时限 将客户端的信息记录到server.db[1]-\u003eblocking_keys中（其中i为客户端所使用的的数据库号码） 继续维持客户端和服务端之间的网络连接，但不在向客户端传送任何信息，造成客户端阻塞 客户端脱离阻塞状态的方法： 被动脱离：其他客户端为造成阻塞的键推入了新元素 主动脱离：超过最大阻塞时间 强制脱离：客户端强制终止和服务器的链接，或者服务器停机 3.4.5 阻塞因LPUSH、RPUSH、LINSERT等添加命令而被取消 这三个添加新元素到列表命令底层都是由pushGenericCommand函数实现 当向一个空键推入新元素时，该函数执行两件事： 检查键是存在于server.db[i]-\u003eblocking_keys字典里，如果有，为这个键创建一个redis.h/readyList结构，并将它添加到server.ready_keys链表中。 将给定的值添加到列表键中 readyList结构定义： typedef struct readyList { redisDb *db; // 指向该键所在的数据库 robj *key; // 指向造成阻塞的键 } readyList; Redis主进程执行完pushGenericCommand函数后，继续调用handleClientsBlockedOnLists： 如果server.ready_keys不为空，弹出表头元素，并取出元素中的readyList值 根据readyList在server.blocking_keys中查找因为key被阻塞的客户端（以链表形式保存） 如果key不为空，弹出一个元素，并弹出客户端链表的第一个客户端，然后将被弹出的元素返回给被弹出客户端作为阻塞原语的返回值 根据readyList结构的属性，删除server.blocking_","date":"2021-07-14","objectID":"/redis_design_and_implement/:0:3","tags":["redis","读书笔记"],"title":"Redis设计与实现","uri":"/redis_design_and_implement/"},{"categories":null,"content":"4、功能的实现4.1 事务 Redis通过MULTI、DISCARD、EXEC、WATCH四个命令来实现事务功能 4.1.1 事务 事务提供一种“将多个命令打包，然后一次性、按顺序地执行”的机制，并且事务在执行期间不会主动终端—服务器在执行完事务中所有的命令后，才会继续处理其他客户端的其他命令 事务执行阶段 开始事务 命令入队 执行事务 4.1.2 开始事务 WATCH命令的执行标记着事务的开始 这个命令唯一做的，将客户端REDIS_MULTI选项打开，让客户端从非事务状态切换到事务状态 4.1.3 命令入队 当客户端处于非事务状态时，所有发送给服务端的命令都会立即被执行 当客户端处于事务状态时，服务器在收到客户端命令时，不会立即执行，而是将这些命令全部让如一个事务队列，然后返回QUEUED，表示命令已入队 事务队列是一个数组，每个元素包含三个属性 要执行的命令（cmd） 命令的参数（argv） 参数的个数（argc） 4.1.4 执行事务 不是所有命令都会被放入事务队列：EXEC、DISCARD、MULTI、WATCH这四个命令会被立即执行 当EXEC命令执行时 服务器根据客户端所保存的事务队列，以先进先出（FIFO）方式执行 4.1.5 在事务和非事务状态下执行命令 无论事务状态还是非事务状态，Redis命令都是由同一个函数执行，所以他们共享服务器一般配置，比如AOF配置、RDB配置以及内存限制等 事务中的命令和普通命令区别： 非事务状态下的命令以单个命令为单位执行，前一个命令和后一个的客户端不一定是同一个；事务状态则是以事务为单位：除非当前事务执行完毕，否则服务器不会中断事务，也不会执行其他客户端的其他命令。 非事务状态下，执行命令结果立即返回给客户端；事务状态下所有命令的结果集合到回复队列，在做EXEC命令的结果返回客户端。 4.1.6 事务状态下的DISCARD、MULTI、WATCH DISCARD用于取消一个事务，清空客户端的整个事务队列，然后将客户端从事务状态调整回非事务状态，最后返回OK Redis的事务不可嵌套。事务状态下发送MULTI，服务器只是简繁返回错误，然后继续等待其他命令入队。不会造成事务失败或修改 WATCH只能在客户端进入事务之前执行，否则会引发错误。但它不会造成事务失败，也不会修改事务队列已有数据。 4.1.7 带WATCH的事务 WATCH命令用于在事务开始之前监视任意数量的键：当调用EXEC命令执行事务时，如果任意一个被监视的键已经被其他客户端修改了，那么整个事务不在执行，直接返回失败。 4.1.8 WATCH命令的实现 在每个数据库redis.h/redisDb的数据类型中，保存了一个watched_keys字典，字典的键时整个数据库被监视的键，字典的值则是一个链表，链表中保存了所有监视这个键的客户端。 WATCH命令的作用就是：将当前客户端和要监视的键在watched_keys中进行关联 4.1.9 WATCH的触发 在任何对数据库键空间进行修改的命令成功执行之后，multi.c/touchWatchKey函数都会被调用，它检查数据库的watched_keys字典，看是否有客户端在监视已经被命令修改的键，如果有，程序将所有监视这个键的客户端的REDIS_DIRTY_CAS选项打开 当客户端发送EXEC命令、出发事务执行时，会对客户端状态进行检查 如果REDIS_DIRTY_CAS被打开，直接返回空回复，表示事物执行失败 如果REDIS_DIRTY_CAS没有打开，说明安全，正式执行事务 最后，当一个客户端结束他的事务时，无论事务成功失败，watched_keys字典中和这个客户端有关的资料都会别清除 4.1.10 事务的ACID性质 原子性（Atomicity） 单个Redis命令的执行事原子性的，但Redis没有在事务上增加任何维持原子性的机制，所以Redis事务不是原子性的 如果一个事务队列所有命令都被成功执行，那么称这个事务执行成功 如果Redis服务器进程在执行事务过程中被停止，那么事务执行失败 事务失败时，Redis也不会进行任何的重试或者回滚操作 一致性（Consistency） Redis的一致性：入队错误、执行错误、Redis进程被终结 入队错误 在命令入队时，如果客户端发送错误的命令，服务端会向客户端返回一个出错信息，并且将客户端的事务状态设置为REDIS_DIRTY_EXEC 当客户端执行EXEC时，Redis拒绝执行状态为REDIS_DIRTY_EXEC的事务，并返回失败信息 因此，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性 执行错误 如果命令在事务执行过程中发生错误，Redis只会将错误包含在事务的结果中，不会引起事务的中断或整个失败 不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令 所以它对事务的一致性没有影响 Redis进程被终结 根据Redis持久化模式： 内存模式：没有任何持久化机制，重启后数据库总是空白，所以数据总是一致 RDB模式：事务进行中，不会中断Redis执行保存RDB保存工作，所以数据库是一致的 AOF模式：因为AOF后台进行： 事务语句未被写入AOF文件，还原后是一致的 事务语句被写入AOF文件。重启Redis，程序会检测AOF文件并不完整，Redis会退出，并报告错误。需要使用redis-check-aof工具将部分成功事务命令移除之后，才能再次启动服务器。还原后是一致的 隔离性（Isolation） Redis是单进程程序，并且保证执行事务时不会对事务进行中断，所以具有隔离性 持久性（Durability） 因为事务只是用队列包裹了一组Redis命令，没有提供任何额外的持久性功能，所以事务的持久性由Redis所使用的的持久化模式决定 内存模式：不持久 RDB模式：不持久 AOF模式：异步保存有时间间隔，也不持久 4.1.11 小结 事务提供一种将多个命令打包，然后一次性、有序地执行的机制 事务执行过程中不会被中断，所有事务命令执行完之后，事务才能结束 多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。 带WATCH命令的事务会将客户端和被监视的键在数据库的 watched_keys 字典中进行关 联，当键被修改时，程序会将所有监视被修改键的客户端的 REDIS_DIRTY_CAS 选项打开。 只有在客户端的 REDIS_DIRTY_CAS 选项未被打开时，才能执行事务，否则事务直接返回 失败。 Redis 的事务保证了 ACID 中的一致性（C）和隔离性（I），但并不保证原子性（A）和 持久性（D）。 4.2 订阅与发布 Redis通过PUBLISH、SUBSCRIBE等命令实现了订阅与发布模式 4.2.1 频道的订阅与信息发送 SUBSCRIBE命令可以让客户端订阅任意数量的频道 当有消息通过PUBLISH命令发送给频道时，这个消息就会被发送给订阅他的所有客户端 4.2.2 订阅频道 每个Redis服务器进程都维持这个一个表示服务器状态的redis.h/redisServer结构，结构的pubsub_channels属性是一个字典，用于保存订阅频道的信息 struct redisSercer { dict *pubsub_channels; } 字典的键为正在被订阅的频道，值为一个链表，保存了所有订阅这个频道的客户端 当客户端调用SUBSCRIBE时，程序就将客户端和要订阅的频道在pubsub_channels字典中关联起来 4.2.3 发送信息到频道 首先根据channel定位到字典的键 将信息发送给字典链表中的所有客户端 4.2.4 退订频道 UNSUBSCRIBE，从pubsub_channels字典的给定频道（键）中，删除关于当前客户端的信息 4.2.5 模式的订阅与信息发送4.2.6 订阅模式 redisServer.pubsub_patterns属性是一个链表，保存着所有和模式先关的信息 struct redisServer { list *pubsub_patterns; } 链表的每个节点都包含一个redis.h/pubsubPattern结构 typedef struct pubsubPattern { redisClient *client; // 订阅模式的客户端 robj *pattern; // 被订阅的模式 } pubsubPattern; 调用PSUBSCRIBE时，程序就创建一个包含客户端和被订阅模式的pubsubPattern结构，并将该结构添加到redisServer.pubsub_patterns链表中 4.2.7 发送信息到模式 PUBLISH 4.2.8 退订模式 PUNSUBSCRIBE 4.2.9 小结 订阅信息由服务器进程维持的redisServer.pubsub_channels字典保存，字典的键为被订阅的频道，字典的值为订阅频道的所有客户端 当有新消息发送到频道时，程序遍历频道所对应的所有客户端，然后将消息发送到订阅频道的客户端上 订阅模式的信息由服务器进程维持的redisServer.pubsub_patterns链表来保存，链表的每个节点都保存一个pubsubPattern结构。 当有新消息发送到频道时，除了订阅频道的客户端回收到消息之外，所有订阅了匹配频道的模式的客户端，也同样会收到消息 退订频道和退订模式分别的订阅频道和订阅模式的反操作 4.3 Lua脚本4.3.1 初始化Lua环境 在初始化Redis服务器时 Redis对Lua环境进行了一系列修","date":"2021-07-14","objectID":"/redis_design_and_implement/:0:4","tags":["redis","读书笔记"],"title":"Redis设计与实现","uri":"/redis_design_and_implement/"},{"categories":null,"content":"5、内部运作机制5.1 数据库5.1.1 数据库的结构 Redis中的每个数据库，都是由一个redis.h/redisDb结构表示： typedef struct redisDb { int id; // 保存着数据库以整数表示的号码 dict *dict; // 保存着数据库中的所有键值对数据。也被称为键空间 dict *expires; // 保存着键的过期信息 dict *blocking_keys; // 实现列表阻塞原语 dict *ready_keys; dict *watched_keys; // 用于MATCH命令。事务 } redisDb; 5.1.2 数据库的切换 redisDb结构的id保存着数据库的号码 Redis初始化时，会创建redis.h/REDIS_DEFAULT_DBNUM个数据库，并将所有数据库保存到redis.h/redisServer.db数组中，每个数据库id从0到REDIS_DEFAULT_DBNUM - 1 当执行SELECT number时，程序使用redisServer.db[number]来切换数据库 5.1.3 数据库键空间 Redis是键值对数据库，所以它的数据库本身也是一个字典(key space) 字典的键是一个字符串对象 字典的值则可以使包括字符串、列表、哈希表、集合、有序集在内的任意一种Redsi类型对象 redisDb结构的dict属性，保存着数据库所有的键值对数据 5.1.4 键空间的操作 因为数据库本身是一个字典，所以对数据库的操作基本上都是对字典的操作，加上一些维护操作 添加新键 删除键 更新键 取值 其他操作 FLUSHDB RANDOMKEY DBSIZE EXISTS RENAME 5.1.5 键的过期时间 EXPIRE、PEXPIRE、EXPIREAT、PEXPIREAT 5.1.6 过期时间的保存 redisDb结构的expires字典里 expires字典的键是一个执行dict字典里某个键的指针，字典的值是过期时间long long类型 5.1.7 设置生存时间 Redis有四个命令设置键的生存时间和过期时间 但是，expires字典的值只保存“以毫秒为单位的过期UNIX时间戳” 5.1.8 过期键的判定 通过expires字典，通过以下步骤检查 检查键是否在expires字典；如果存在，那么取出键的过期时间 通过与当前UNIX时间戳对比没判断是否过期 5.1.9 过期键的清除 三种删除方式 定时删除：在设置键的过期时间时，创建一个定时事件，当过期时间到达时，由事件处理器自动执行键的删除操作 惰性删除：放任键过期不管，但是在每次从dict字典取出键时，检查是否过期，过期则删除并返回空 定期删除：每隔一段时间，对expires字典进行检查，删除过期键 定时删除 对内存最友好：因为能保证过期键第一时间被删除 缺点： 对CPU时间最不友好：因为删除操作可能会占用大量的CPU时间 目前Redis事件处理器对时间事件的实现方式–无序链表，查找复杂度O(n)，不适合用来处理大量时间事件 惰性删除 对CPU最友好：只会在取出键时进行检查 缺点 对内存最不友好：内存已知占用不被释放 定期删除 上述两种的折中策略 每隔一段时间执行一次删除操作，并通过限制删除操作执行的时长和频率，来减少删除操作对CPU时间的影响 通过定期删除过期键，有效的减少内存浪费 Redis使用的策略 惰性删除 + 定期删除 5.1.10 过期键的惰性删除策略 db.c/expireIfNeeded函数。 所有命令在读取或写入数据库之前都会调用expireIfNeeded函数对键进行检查 expireIfNeeded的作用是，如果输入键过期的话，将键、值、键保存在expires字典中的过期时间都删除掉 5.1.11 过期键的定期删除策略 redis.c/activeExpireCycle函数。 每当Redis的例行处理程序serverCron执行时，activeExpireCycle都会被调用 这个函数在规定时间限制内，尽可能地遍历各个数据库的expires字典，随机的检查一部分键的过期时间，并删除其中的过期键 5.1.12 过期键对AOF、RDB和复制的影响 更新后的RDB文件 在创建RDB文件时，程序会对键进行检查，过期的键不会被写入到更新后的RDB文件中 AOF文件 过期键在被惰性删除或定期删除之前，不会有任何影响，AOF不会被修改 过期键被删除后，程序会向AOF文件追加一条DEL命令 AOF重写 重写时，程序会检查键，过期的键不会被保存到重写后的AOF文件 复制 过期键的删除由主节点统一控制 如果是主节点，它删除一个过期键后，会显式地向所有附属节点发送一个DEL命令 如果是附属节点，碰到过期键，会返回已过期的回复，但是不会删除。 5.1.13 数据库空间的收缩和扩展 字典的 扩展/收缩规则 redis.c/tryResizeHashTables函数检查数据库是否需要收缩 每次redis.c/serverCron函数运行时，被调用 5.1.14 小结 数据库主要由dict和expires两个字典构成，dict保存键值对，expires保存键的过期时间 数据库的键总是一个字符串对象，值可以使任意一种Redis数据类型，包括字符串、哈希表、集合、列表、有序集 expires的某个键和dict的某个键共同指向同一个字符串对象，而expires键的值则是该键以毫秒计算的UNIX过期时间戳 Redis使用惰性删除和定期删除两种策略来删除过期的键 更新后的RDB文件和重写后的AOF文件不会保留过期的键 当一个过期的键被删除之后，程序会追加一条新的DEL命令到AOF文件 当主节点删除一个过期键后，会显式的发送一条DEL命令到所有附属节点 附属节点发现过期键后，不会删除，而是等待主节点发来DEL命令，保证数据一致 数据库的dict和expires字典的扩展策略和普通字典一样。当填充百分比不足10%时，将可用节点数量减少至大于等于当前已用节点数量。 5.2 RDB RDB核心是rdbSave和rdbLoad函数，前者用于生成RDB文件到磁盘，后者用于将RDB文件中的数据重新载入到内存 5.2.1 保存 如果RDB文件已存在，新的RDB文件会替换已有的 RDB保存文件期间，主进程会被阻塞，知道保存完成为止 SAVE直接调用rdbSave，阻塞Redis主进程，知道保存完成为止 BGSAVE则fork出一个子进程，子进程负责调用rdbSave，并在保存完成后向主进程发送信号，通知保存已完成。 5.2.2 SAVE、BGSAVE、AOF写入、BGREWRITEFOF SAVE SAVE执行时，新的SAVE、BGSAVE、BGREWRITEAOF调用不会产生任何多用 AOF写入是后台线程完成，BGREWRITEAOF由子进程完成，所以SAVE执行过程中，AOF写入、BGREWRITEAOF可以同时进行 BGSAVE 在指向SAVE之前，服务器会检查BGSAVE是否正在执行，如果是，不调用rdbSave，向客户端返回出错信息 当BGSAVE执行时，调用新的BGSAVE的客户端也会收到出错信息 BGSAVE执行时，BGREWRITEAOF的重写请求会被延迟到BGSAVE执行完毕 BGREWRITEAOF执行时，调用BGSAVE的客户端将收到出错信息 BGREWRITEAOF和BGSAVE不同时执行时处于性能考虑 并发两个子进程，并且两个子进程都同时进行大量的磁盘写入，性能问题 5.2.3 载入 Redis服务器启动时，rdbLoad函数就会被执行，它读取RDB文件，将文件中的数据库数据载入到内存中 在载入期间， 服务器每载入 1000 个键就处理一次所有已到达的请求， 不过只有 PUBLISH 、 SUBSCRIBE 、PSUBSCRIBE 、UNSUBSCRIBE 、PUNSUBSCRIBE 五个命令的请求会被正确地处理， 其他命令一律返回错误。等到载入完成之后，服务器才会开始正常处理所有命令。 发布与订阅功能和其他数据库功能是完全隔离的，前者不写入也不读取数据库，所以 在服务器载入期间，订阅与发布功能仍然可以正常使用，而不必担心对载入数据的完整性产生 影响。 AOF保存频率通常高于RDB。如果AOF功能打开会优先使用AOF文件还原数据 5.2.4 RDB文件结构 REDIS 文件开头保存REDIS五个字符，表示RDB文件的开始 RDB-VERSION 四字节长 记录RDB版本号（目前为0006） 因为不同版本的RDB文件不兼容，所以需要根据版本来选择不同的读入方式 DB-DATA 重复多次出现 每一个DB-DATA部分保存着服务器上一个非空数据库的所有数据数据 SELECT-DB 保存着跟在后面的键值对所属的数据库号码 KEY-VALUE-PAIRS 因为空数据库不会被保存到RDB文件，所以这部分至少包含一个键值对的数据 键值对数据结构 OPTIONAL-EXPIRE-TIME：记录着过期时间。可选，没有过期时间，该域不出现 KEY：键。格式和REDIS_ENCODING_RAW编码的字符串对象一样。 TYPE-OF-VALUE：记录VALUE域的值所使用的的编码 VALUE：不同类型格式不同 EOF 标志着数据库内容的结尾，值为rdb.h/EDIS_RDB_OPCODE_EOF CHECK-SUM 校验和。uint_64t类型值 如果为0，表示Redis关闭了校验和功能 5.2.5 小结 rdbSave 会将数据库数据保存到 RD","date":"2021-07-14","objectID":"/redis_design_and_implement/:0:5","tags":["redis","读书笔记"],"title":"Redis设计与实现","uri":"/redis_design_and_implement/"},{"categories":null,"content":" 字符串、散列、列表、集合、有序集合 hyperloglog、位图、地理坐标、流 数据库自动过期、流水线与事物、LUA脚本、持久化、发布与订阅、模块 复制、Sentinel、集群 ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:0","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"字符串1、SET 为字符串键设置值 SET key value SET number “10086” 返回ok SET key value [NX|XX] NX表示对存在的key不能覆盖，对于不存在的可以设置 成功返回ok 失败返回nil XX表示对不存的key不能设置值，对于存在的可以覆盖 成功返回OK 失败返回nil O(1) 2、GET 获取字符串键的值 GET key GET number 返回键的值 或者 nil O(1) 3、GETSET 获取旧值并设置新值 GETSET key new_value O(1) 4、MSET 一次为多个字符串键设置值 MSET key value [key value … ] MSET message “hello” number “10086” 成功返回ok O(n) 5、MGET 一次获取多个字符串键的值 MGET key [key … ] MGET messgae number page 返回 “hello” “10086” nil O(n) 6、MSETNX 只有在键不存在的情况下，一次为多个字符串设置值 MSET key value [key value … ] MSET k1 “one” k2 “two” k3 “three” 只有在所有键都不存在的情况下才会设置 成功返回1。失败返回0 O(n) 7、STRLEN 获取字符串值的字节长度 STRLEN key STRLEN number 返回key的长度。不存在的key返回0 0(1) 8、 字符串值的索引 9、GETRANGE 获取字符串值指定索引范围上的内容 GETRANGE key start end GET message “hello world” GETRANGE message 0 3 “hell” GETRANGE message -11 -7 “hello” O(n) 10、SETRANGE 对字符串值的指定索引范围进行设置 SETRANGE key index substitute GET message “hello world” SETRANGE message 6 “Redis” 11 (返回字符串当前长度) GET message “hello Redis” SETRANGE命令会自动扩展被修改的字符串值，从而保证新内容可以顺利写入 SETRANGE命令会在值里面填充空字节 O(n) 11、APPEND 追加新内容到值的末尾 APPEND key suffix GET desc “Redis” APPEND desc \" is a database\" 19 GET desc “Redis is a database” 对于不存的key执行设置操作 O(n) n为新追加内容的长度 12、 使用字符串键存储数字值 13、INCRBY、DECRBY 对整数值执行加法操作和减法操作 INCRBY key increment SET number 100 OK INCRBY number 100 400 DECRBY key increment SET number 100 OK DECRBY number 10 90 类型限制 当键的值不能被Redis解释为整数时,会返回错误 不能使用除整数外的数据类型作为增量 处理不存在的键 对于不存在的键,会先把该键初始化为0,然后操作 O(1) 14、INCR、DECR 对整数值执行加1操作和减1操作 INCR key 类似INCRBY、DECRBY。只是增量固定为1 O(1) 15、INCRBYFLOAT 对数字值执行浮点数加法操作 对于浮点数减法操作，增量使用负数 INCRBYFLOAT key -1.1 INCRBYFLOAT可以操作设置为整数的key INCRBYFLOAT可以设置增量为整数 小数位长度限制 最多保留小数点后17位 O(1) ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:1","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"散列1、散列简介2、HSET 为字段设置值 HSET hash field value 如果字段不在散列中，执行创建操作，返回1 如果字段存在散列中，执行更新操作，返回0 HSET article title “greeting” 1 HSET article content “hello world” 1 HSET article count 100 1 HSET article title “redis” 0 O(1) 3、HSETNX 只在字段不存在的情况下为他设置值 HSETNX hash field value 成功返回1 失败返回0 O(1) 4、HGET 获取字段值 HGET hash field HGET article title “redis” 不存在返回nil O(1) 5、HINCRBY 对字段存储的整数值执行加法或减法操作 HINCRBY hash field increment HINCRBY article count 1 101 HINCRBY article count -6 95 O(1) 6、HINCRBYFLOAT 对字段存储的数字值执行浮点数加法或减法 O(1) 7、HSTRLEN 获取字段值的字节长度 HSTRLEN hash field HSTRLEN article title 5 – redis 字段不存在返回0 散列不存在返回0 O(1) 8、HEXISTS 检查字段是否存在 HEXISTS hash field 存在返回1 不存在返回0 O(1) 9、HDEL 删除字段 HDEL hash field 成功返回1 hash不存在或者字段不存在返回0 O(1) 10、HLEN 获取散列包含的字段数量 HLEN hash HLEN article 4 散列不存在返回0 O(1) 11、HMSET 一次为多个字段设置值 HMSET hash field value [field value … ] O(n) 12、HMGET 一次获取多个字段的值 HMGET hash field [field … ] 存在返回值 不存在返回nil O(n) 13、HKEYS、HVALS、HGETALL 获取所有字段、所有值、所有字段和值 HKEYS hash HVALS hash HGETALL hash HGETALL article “title” – key “greeting” – value “content” “hello world” 散列不存在 返回空列表 字段在散列中存放是无序的 O(n) n为散列包含的字段数量 14、 散列与字符串 ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:2","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"列表 线性有序 文字数据或二进制数据 元素可重复 1、 LPUSH 将元素推入列表左端 LPUSH list item [item item … ] 返回列表包含元素数量 一次推入多个元素 LPUSH todo key1 key2 key3 先推入key1，然后是key2，然后是key3 O(n) n为推入元素数量 2、RPUSH 将元素推入列表右端 RPUSH list item [item item … ] 返回列表包含元素数量 O(n) 3、LPUSHX、RPUSHX 只对已存在的列表执行推入操作 LPUSHX list item RPUSHX list item 成功返回列表包含元素数量。失败返回0 每次只能推入单个元素 O(1) 4、LPOP 弹出列表最左端元素 LPOP list 列表不存在返回nil O(1) 5、RPOP 弹出列表最右端的元素 RPOP list O(1) 6、RPOPLPSH 将右端弹出的元素推入左端 RPOPLPUSH source traget RPOPLPUSH list1 list2 将列表list1的最右端元素弹出，然后推入list2的左端 源列表为空则返回nil O(1) 7、LLEN 获取列表的长度 LLEN list O(1) 8、LINDEX 获取指定索引上的元素 LINDEX list index 超出list返回返回nil O(n) 9、LRANGE 获取指定索引范围上的元素 LRANGE list start end 返回列表 获取列表包含的所有元素 LRANGE list 0 -1 超出索引范围返回空列表，存在部分则返回部分 O(n) 10、LSET 为指定索引设置新元素 LSET list index new_element 成功返回1 超出索引范围返回错误 (error) ERR index out of range O(n) 11、LINSERT 将元素插入列表某个指定元素的前面或者后面 LINSERT list BEFORE|AFTER target_element new_element 返回插入后列表长度 LINSERT lst BEFORE “b” “10086” 4 不存在的元素 返回-1 O(n) 12、LTRIM 修剪列表。移除列表中位于给定索引外的元素 LTRIM list start end 成功返回ok O(n) 13、LREM 从列表中删除指定元素 LREM list count element count=0，删除所有指定元素 count\u003e0，从左开始检查，删除count个指定元素 count\u003c0，从右向左检查，删除count个指定元素 O(n) 14、BLPOP 阻塞式左端弹出操作。 从左到右依次检查是否有非空列表，没有即阻塞指定时间，直到某个列表不为空或超出等待时间 BLPOP list [list … ] timeout 返回两个元素 被弹出元素的来源列表 被弹出元素 如果阻塞过，客户端也会打印阻塞时间 阻塞只会阻塞客户端 不影响服务端 O(n) 15、BRPOP 阻塞式右端弹出 O(n) 16、BRPOPLPUSH 阻塞式弹出并推入 BRPOPLPUSH source target timeout O(1) ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:3","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"集合 可以存储任意多个元素 可以存储文本或者二进制数据 只存储非重复元素 以无序方式存储元素 1、SADD 将元素添加到集合 SADD set element [element … ] 返回成功添加元素的数量 对于已存在的元素，不会添加到集合中，返回0 O(n) n为添加元素的数量 2、SREM 从集合中移除元素 SREM set element [element … ] 返回被移除元素数量 O(n) n为元素给定元素数量 3、SMOVE 将元素从一个集合移动到另一个集合 SMOVE source target element 成功返回1 元素不存在返回0 O(1) 4、SMEMBERS 获取集合包含的所有元素 SMEMBERS set 返回元素无序 O(n) 5、SCARD 获取集合包含的元素数量 SCARD set O(1) 6、SISMEMBER 检查给定元素是否存在于集合中 SISMEMBER set element 存在返回1 不存在返回0 O(1) 7、SRANDMEMBER 随机获取集合中的元素 SRANDMEMBER set [count] count默认为1 随机返回count个元素 O(n) n为count的数量 8、SPOP 随机地从集合中移除指定数量的元素 SPOP set [count] count 默认为1 返回count个元素 O(n) n为count的数量 9、SINTER、SINTERSTORE 对集合执行交集计算 SINTER set [set … ] 返回n个集合的交集 O(m*n) SINTERSTORE destination_key set [set … ] 把n个集合的交集存储到destination_key中 返回交集长度 O(m*n) 10、SUNION、SUNIONSTORE 对集合执行并集运算 SUNION set [set … ] 返回n个集合的并集 O(n) n为所有集合元素的总数 SUNION destination_key set [set … ] 把n个集合的并集存储到destination_key中 返回并集长度 O(n) n为所有集合元素的总数 11、SDIFF、SDIFFSTORE 对集合执行差集运算 SDIFF set [set … ] 返回n个集合的差集 O(n) SDIFFSTORE destination_key set [set … ] 把n个集合的差集保存到destination_key中 返回差集的长度 O(n) ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:4","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"有序集合 有序 集合 每一个元素由成员和成员分值组成 1、ZADD 添加或更新成员 ZADD sorted_set score member [socre member … ] 返回新成员数量 ZADD salary 3500 “peter” 4000 “jack” 2000 “tom” 5500 “mary” 返回 4 ZADD salary 5000 “tom” 返回0 因为没有添加新成员 ZADD sorted_set [XX|NX] score member [socre member … ] XX：只对已存在的成员更新，不会添加 NX：只对不存在的成员添加，不会更新 ZADD sorted_set [CH] score member [socre member … ] 返回被修改的成员数量（包括新增和被更新） O(m*log(n)) m为给定成员的数量。n为有序集合包含的成员数量 2、ZREM 移除指定的成员 ZREM sorted_set member [member … ] 返回被移除成员的数量 O(M*log(n)) m为给定成员数量，n为有序集合包含的成员数量 3、ZSCORE 获取成员的分值 ZSCORE sorted_set member O(1) 4、ZINCRBY 对成员的分值执行自增或自减操作 ZINCRBY sorted_set increment member 返回修改后的分值 ZINCRBY salary 1000 “tom” “3000” ZINCRBY salary -1000 “tom” “2000” 对于不存在的成员 添加成员并设置分值 对于不存在的集合 自动创建集合 O(log(n)) 5、ZCARD 获取有序集合的大小 ZCARD sorted_set 返回长度 O(1) 6、ZRANK、ZREVRANK 获取成员在有序集合中的排名 ZRANK sorted_set member 按照分值从小到大排序返回排名 从0开始 ZREVRANK sorted_set member 按照分值从大到小排序返回排名 从0开始 对于不存在的键和或者不存在的成员 返回nil O(log(n)) 7、ZRANGE、ZREVRANGE 获取指定索引范围内的成员 ZRANGE sorted_set start end 分值升序返回 ZREVRANGE sorted_set start end 分值降序返回 ZRANGE sorted_set start end [WITHSOCRES] 返回成员和分值 不存在的有序集合，返回空列表或集合 O(log(n) + m) 8、ZRANGEBYSCORE、ZREVRANGEBYSCORE 获取指定分值范围内的成员 ZRANGEBYSCORE sorted_set min max 升序排列方式返回 [min, max]闭区间 ZREVRANGEBYSCORE sorted_set max min 降序排列方式返回 ZRANGEBYSCORE sorted_set min max [WITHSCORES] 带分值返回 ZRANGEBYSCORE sorted_set min max [LIMIT offset count] offser指定跳过成员数量。count只是返回成员个数 ZRANGEBYSCORE salary 3000 5000 0 1 “peter” 使用开区间取值 “(” ZRANGEBYSCORE salary (3500 (5000 WITHSCORES “bob” “3800” “jack” “4500” ZRANGEBYSCORE salary 3500 (5000 WITHSCORES “peter” “3500” “bob” “3800” “jack” “4500” 使用无限制作为范围 ZRANGEBYSCORE salary -inf (5000 WITHSCORES O(log(n) + m) 9、ZCOUNT 统计指定分值范围内的成员数量 ZCOUNT sorted_set min max [min, max]闭区间 返回成员个数 “+inf\"表示无穷大 “-inf\"表示无穷小 “(“表示开区间 O(log(n)) 10、ZREMRANGEBYRANK 移除指定排名范围内的成员 ZREMRANGEBYRANK sorted_set start end [start, end]闭区间 返回移除成员数量 O(log(n) + m) 11、ZREMRANGEBYSCORE 移除指定分值范围内的成员 ZREMRANGEBYSCORE sorted_set min max [min, max]闭区间 返回移除成员个数 O(log(n) + m) 12、ZUNIONSTORE、ZINTERSTORE 有序集合的并集运算和交集运算 ZUNIONSTORE destination number sorted_set [sorted_set … ] number参数用于指定参与计算的有序集合数量 计算并集存储至destination 返回并集长度 O(n*log(n)) ZINTERSTORE destination number sorted_set [sorted_set … ] number参数用于指定参与计算的有序集合数量 计算交集存储至destination 返回交集长度 O(n*log(n)*m) 指定分数的聚合函数 ZUNIONSTORE destination number sorted_set [sorted_set … ] [AGGREGATE SUM|MIN|MAX] SUM：所有集合的分值的和 MIN：所有集合中分值最小的值 MAX：所有集合中分值最大的值 为每个有序集合设置权重 权重会与分值相乘，然后执行聚合运算 ZUNIONSTORE destination number sorted_set [sorted_set … ] [WEIGHTS weight [weight … ]] 使用集合作为输入 这两个命令也可以操作集合。默认分值为1 13、ZRANGEBYLEX、ZREVRANGEBYLEX 返回指定字典序范围内的成员 ZRANGEBYLEX sorted_set min max “[“表示包含 “(“表示不包含 “+“表示无穷大 “-“表示无穷小 ZRANGEBYLEX words - + 返回所有 ZRANGEBYLEX words [a (b 返回a开头的所有 不返回b开头的 ZREVRANGEBYLEX sorted_set max min 倒序返回 ZRANGEBYLEX sorted_set min max [LIMIT offset count] 限制返回数量 O(log(n) + n) 14、ZLEXCOUNT 统计位于字典序指定范围内的成员数量 ZLEXCOUNT sorted_set min max “[” “(” “+” “-” O(nlog(n)) 15、ZREMRANGEBYLEX 移除位于字典序指定范围内的成员 ZREMRANGEBYLEX sorted_set min max 返回移除元素数量 O(log(n) + m) 16、ZPOPMAX、ZPOPMIN 弹出分值最高和最低的成员 ZPOPMAX sorted_set [count] count默认为1 返回被移除的成员和分值 ZPOPMIN sorted_set [count] count默认为1 返回被移除的成员和分值 O(n) n为移除元素数量 17、BZPOPMAX、BZPOPMIN 阻塞式最大/最小元素弹出操作 BZPOPMAX sorted_set [sorted_set … ] timeout 返回被弹出元素所在集合。成员。分值 BZPOPMIN sorted_set [sorted_set … ] timeout O(n) ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:5","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"hyperloglog1、hyperloglog是专门为了计算集合的基数而创建的概率算法 对集合的元素进行基数 获取集合当前的近似基数 合并多个HyperLogLog 2、PFADD 对集合元素进行计数 PFADD hyperloglog element [element … ] 若基数没变返回0 若基数变化返回1 O(n) 3、PFCOUNT 返回集合的近似基数 PFCOUNT hyperloglog [hyperloglog … ] 返回近似基数 不存在返回0 返回并集的近似基数 传入多个HyperLogLog时，将进行并集运算，返回并集的近似基数 O(n) 4、PFMERGE 计算多个HyperLogLog的并集 PFMERGE destination hyperloglog [hyperloglog … ] 并集保存到destination 如果指定的键已存在则覆盖 成功返回ok PFCOUNT命令会调用PFMERGE获取临时HyperLogLog，然后计算近似基数，删除临时HyperLogLog O(n) ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:6","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"位图1、SETBIT 设置二进制的值 SETBIT bitmap offset value 返回二进制位被设置前的旧值 偏移量只能为正数 位图不存在将被创建 位图长度不够将被扩展 O(1) 2、GETBIT 获取二进制位的值 GETBIT bitmap offset 返回偏移量上的二进制值 偏移量只能为整数 对于偏移量范围外的返回0 O(1) 3、BITCOUNT 统计被设置的二进制位数量 BITCOUNT key 返回被设置为1的位数 BITCOUNT key [start end] 在指定字节范围统计 start，end为字节偏移量 1字节 = 8bit 1字节偏移量 = 8bit位偏移量 O(n) 4、BITPOS 查找第一个指定的二进制位值 BITPOS bitmap value 返回第一个被设置为value的位置偏移量 BITPOS bitmap value [start end] 在指定字节范围搜索第一个被设置value的位置 O(n) 5、BITOP 执行二进制位运算 BITOP operation result_key bitmap [bitmap … ] opetration: AND、OR、XOR、NOT NOT只允许输入一个位图，其他允许多个 返回被存储位图的字节长度 两个不同长度的位图，较短的会在前补0 O(n) 6、BITFIELD 在位图中存储整数值 BITFIELD支持SET、GET、INCRBY、OVERFLOW四个子命令 BITFIELD bitmap SET type offset value type：i8(有符号8位整数) u16(无符号16位整数) BITFIELD bitmap SET u8 0 198 0 BITFIELD bitmap SET u8 0 123 SET i32 20 10086 SET i64 188 123456789 198 0 0 O(n) 7、 TYPE bitmap string ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:7","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"地理坐标1、GEOADD 存储坐标 GEOADD location_set longitude latitude name [ longitude latitude name … ] 返回添加个数 GEOADD可以更新已存在的地理位置 更新返回0 O(log(n)*m) 2、GEOPOS 获取指定位置坐标 GEOPOS location_set name [name … ] 返回n组数组 GEOPOS guangdong qingyuan guangzhou “113” – 清远市经度 ​ 2) “23” – 清远市纬度 “113” – 广州市经度 ​ 2) “23” – 广州市纬度 不存在返回nil O(log(n)*m) 3、GEODIST 计算两个位置之间的直线距离 GEODIST location_set name1 name2 返回name1和name2的距离 GEODIST location_set name1 name2 [unit] unit可选：m(米),km(千米),mi(英里),ft(英尺) 不存在的位置返回nil O(log(n)) 4、GEORADIUS 查找指定坐标半径范围内的其他位置 GEORADIUS location_set longitude latitude radius unit GEORADIUS guangdong 112 23 100 km “foshan” “guangzhou” GEORADIUS location_set longitude latitude radius unit [WITHDIST] WITHDIST: 返回携带距离 GEORADIUS location_set longitude latitude radius unit [WITHCOORD] WITHCOORD：返回携带经纬度 GEORADIUS location_set longitude latitude radius unit [ASC|DESC] 排序查找 GEORADIUS location_set longitude latitude radius unit [COUNT n] 限制返回的数量 O(n) 5、GEORADIUSBYMEMBER 查找指定位置半径范围内的其他位置 GEORADIUSBYMEMBER location_set name radius unit [WITHDIST] [WITHCOORD] [ASC|DESC] [COUNT n] O(n) 6、GEOHASH 获取指定位置的Geohash值 GEOHASH guangdong qingyuan guangzhou GEORADIUS、GEORADIUSBYMEMBER可以添加[WITHHASH]参数返回Geohash O(n) 7、 可以使用ZREM对location中位置进行删除 ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:8","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"流 redis5.0新增 1、XADD 追加新元素到流的末尾 XADD stream id field value [field value … ] 流不存在则创建 id由\"毫秒时间-编号\"两部分组成 XADD stream 1000000-123 k1 v1 返回编号id id不可以重复 新id必须大于旧id XADD s1 * k1 v1 自动生成id 限制流的长度 XADD stream [MAXLEN len] id field value [field value … ] 按照先进先出移除超过长度的元素 O(log(n)) 2、XTRIM 对流进行修剪。将流修剪为指定长度 XTRIM stream MAXLEN len 返回被移除元素数量 O(log(n)+m) n为修剪操作前元素数量。m为被修剪元素数量 3、SDEL 移除指定元素 XDEL stream [id id … ] 返回被移除元素数量 O(log(n)*m) 4、XLEN 获取流包含的元素数量 XLEN stream O(1) 5、XRANGE、XREVRANGE 访问流中元素 XRANGE stram start-id end-id [COUNT n] 返回ID1 k1 v1 … XRANGE temp 4000000000000 + 获取所有大于4000000000000的 XRANGE temp - 4000000000000 获取所有小于4000000000000的 COUNT 限制获取的数量 XREVRANGE stram start-id end-id [COUNT n] 逆序访问 O(log(n)+m) 6、XREAD 以阻塞或非阻塞方式获取流元素 XREAD [BLOCK ms] [count n] STREAMS stream1 stream2 stream3 … id1 id2 id3 … 从给定的流中取出大于指定ID的多个元素 XREAD COUNT 3 STREAMS s1 10000000 XREAD BLOCK ms STREAMS stream1 stream2 … $ $ $ … 只获取新元素 XREAD BLOCK 10000 STREAMS bs1 $ 只获取bs1后续出现的新元素 O((log(n)+m)*I) 流包含n个元素。m为被获取元素数量。I个流 7、XGROUP、XREADGROUP、XACK 消费者组 XGROUP CREATE stream group start_id 创建消费者组 group为组名 start_id为消费者开始读取的id XREADGROUP GROUP consumer [COUNT n] [BLOCK ms] STREAMS stream [stream … ] id [id … ] 读取消费者组 XREADGROUP GROUP g1 c1 STREAMS msgs 0 XACK stream group id [id id …] 消息的状态转换 8、XGROUP 管理消费者组 XGROUP CREATE stream group id 创建消费者组 如果stream不存在返回错误 XGROUP CREATE cgs all-message 0-0 XINFO GROUP cgs O(1) XGROUP SETID stream group id 修改消费者组最后递送消息ID O(1) XGROUP DELCONSUMER stream group consumer 删除消费者 O(n) n为被删除消费者正在处理的消息数量 XGROUP DESTORY stream group 删除消费者组 O(n+m) n为消费者组被删除时，待处理的消息数量。m为消费者数量 9、XREADGROUP 读取消费者组中的消息 XREADGROUP GROUP group consumer [COUNT n] [BLOCK ms] STREAMS stream [stream …] id [id …] XREADGROUP GROUP all-message worker1 COUNT 1 STREAMS cgs \u003e 读取未递送过的新消息 O((log(n)+m)*i) 10、XPENDING 显示待处理消息的相关信息 XPENDING stream group [start stop count] [consumer] O(log(n)+m) 11、XACK 将消息标记为“已处理” XACK stream group id [id id …] O(n) 12、XCLAIM 转移消息的归属权 XCLAIM stream group new_consumer max_pending_time id [id id …] 只转移消息ID XCLAIM stream group new_consumer max_pending_time id [id id …] [JUSTID] O(n) 13、XINFO 查看流和消费者组的相关信息 XINFO CONSUERS stream group-name 打印消费者信息 O(n) n为消费者数量 XINFO GROUPS stream 打印消费者组的信息 O(m) m为消费者组数量 XINFO STREAM stream 打印流信息 O(1) ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:9","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"数据库1、SELECT 切换至指定的数据库 SELECT db SELECT 0 O(1) 2、KEYS 获取所有与给定匹配符相匹配的键 KEYS pattern KEYS *（阻塞服务器） O(n) 3、SCAN 以渐进方式迭代数据库中的键 SCAN cursor SCAN 0 SCAN命令不需要申请也不需要释放，不占用任何资源 SCAN cursor [MATCH pattern] 迭代与给定匹配符相匹配的键 SCAN cursor [COUNT n] 返回指定数量 Redis中可能导致阻塞的命令 KEYS HKEYS、HVALS、HGETALL SMEMBERS ZRANGE 为解决以上问题提供了SSCAN、HSCAN、ZSCAN HSCAN hash cursor [MATCH pattern] [COUNT n] SSCAN set cursor [MATCH pattern] [COUNT n] ZSCAN sorted_set cursor [MATCH pattern] [COUNT n] 单次调用O(1)。迭代一次O(n) 4、RANDOMKEY 随机返回一个键 RANDOMKEY O(1) 5、SORT 对键的值进行排序 SORT key 指定排序方式 SORT key [ASC|DESC] 对字符串进行排序 SORT key [ALPHA] 只获取部分排序结果 SORT key [LIMIT offset count] 获取外部键的值作为结果 SORT key [[GET pattern] [GET pattern] …] 使用外部键的值作为排序权重 SORT key [BY pattern] 保存排序结果 SORT key [STORE destination] O(n*log(n)+m) 6、EXISTS 检查给定键是否存在 EXISTS key [key …] 返回存在的key的数量 O(n) 7、DBSIZE 获取数据库中包含的键值对数量 DBSIZE O(1) 8、TYPE 查看键类型 TYPE key 键类型 TYPE返回值 字符串键 string 散列键 hash 列表键 list 集合键 set 有序集合键 zset HyperLogLog string 位图 string 地理位置 zset 流 stream O(1) 9、RENAME、RENAMENX 修改键名 RENAME origin new new已存在则会覆盖 RENAMENX origin new new已存在则不覆盖 O(1) 10、MOVE 将给定的键移动到另一个数据库 MOVE key db 源数据库不存在key或者目标数据库存在key该操作都会失败 O(1) 11、DEL 移除指定的键 DEL key [key …] 返回被移除的键的数量 O(n) 12、UNLINK 以异步方式移除指定的键（防止阻塞） UNLINK key [key …] 返回成功移除的键的数量 13、FLUSHDB 清空当前数据库 FLUSHDB ok FLUSHDB async 异步方式清除数据库 O(n) 14、FLUSHALL 清空所有数据库 FLUSHALL ok FLUSHALL async 异步方式 O(n) 15、SWAPDB 互换数据库 SWAPDB x y O(1) ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:10","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"自动过期1、EXPIRE、PEXPIRE 设置生存时间 EXPIRE key seconds 秒级过期时间 PEXPIRE key milliseconds 毫秒级过期时间 O(1) 2、SET-EX、PX SET key value [EX seconds] [PX milliseconds] O(1) 3、EXPIREAT、PEXPIREAT 设置(更新)过期时间 EXPIREAT key seconds_timestamp 超过给定的秒级时间戳，key被删除 PEXPIRAET key milliseconds_timestamp 超过给定的毫秒级时间戳，key被删除 O(1) 4、TTL、PTTL 获取键的剩余生存时间 TTL key PTTL key 没有过期时间的key返回-1 不存在的key返回-2 O(1) ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:11","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"流水线与事物1、流水线 允许客户端打包多条redis请求一次性发送给服务器，处理完毕后一次性返回全部处理结果 2、事务 MULTI 开启事务 O(1) EXEC 执行事务 DISCARD 放弃事务 O(n) 事务会独占服务器。避免事务执行过多命令造成服务器阻塞。 3、带有乐观锁的事务 WATCH 对键进行监视 WATCH key [key …] 确保事务只会在被监视键没有发生变化的情况下执行，从而保证事务对被监视键的所有修改都是安全、正确和有效的。 O(n) UNWATCH 取消对键的监视 UNWATCH key [key …] O(n) ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:12","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"LUA脚本 lua脚本执行具有原子性 1、EVAL 执行脚本 EVAL script numkeys key [key …] arg [arg …] 使用脚本执行redis命令 redis.call(command, …) redis.call(‘SET’, KEYS[1], ARGV[1]) redis.pcall(command, …) 2、SCRIPT LOAD和EVALSHA 缓存并执行脚本 ACRIPT LOAD script 缓存脚本 EVALSHA sha1 numkeys key [key …] arg [arg …] 执行脚本 3、脚本管理 SCRIPT EXISTS sha1 [sha1 …] 脚本是否已存在。存在返回1，不存在返回0 SCRIPT FLUSH 移除所有已缓存脚本 SCRIPT KILL 强制停止正在运行的脚本 kill失败只能 “SHUTDOWN nosave\"关闭服务器 O(1) 4、内置函数库 redis包 bit包 struct包 cjson包 cmsgpack包 ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:13","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"持久化 RDB持久化 AOF持久化 RDB-AOF混合持久化 1、RDB持久化 Redis默认 全量式持久化 生成.rdb结尾文件(Redis DataBase) SAVE 阻塞服务器并创建RDB文件 返回OK 如果已经存在RDB文件 SAVE会移除就文件，只保留新的RDB文件 O(n) n为键值对总数量 BGSAVE 以非阻塞方式创建RDB文件 使用子进程创建RDB文件 O(n) n为键值对总数量 通过配置自动创建RDB文件 save 服务器在seconds秒内执行了changes次自改，自动BGSAVE。 Redis默认 save 60 10000 save 300 100 save 3600 1 RDB持久化缺陷 间隔越长，停机时丢失数据越多 全量持久化操纵消耗大量计算资源和内存资源 2、AOF持久化 增量式持久化 服务器每次执行完写命令之后，都会以协议文本方式将被执行命令最佳到AOF文件末尾 打开AOF持久化功能 appendbonly [yes | no] appendonly yes # 开启 appendonly no # 关闭 设置AOF文件的冲洗频率(把内存缓冲区数据写入文件) appendfsync [always | everysec | no] always：每次执行写命令 everysec：每隔1s （默认选项） no：不主动冲洗 AOF重写（优化AOF历史命令，只保存恢复当前数据库所需的尽可能少的命令） BGRERITEAOF 显式触发AOF重写操作 异步命令 如果正在创建RDB文件，将会等待。避免两个写磁盘造成性能下降 执行中，重复收到该命令将返回错误 O(n) auto-aof-rewrite-min-size auto-aof-rewrite-min-size 64m 当AOF文件大于value时，将会自动执行重写 auto-aof-rewrite-percentage auto-aof-rewrite-percentage 100 当前AOF文件体积比最后一次AOF重写之后打了一倍(100%)后重写 AOF持久化优点 比RDB安全性高得多(丢失数据少) AOF持久化缺点 存储协议文本比RDB二进制大得多。生成时间也更长 AOF需要执行命令来恢复。恢复速度更慢 AOF重写会占用大量资源。创建子进程会造成短暂阻塞 3、RDB-AOP混合持久化 AOF文件有RDB数据和生成RDB之后的命令组成 aof-use-rdb-preamble yes: Redis在执行AOF重写操作时，会像执行BGSAVE，同事生成RDB数据写入AOF文件。对于新执行命令继续以协议文本方式写入AOF文件。 no：redis默认 4、5、无持久化 关闭系统默认持久化 save '' '' 6、关闭服务器 SHUTDOWN SHUTDOWN [save | nosave] 关闭前进行一次持久化操作 开启RDB会执行SAVE命令。 开启AOF会冲洗AOF文件。 O(n) n为需要持久化的键值对数量 ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:14","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"发布与订阅1、PUBLISH 向频道发送消息 PUBLISH channel message PUBLISH “news.it” “hello” O(n+m) n=订阅者数量。m=被订阅的模式总数量 2、SUBSCRIBE 订阅频道 SUBSCRIBE channel [channel … ] SUBSCRIBE “new.it” O(n) n为订阅频道数量 3、UNSUBSCRIBE UNSUBSCRIBE [channel channel … ] O(n) 4、PSUBSCRIBE 订阅模式 PSUBSCRIBE pattern [pattern … ] PSUBSCRIBE “news.*” O(n) n为给定模式数量 5、PUNSUBSCRIBE 退订模式 O(n*m) n=给定模式数量 m=被订阅模式数量 6、PUBSUB 查看发布与订阅的相关信息 PUBSUB CHANNELS 查看被订阅的频道 PUBSUB NUMSUB [channel channel …] 查看频道的订阅者数量 PUBSUB NUMPAT 查看被订阅模式的总数量 O(1) ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:15","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"模块通常由C语言或其他能够与C语言交互的语言实现 1、模块的管理 编译模块 载入模块 在服务启动时 loadmoule \u003cmodule_path\u003e 在服务运行期间 module load module_path O(1) 列出已载入的模块 MODULE LIST O(n) n为模块数量 卸载模块 MODULE UNLOAD module_name O(1) 2、ReJSON模块 MODULE LOAD ~/src/rejson.so JSON.SET [NX|XX] JSON.GET [path path …] JSON.DEL [path] JSON.MGET [key …] JSON.TYPE [path] 3、RediSQL模块 REDISQL CREATE_DB name [path] 创建数据库 O(1) DEL db [db … ] 删除数据库 REDISQL.EXEC db “statement” 执行语句 REDISQL.EXEC MYDB “INSERT INTO user VALUES(‘peter’)” REDISQL.QUERY db “statement” 执行查询 REDISQL.COPY source destination 复制数据库 4、RediSearch模块 FT.CREATE name SCHEMA [field [WEIGHT n] [TEXT | NUMERIC | GEO |TAG] [SORTABLE] ] [FIELD …] 创建索引 FT.ADD index docId score FIELDS field value [field value] 添加文档至索引 FT.ADDHASH index hash score [LANGUAGE lang] [REPLACE] 添加散列至索引 FT.INFO index 查看索引信息 FT.SEARCH index query [LANGUAGE lang] 检索文档 FT.GET index docId FT.MGET index docId [docId …] 从索引中获取文档 FT.DEL index docID 从索引中删除文档 FT.DROP index [KEEPDOCS] 移除索引 ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:16","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"复制 主从复制 1、REPLICAOF 将服务器设置为从服务器 REPLICAOF host port 成为host:port 服务的从服务器 在启动的同时设置为从服务器 replicaof redis-server –port 10086 –replicaof 127.0.0.1 6379 取消复制 REPLICAOF no one 不会清空数据，继续保留复制产生的所有数据 2、ROLE 查看服务器的角色 ROLE master # 主服务器 slave # 从服务器 O(1) 3、数据同步 执行REPLICAOF后： 主服务器执行BGSAVE生成RDB文件，并使用缓冲区存储之后执行的所有写命令 通过套接字吧RDB传送给从服务器 从服务器接受RDB文件，载入 接受主服务器缓存区所有写命令 在线更新 主服务器执行完写命令后会把相同写命令或具有相同效果的写命令发给从服务器执行 部分同步 因故障下线的从服务器重新上线时 主服务维护命令队列。如果从服务器上线时缺失的命令存在于队列则执行队列中的命令更新，否则执行完整同步 通过repl-backlog-size 修改队列大小 4、无需硬盘的复制 创建RDB文件导致复制变慢 repl-diskless-sync \u003cyes|no\u003e redis-server repl-diskless-sync yes 不在本地创建RDB文件。创建子进程直接通过套接字将RDB文件写入从服务器 5、降低数据不一致情况出现的概率 min-replicas-max-lag min-relicas-to-write 主服务器只会在从服务器数量大于min-relicas-to-write且从服务器与主服务器最后一次成功通信的间隔不超过min-replicas-max-lag时才会执行写命令 6、可写的从服务器 从服务器默认只允许读 replica-read-only \u003cyes|no\u003e 设置no，表示可写 7、脚本复制 脚本传播模式 命令传播模式 选择性命令传播 ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:17","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"Sentinel 故障转移：使用正常服务器替换下线服务器以维持系统正常运行 Redis Sentinel通过心跳检测的方式监视多个主服务器以及它们属下从服务器，并在某个主服务器下线时自动对其实施故障转移 1、启动Sentinel redis-sentinel /etc/sentinel.conf sentinel monitor # 配置 … 对于重新上线的旧主服务器会被转换为当前主服务器的从服务器 replica-priority配置选项可以设置从服务器优先级 选主规则 优先级高 偏移量大 运行ID小 2、Sentinel网络3、Sentinel管理命令 SENTINEL masters 获取所有被监视主服务器的信息 SENTINEL master 获取指定主服务器的信息 SENTINEL slaves 获取所有被监视主服务器的从服务器信息 SENTINEL sentinels 获取其他Sentinel的相关信息 SENTINEL get-master-addr-by-name 获取给定主服务器的IP地址和端口号 SENTINEL reset 重置主服务器状态 SENTINEL failover 强制执行故障转移 SENTINEL ckquorum 检查可用Sentinel数量 SENTINEL flushconfig 强制写入配置文件 4、在线配置Sentinel SENTINEL monitor 监视给定主服务器 SENTINEL remove 取消对给定主服务器的监视 SENTINEL set 修改Sentinel配置选项的值 ","date":"2021-07-06","objectID":"/redis_reference_manual/:0:18","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":"集群1、基本特性 复制与高可用 分片与重分片 高性能 简单易用 2、搭建集群 快速搭建集群 create-cluster 手动搭建集群 3、散列标签4、打开/关闭从节点的读命令执行权限 READONLY 打开读命令执行权限 READWRITE 关闭读命令执行权限 O(1) 5、集群管理工具redis-cli redis-cli –cluster help 6、集群管理命令","date":"2021-07-06","objectID":"/redis_reference_manual/:0:19","tags":["redis","读书笔记"],"title":"Redis使用手册","uri":"/redis_reference_manual/"},{"categories":null,"content":" 计算机网络之概述 计算机网络之网络层 计算机网络之传输层 计算机网络之应用层 计算机网络实践 ","date":"2021-05-27","objectID":"/computer_networks/:0:0","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"计算机网络之概述篇","date":"2021-05-27","objectID":"/computer_networks/:1:0","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"计算机网络的发展简史 第一阶段：单个网络ARPANET 第二阶段：三层结构互联网 第三阶段：多层次ISP互联网 ISP(Internet Service Provider)：网络服务提供商 中国电信、中国移动、中国联通等 中国互联网发展简史 ","date":"2021-05-27","objectID":"/computer_networks/:1:1","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"层次结构设计的基本原则层次结构设计的基本原则 需要考虑的问题（采用分层设计的原因） 保证数据通路顺畅 目的计算机状态 识别目的计算机 数据是否错误 设计原则 各层之间相互独立 每一层要有足够的灵活性 各层之间完全解耦 OSI七层模型七层模型： 应用层 为计算机用户提供接口和服务 表示层 数据处理（编码解码、加密解密等） 会话层 管理（建立、维护、重连）通信会话 传输层 管理端到端的通信连接 网络层 数据路由（决定数据在网络中的路径） 数据链路层 管理相邻节点之间的数据通信 物理层 数据通信的光点物理特性 other： OSI欲成为全球计算机都遵循的标准 OSI在市场化的过程中困难重重，TCP/IP在全球范围成功运行 OSI最终并没有成为广为使用的标准模型 OSI没有广泛推广的原因： OSI的专家缺乏实际经验 OSI标准制定周期过长，按OSI标准生产的设备无法及时进入市场 OSI模型设计的并不合理，一些功能在多层中重复出现 TCP/IP四层模型四层模型： 应用层 应用层、表示层、会话层 HTTP、FTP。。。 传输层 传输层 TCP、UDP 网络层 网络层 IP、ICMP 网络接口层 数据链路层、物理层 Ethernet、ARP、RARP 数据传输： ","date":"2021-05-27","objectID":"/computer_networks/:1:2","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"现代互联网的网络拓扑边缘部分 核心部分 ","date":"2021-05-27","objectID":"/computer_networks/:1:3","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"计算机网络的性能指标速率： bps=bit/s 时延： 发送时延 =数据长度(bit)/发送速率(bit/s) 排队时延 =传播路径距离/传播速度(bit/s) 传播时延 数据包在网络设备中等待被处理的时间 处理时延 数据包到达设备或者目的机器被处理所需要的时间 总时延 = 发送时延 + 排队时延 + 传播时延 + 处理时延 RTT(Route-Trip Time) 表示的是数据报文在端到端通信的来回一次的时间 通常使用ping命令查看RTT ","date":"2021-05-27","objectID":"/computer_networks/:1:4","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"数据链路层概述 封装成帧 “帧”是数据链路层数据的基本单位 发送端在网络层的一段数据前后添加特定标记形成“帧” 接收端根据前后特定标记识别出“帧” 物理层不管是不是“帧” 帧首部和尾部是特定的控制字符（特定比特流） 首部(SOH)：00000001 尾部(EOT): 00000100 透明传输 “透明\"在计算机领域是一个非常重要的术语 即是控制字符在帧数据中，但要当做不存在的去处理 ESC 转义字符 差错监测 物理层只管传=传输比特流，无法控制是否出错 数据链路层负责起“查错检测”的工作 ","date":"2021-05-27","objectID":"/computer_networks/:1:5","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"数据链路层的差错检测 奇偶校验码 数据流求和。偶数就在末尾添加0，否则在末尾添加1 出错位数为偶数时，校验不出 循环冗余校验码CRC 一种根据串或保存的数据而产生固定位数校验码的方法 检测数据传输或者保存后可能出现的错误生成的数字计算出来并且附加导数据后面 计算步骤 选定一个用于校验的多项式G(x)，并在数据尾部添加r个0 将添加r个0后的数据，使用模\"2\"除法除以多项式的位串 得到的余数填充在原数据r个0的位置得到可校验的位串 CRC的错误检测能力与位串的阶数r有关 数据链路层只进行数据的检测，不进行纠正（对于错误的数据，直接丢弃） ","date":"2021-05-27","objectID":"/computer_networks/:1:6","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"最大传输单元MTU MTU(Maximum Transmission Unit) 数据链路层的数据帧也不是无限大的 数据帧长度受MTU限制 数据帧过大或者过小都会影响传输的效率(以太网一般为1500字节) 路径MTU由链路中MTU最小值决定 ","date":"2021-05-27","objectID":"/computer_networks/:1:7","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"以太网协议详解MAC地址 物理地址、硬件地址 每个设备都拥有唯一的MAC地址 MAC地址共48位，使用十六进制表示 以太网协议 以太网是一种使用广泛的局域网技术 以太网是一种应用于数据链路层的协议 使用以太网可以完成相邻设备的数据帧传输 MAC地址表 ","date":"2021-05-27","objectID":"/computer_networks/:1:8","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"计算机网络之网络层篇","date":"2021-05-27","objectID":"/computer_networks/:2:0","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"IP协议详解虚拟互联网络 IP协议是的复杂的实际网络变成一个虚拟互联的网络 IP协议是的网络层可以屏蔽底层细节而专注网络层的数据转发 IP协议解决了在虚拟网络中数据报传输路径的问题 IP协议 长度32位，常分为4个8位 IP地址常使用点分十进制来表示 ip首部 版本：占4位，指的是IP协议的版本。即IPV4或IPV6 首部位长度：占4位，表示IP首部长度，即是IP首部最大长度为60字节 总长度，占16位，最大数值25535，表示IP数据报总长度(IP首部+IP数据) 标识 标志 片偏移 TTL：占8位，表明IP数据报文在网络中的寿命，没经过一个设备，TTL减1，当TTL=0时，网络设备必须丢弃该报文 协议：占8位，表明IP数据所携带的具体数据是什么协议的(如：TCP、UDP等) 首部校验和：占16位，校验IP首部是否出错 ","date":"2021-05-27","objectID":"/computer_networks/:2:1","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"IP协议的转发流程路由表的简介 IP协议的转发流程 数据帧每一跳的MAC地址都在变化 IP数据报每一跳的IP地址始终不变 ","date":"2021-05-27","objectID":"/computer_networks/:2:2","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"ARP协议与RARP协议ARP(Address Resoution Protocol)地址解析协议 ARP缓存表 ARP缓存表是ARP协议和RARP协议运行的关键 ARP缓存表缓存了IP地址到硬件地址之间的映射关系 ARP缓存表中的记录并不是永久有效的，有一定的期限 RARP(Reverse Address Resolution Protocol)逆地址解析协议 (R)ARP协议是TCP/IP协议栈里面基础的协议 ARP和RARP的操作对程序员是透明的 理解(R)ARP协议有助于理解网络分层的细节 ","date":"2021-05-27","objectID":"/computer_networks/:2:3","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"IP地址的子网划分分类的IP地址 特殊主机号 主机号全0表示当前网络段，不可分配为特定主机 主机号全1表示广播地址，向当前网络段所有主机发消息 特殊网络号 A类地址网络段全0(00000000)表示特殊网络 A类地址网络段后7位全1(01111111：127)表示回环地址 B类地址网络段(10000000.00000000：128.0)是不可使用的 C类地址网络段(192.0.0)是不可使用的 127.0.0.1 通常被称为本地回环地址(Loopback Address)，不属于任何一个有类别的地址类。 划分子网 子网掩码 子网掩码和IP地址一样，都是32位 子网掩码由连续的1和连续的0组成 某一个子网的子网掩码具备网络号位数个连续的1 例子 A类：255.0.0.0 B类：255.255.0.0 C类：255.255.255.0 用于快速判断IP属于拿一个子网号 无分类编址CIDR CIDR中没有A、B、C类网络号和子网划分的概念 CIDR吧网络前缀相同的IP地址成为一个\"CIDR地址块” 斜线记法 193.10.10.129/25 ","date":"2021-05-27","objectID":"/computer_networks/:2:4","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"网络地址转换NAT技术背景： IPV4只有40+亿个IP地址 早期IP地址的不合理规划导致IP号浪费 内网地址 内部机构使用 避免与外网地址重复 三类内网地址 10.0.0.0 ~ 10.255.255.255（支持千万数量及设备） 172.16.0.0 ~ 172.31.255.255（支持百万数量级设备） 192.168.0.0 ~ 192.168.255.255（支持万数量级设备） 外网地址 全球范围使用 全球公网唯一 网络地址转换NAT（Network Adress Translation） NAT技术用于多个主机通过一个公有IP访问互联网的 NAT减缓了IP地址的消耗，但是增加了网络通信的复杂度 ","date":"2021-05-27","objectID":"/computer_networks/:2:5","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"ICMP协议详解 网际控制报文协议(Internet Control Message Protocol) ICMP协议可以报告错误信息或者异常情况 报文种类 差错报告报文 询问报文 ","date":"2021-05-27","objectID":"/computer_networks/:2:6","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"ICMP协议的应用Ping应用 Ping回环地址127.0.0.1 Ping网关地址 Ping远端地址 Traceroute应用 Traceroute可以探测IP数据在网络中走过的路径 Traceroute依次发出TTL加一的报文，获取操作不可达的返回 ","date":"2021-05-27","objectID":"/computer_networks/:2:7","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"网络层的路由概述背景： 路由表怎么维护的 下一跳怎么来的 下一跳地址唯一吗 下一跳地址是最佳的吗 路由器这么多，他们怎么协同工作 要求： 算法是正确的、完整的 算法在计算上应该尽可能的简单 算法可以适应网络中的变化 算法是稳定的和公平的 路由算法本质是图的算法 对互联网进行划分 互联网的规模是非常大的 互联网的环境是非常复杂的 自制系统（Autonomous System） 一个自治系统(AS)是处于一个管理机构下的网络设备群 AS内部网络自行管理，AS对外提供一个或者多个出（入）口 自治系统内部路由的协议称为：内部网关协议(RIP、OSPF) 自治系统外部路由的协议称为：外部网关协议（BGP） ","date":"2021-05-27","objectID":"/computer_networks/:2:8","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"内部网络路由协议只RIP协议距离矢量(DV)算法 每一个节点使用两个向量Di和Si Di描述的是当前节点到别的节点的距离 Si描述的是当前节点到别的节点的下一节点 每一个节点与相邻的节点交换向量Di和Si的信息 每一个节点根据交换的信息更新及的节点信息 RIP协议的过程 RIP(Routing Information Protocol)协议 RIP协议是使用DV算法的一中路由协议 RIP协议把网络的跳数(hop)作为DV算法的距离 RIP协议每隔30秒交换一次路由信息 RIP协议认为跳数\u003e15的路由则为不可达路由 RIP协议过程 路由器初始化路由信息(两个向量Di和Si) 对相邻路由器X发过来的信息，对信息的内容进行修改（下一跳地址设置为X，所有距离加1） 检索本地路由，将信息中新的路由插入到路由表里面 检索本地路由，对于下一跳为X的，更新为修改后的信息 检索本地路由，对比相同目的地距离，如果新信息的距离更小，则更新本地路由表 如果3分钟没有收到相邻的路由信息，则把相邻路由设置为不可达(16跳) RIP协议优点： 实现简单，开销很小 RIP协议缺点： 限制了网络的规模 故障消息传递慢，更新收敛时间过长 ","date":"2021-05-27","objectID":"/computer_networks/:2:9","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"Dijkstra(迪杰斯特拉)算法 著名的图算法 解决有权图从一个节点到其他节点的最短路径问题 广度优先 最短路径问题 ","date":"2021-05-27","objectID":"/computer_networks/:2:10","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"内部网关路由协议之OSPF协议链路状态(LS)协议 向所有路由器发送信息 消息描述该路由器与相邻路由器的链路状态 只有链路状态发生变化时， 才发送更新信息 OSPF协议的过程 OSPF(Open Shortest Path First: 开放最短路径优先) OSPF协议的核心是Dijkstra算法 向所有的路由器发送消息 获得网络中的所有信息 -\u003e 网络的完整拓扑 也称为“链路状态数据库” “链路状态数据库”是全网一致的 Dijkstra算法 消息描述该路由器与相邻路由器的链路状态 OSPF协议更加客观、更加先进 只有链路状态发生变化时， 才发送更新信息 减少了数据的交换，更快收敛 五种消息类型 问候(Hello) 链路状态数据库描述信息 链路状态请求信息 链路状态更新信息 链路状态确认信息 过程： 对比： ","date":"2021-05-27","objectID":"/computer_networks/:2:11","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"外部网关路由协议之BGP协议 BGP(Border Gateway Protocol: 边际网关协议) BGP协议是运行在AS之间的一种协议 BGP协议可以找到一条到达目的比较好的路由 背景： 互联网规模很大 AS内部使用不同的路由协议 AS之间需要考虑网络特性意外的一些因素（政治、安全…） BGP发言人(speaker) BGP并不关心内部网络拓扑 AS之间通过BGP发言人交流信息 BGP Speaker可以人为配置策略 ","date":"2021-05-27","objectID":"/computer_networks/:2:12","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"计算机网络之传输层 使用端口来标记不同的网络进程 端口使用16比特位表示（0~65535） ","date":"2021-05-27","objectID":"/computer_networks/:3:0","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"UDP协议详解 UDP(User Datagram Protocol:用户数据报协议) UDP是一个非常简单的协议 数据报(Datagram)： 不合并 不拆分 特点： UDP是无连接协议 UDP不能保证可靠的交付数据 UDP是面向报文传输的 UDP没有拥塞控制 UDP的首部开销很小 ","date":"2021-05-27","objectID":"/computer_networks/:3:1","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"TCP协议详解 TCP(Transmission Control Protocol:传输控制协议) TCP协议是计算机网络中非常复杂的一个协议 特点： TCP是面向连接的协议 TCP的一个连接有两端（点对点通信） TCP提供可靠的传输服务 TCP协议提供全双工的通信 TCP是面向字节流的协议- 序号 0 ~ 2^32-1 一个字节一个序号 数据首字节序号 确认号 0 ~ 2^32-1 一个字节一个序号 期望收到的首字节序号 数据偏移 占4位：0 ~ 15，单位为：32位字 数据偏移首部的距离 TCP标记 占6位，每位各有不同意义 窗口 占16位，0 ~ 2^16-1 窗口指明允许对方发送的数据量 校验和 紧急指针 紧急数据（URG=1） 置顶紧急数据在报文的位置 TCP选项 最多40字节 支持未来的拓展 ","date":"2021-05-27","objectID":"/computer_networks/:3:2","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"可靠传输的基本原理停止等待协议 发送的消息在路上丢失了 确认的消息在路上丢失了 确认的消息很久才到 超时定时器 每发送一个消息买都需要设置一个定时器 停止等待协议是最简单的可靠传输协议 停止等待协议对信道的利用效率不高 连续ARQ协议ARQ(Automatic Repeat reQuest: 自动重传请求) - 滑动窗口 - 累计确认 ","date":"2021-05-27","objectID":"/computer_networks/:3:3","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"TCP协议的可靠传输TCP的可靠传说基于连续ARQ协议 滑动窗口 选择重传 选择重传需要指定需要重传的字节 每一个字节都有唯一的32位序号 需要重传的边界序号存放在TCP首部的“TCP选项”中 TCP的滑动窗口以字节为单位","date":"2021-05-27","objectID":"/computer_networks/:3:4","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"TCP协议的流量控制 流量控制指让发送方发送速率不要太快 流量控制是使用滑动窗口来实现的 坚持定时器 当接收到窗口为0的消息，则启动坚持定时器 坚持定时器每隔一段时间发送一个窗口探测报文 ","date":"2021-05-27","objectID":"/computer_networks/:3:5","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"TCP协议的拥塞控制拥塞原因： 一条数据链路经过非常多的设备 数据链路中各个部分都有可能成为网络传输的瓶颈 和流量控制的区别： 流量控制考虑点对点的通信量的控制 拥塞控制考虑整个网络，是全局性的考虑 报文超时则认为是拥塞 慢启动算法 由小到大逐渐增加发送数据量 每收到一个报文确认，就加一 指数增长 慢启动阈值(ssthresh) 增长到慢启动阈值不再增长 拥塞避免算法 维护一个拥塞窗口的变量 只要网络不拥塞，就试探着拥塞窗口调大 ","date":"2021-05-27","objectID":"/computer_networks/:3:6","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"TCP连接的建立 为什么发送方要发出第三个确认报文呢？ 已经失效的连接请求报文传送到对方，引起错误 ","date":"2021-05-27","objectID":"/computer_networks/:3:7","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"TCP的释放 等待计时器 等待2MSL时间 为什么等待2MSL 确保发送方的ACK可以到达接收方 2MSL时间内没有收到，则接收方会重发。保证接收方收到了最后一次挥手 确保当前连接的所有报文都已经过期 MSL: MSL(Max Segment Lifetime)：最长报文段寿命 MSL建议设置2分钟 ","date":"2021-05-27","objectID":"/computer_networks/:3:8","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"套接字与套接字编程 使用端口(Port)来标记不同的网络进程 端口(Port)使用16比特位表示(0~65535) 套接字(Socket)是抽象概念，表示TCP连接的一端 通过套接字可以金慈宁宫数据发送或接收 套接字编程流程： 服务端 客户端 域套接字和网络套接字 Unix域套接字只能用于在同一个计算机的进程间进行通信。但是使用Unix域套接字效率会更高，因为Unix域套接字仅仅进行数据复制，不会执行在网络协议栈中需要处理的添加、删除报文头、计算校验和、计算报文顺序等复杂操作 ","date":"2021-05-27","objectID":"/computer_networks/:3:9","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"计算机网络之应用层篇 传输层及以下提供完整的通信服务 应用层是面向用户的一层 UDP 多媒体信息分发 视频 语音 实时信息 TCP 可靠信息传输 金融交易 可靠通讯 MQ 应用层概述：（定义应用间通信的规则） 应用进程的报文类型（请求报文、应答报文） 报文的语法、格式 应用进程发送数据的时机、规则 ","date":"2021-05-27","objectID":"/computer_networks/:4:0","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"DNS详解DNS(Domain Name System:域名系统) 把域名转换为IP UDP协议 背景： IP不方便记忆，使用域名帮助记忆 域名： 域名由点、字母和数字组成 点分割不同的域 域名可以分为顶级域、二级域、三级域 域名分级： 顶级域： 国家 cn 中国 uk 英国 us 美国 ca 加拿大 通用 com 公司 net 网络服务机构 gov 政府机构 org 组织 二级域 域名服务器 根域名服务器 顶级域名服务器 域名服务器 访问方式： 先访问本地DNS服务器，没有的话在向上请求 DNS查询方式： 递归查询 迭代查询 一般来说，域名服务器之间的查询使用迭代查询方式，以免根域名服务器的压力过大。 ","date":"2021-05-27","objectID":"/computer_networks/:4:1","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"DHCP协议详解 DHCP(Dynamic Host Configuration Protocol:动态主机设置协议) DHCP是一个局域网协议 DHCP是应用UDP协议的应用层协议 临时IP 租期 工作流程： DHCP服务器监听默认端口：67 主机使用UDP协议广播DHCP发现报文 DHCP服务器发出DHCP提供报文 主机向DHCP服务器发出DHCP请求报文 DHCP服务器回应并提供IP地址 ","date":"2021-05-27","objectID":"/computer_networks/:4:2","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"HTTP协议详解 HTTP(HyperText Transfer Protocol:超文本传输协议) 超文本：带超链接的文本 http(s)://\u003c主机\u003e:\u003c端口\u003e/\u003c路径\u003e HTTP协议是可靠的数据传输协议 应用TCP协议 c/s架构： Web服务器 硬件部分 软件部分 请求流程 接受客户端连接 接收请求报文 处理请求 访问Web资源 构造应答 发送应答 请求方法 GET 获取指定的服务端资源 POST 提交数据到服务端 DELETE 删除指定的服务器资源 UPDATE 更新指定的服务端资源 PUT OPTIONS PATCH HEAD TRACE 指定资源 在地址中指定 在请求数据中指定 请求报文 应答报文 状态码 ","date":"2021-05-27","objectID":"/computer_networks/:4:3","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"HTTP工作的结构 Web缓存 Web代理 正向代理 反向代理 CDN Content Delivery Network: 内容分发网络 爬虫 ","date":"2021-05-27","objectID":"/computer_networks/:4:4","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"HTTPS协议详解 HTTP是明文传输的 HTTPS(Secure)是安全的HTTP协议 http(s)://\u003c主机\u003e:\u003c端口443\u003e/\u003c路径\u003e 加密模型 对称加密 非对称加密 A和B是拥有一定数学关系的一组密钥 私钥：私钥自己使用，不对外公开 公钥：公钥给大家使用，对外公开 数字证书 数字证书是可信任组织颁发给特定对象的认证 SSL SSL(Secure Socket Layer:安全套接层) 数据安全和数据完整 对传输层数据进行加密后传输 HTTPS工作流程 SSL安全参数握手过程 综合使用非对称加密 随机数3的传递使用非对称加密 秘钥根据随机数1、2、3生成，进行对称加密传输 ","date":"2021-05-27","objectID":"/computer_networks/:4:5","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"计算机网络实践 搭建服务基本框架 python操作字节序列 实现IP报文解析器 实现UDP报文解析器 实现TCP报文解析器 ","date":"2021-05-27","objectID":"/computer_networks/:5:0","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"搭建服务基本框架网卡工作模式： 混杂模式 接受所有经过网卡设备的数据 非混杂模式 只接受目的地址指向自己的数据 ","date":"2021-05-27","objectID":"/computer_networks/:5:1","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"Python操作字节序列 字节序 255 = 00000000,11111111 大端字节序 高位字节放在前面 低位字节放在后面 255 = 00000000,11111111 主要用于网络 小端字节序 位高字节放在后面，低位字节放在前面 255 = 11111111,00000000 主要用于计算机 原因 计算机电路先处理低位字节效率比较高 人类习惯读写大端字节序 格式字符 Python操作字节序列 ","date":"2021-05-27","objectID":"/computer_networks/:5:2","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"实现IP报文解析器 protocol： ","date":"2021-05-27","objectID":"/computer_networks/:5:3","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"实现UDP报文解析器","date":"2021-05-27","objectID":"/computer_networks/:5:4","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":"实现TCP报文解析器代码：https://github.com/Cuiks/review ","date":"2021-05-27","objectID":"/computer_networks/:5:5","tags":["计算机网络"],"title":"计算机网络","uri":"/computer_networks/"},{"categories":null,"content":" 操作系统之基础 操作系统之提升 操作系统实践 ","date":"2021-05-27","objectID":"/operate_system/:0:0","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"操作系统之基础篇","date":"2021-05-27","objectID":"/operate_system/:1:0","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"操作系统概览What管理硬件、提供用户交互的软件系统 操作系统是管理计算机硬件和软件资源的计算机程序 管理配置内存、决定资源供需顺序、控制输入输出设备等 操作系统提供让用户和系统交互的操作界面 Why 我们不能直接操作计算机赢家 设备种类繁多复杂，需要统一界面 操作系统的建议性使得更多人能够使用计算机 操作系统的基本功能 操作系统统一管理着计算机资源 处理器资源、IO设备资源、存储器资源、文件资源 操作系统实现了对计算机资源的抽象 用户无需面向硬件接口编程 IO设备管理软件，提供读写接口 文件管理软件，提供操作文件接口 操作系统提供了用户与计算机之间的接口 图像窗口形式 命令形式 系统调用形式 操作系统相关概念 并发性 并行使之两个或多个时间可以在同一个时刻发生 并发是指两个或多个时间可以在同一个时间间隔发生 共享性 共享性表现为操作系统中的资源可供多个并发的程序共同使用，这种共同使用的形式成为资源共享 互斥共享形式 同时访问形式 虚拟性 虚拟性表现为吧一个物理实体转变为若干个逻辑实体 物理实体是真实存在的，逻辑实体是虚拟的 虚拟的技术主要由时分复用技术和空分复用技术 时分复用技术 资源在时间上进行复用，不同程序并发使用 多道程序分时使用计算机的硬件资源 提高资源利用率 空分复用技术 空分复用技术用来实现虚拟磁盘、虚拟内存等 提高资源的利用率，提升编程效率 异步性 在多道程序环境下，允许多个进程并发执行 进程在使用资源时可能需要等待或放弃 进程的执行不是一气呵成的，而是以走走停停的形式推进 ","date":"2021-05-27","objectID":"/operate_system/:1:1","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"进程管理之进程实体为什么需要进程 进程是系统进行资源分配和调度的基本单位 进程作为程序独立运行的载体保障程序正常执行 进程的存在使得操作系统资源的利用率大幅提升 进程的实体 主存中的进程形态 进程标识符 处理机状态 处理调度信息 进程控制信息 进程控制块 标识符：唯一标记一个进程，用于区别其他进程 状态：标记进程的进程状态，如：运行态 程序计数器：进程即将被执行的下一条指令的地址 内存指针：程序代码、进程数据相关指针 上下文数据：进程执行时处理器存储的数据 IO状态信息：被进程IO操作所占用的文件列表 记账信息：使用处理器时间、时钟数总和等 进程控制块(PCB) 用于描述和控制进程运行的通用数据结构 记录进程当前状态和控制进程运行的全部信息 PCB使得进程是能够独立运行的基本单位 PCB是操作系统进行调度经常会被读取的信息 PCB是常驻内存的，存放在系统专门开辟的PCB区域内 进程与线程 进程(Process) 进程是系统进行资源分配和调度的基本单位 线程(Thread) 线程是操作系统进行运行调度的最小单位 包含在进程之中，是进程中实际运行工作的单位 一个进程可以并发多个线程，每个线程执行不同的任务 线程共享进程的资源 一个进程可以有一个或多个线程 ","date":"2021-05-27","objectID":"/operate_system/:1:2","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"进程管理之五状态模型 就绪状态 当进程被分配到除CPU以外的所有必要的资源后，只要再获取CPU的使用权，就可以立即运行。其他资源都准备好、只差CPU资源的状态为就绪状态。 执行状态 进行获得CPU，其程序正在执行成为执行状态。在单处理机中，在某个时刻只能有一个进程是出于执行状态。 阻塞状态 进程因某种原因(例如:其他设备未就绪而无法继续执行)从而放弃CPU的状态成为阻塞状态 创建状态 创建进程时拥有PCB但其他资源尚未就绪的状态成为创建状态 操作系统提供fork函数接口创建进程 终止状态 进程结束由系统清理或者归还PCB的状态称为终止状态 ","date":"2021-05-27","objectID":"/operate_system/:1:3","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"进程管理之进程同步为什么需要进程间同步 对竞争资源在多进程间进行使用次序的协调 使得并发执行的多个进程之间可以有效使用资源和相互合作 生产者-消费者问题 哲学家就餐问题 进程间同步的原则临界资源 临界资源指的是一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可重新竞争使用共享资源。 同步原则： 空闲让进：资源无占用，允许使用 忙则等待：资源有占用，请求进程等待 有限等待：保证有限等待时间能够使用资源 让权等待：等待时，进程需要让出CPU 进程同步方法： 消息队列 共享存储 信号量 线程同步进程内多线程也需要同步 线程同步方法： 互斥量 读写锁 自旋锁 条件变量 ","date":"2021-05-27","objectID":"/operate_system/:1:4","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"Linux的进程管理Linux进程的相关概念 进程的类型 前台进程 具有终端，可以和用户交互的进程 后台进程 与前台进程相对，没有占用终端的就是后台进程 后台程序基本上不和用户交互，优先级比前台进程低 将需要执行的命令以“\u0026”符号结束 守护进程 守护(daemon)进程是特殊的后台进程 很多守护进程在系统引导的时候启动，一直运行到系认关闭 Linux有很多典型的守护进程 进程名字以\"d\"结尾的一般都是守护进程 crond、sshd、httpd、mysqld 进程的标记 进程ID 进程ID是进程的唯一标记，每个进程拥有不同的ID 进程ID表现为一个非负整数，最大值由操作系统限定 父子进程关系可以通过pstree命令查看 ID为0的进程为idle进程，是系统创建的第一个进程 ID为1的进程为init进程，是0号进程的子进程，完成系统初始化 Init进程是所有用户进程的祖先进程 进程的状态标记 man ps查看进程各种状态的含义 操作Linux进程的相关命令 ps命令 ps -u root 查看root用户的进程 ps -axu|grep ‘python’ ps -ef –forest 查看进程树 ps -aux –sort=-pcpu/pmeme 根据cpu/内存使用频率倒序 top命令 kill命令 ","date":"2021-05-27","objectID":"/operate_system/:1:5","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"作业管理之进程调度进程调度概述 进程调度是指计算机通过决策决定哪个就绪进程可以获得CPU使用权 调度过程 保留旧进程的运行信息，清楚旧进程（收拾包袱） 选择新进程，准备运行环境并分配CPU（新进驻） 调度机制 就绪队列的排队机制 将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程 选择运行进程的委派机制 调度程序以一定的策略选择就绪进程，将CPU资源陪陪给他 新老进程的上下文切换机制 保存当前进程的上下文信息，装入被委派执行进程的运行上下文 调度方式 非抢占式的调度 处理器一旦分配给某个进程，就让该进程一直使用下去 调度程序不以任何原因抢占正在被使用的处理器 直到进程完成工作或因为IO阻塞才会让出处理器 抢占式的调度 允许调度程序以一定的策略暂停当前运行的进程 保存好旧进程的上下文信息，分配处理器给新进程 进程调度算法 先来先服务调度算法 短进程优先调度算法 调度程序优先选择就绪队列中估计运行时间最短的进程 短进程优先调度算法不利于长作业进程的执行 高优先权优先调度算法 进程附带优先权，调度程序优先选择权重很高的进程 高优先权优先调度算法使得紧迫的任务可以优先处理 时间片轮转调度算法 按照先来先服务的原则排列就绪进程 每次从队列头部取出待执行进程，分配一个时间片执行 是相对公平的调度算法，但不能保证及时响应用户 ","date":"2021-05-27","objectID":"/operate_system/:1:6","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"作业管理之死锁死锁：两个或者两个以上的进程在执行过程中，由于经这个资源或者由于彼此通信而造成的一中阻塞的现象，若无外力作用，他们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远处于互相等待的进程成为死锁进程。 死锁的产生 竞争资源 共享资源数量不满足各个进程需求，各个进程之间发生资源竞争导致死锁 进程调度顺序不当 死锁的四个必要条件 互斥条件 进程对资源的使用是排他性的使用 某资源只能由一个进程使用，其他进程需要使用只能等待 请求保持条件 进程至少保持一个资源，又提出新的资源请求 新资源被占用，请求被阻塞 被阻塞的进程不释放自己保持的资源 不可剥夺条件 进程获得的资源在未完成使用前不能被剥夺 获得的资源只能由进程自身释放 环路等待条件 发生死锁时，必然存在进程-资源环形链 死锁的处理 预防死锁的方法 摒弃请求保持条件 系统规定进程运行之前，一次性申请所有需要的资源，进程在运行期间不会提出资源请求，从而摒弃请求保持条件 摒弃不可剥夺条件 当一个进程请求新的资源得不到满足时，必须释放占有的资源。进程运行时占有的资源可以被释放，意味着可以剥夺 摒弃环路等待条件 可用资源线性排序，申请必须按照需要递增申请。线性申请不再形成环路，从而摒弃了环路等待条件 银行家算法 简介 是一个可操作的著名的避免死锁的算法。以银行借贷系统分配策略为基础的算法 策略基础 客户申请的贷款是有限的，每次申请需声明最大资金量 银行家在能够满足贷款时，都应该给用户贷款 客户在使用贷款后，能够及时归还贷款 算法 所需资源表 已分配资源变 还需分配资源表 = 所需资源表 - 已分配资源变 可分配资源表 比较 可分配资源变 和 还需分配资源表 ","date":"2021-05-27","objectID":"/operate_system/:1:7","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"存储管理之内存分配与回收内存分配与回收目的 确保计算机有足够的内存处理数据 确保程序可以从可用内存中获取一部分内存使用 确保程序可以归还使用后的内存一共其他程序使用 内存分配的过程 单一连续分配 最简单的内存分配方式 只能在单用户、单进程的操作系统中使用 固定分区分配 固定分区分配是支持多道程序的最简单存储分配方式 内存空间被划分为若干固定大小的区域 每个分区只提供给一个程序使用，互不干扰 动态分区分配 根据进程实际需要，动态分配内存空间 相关数据结构 动态分区空闲表数据结构 动态分区空闲链数据结构 动态内存分配算法 首次适应算法（FF算法） 分配内存是从开始顺序查找适合内存区 若没有合适的空闲区，则该次分配失败 每次都从头部开始，是的头部地址空间不断被划分 首次适应算法改进 – 循环适应算法 不从头部开始，从上一次位置继续查找 最佳适应算法（BF算法） 要求空闲区链表按照容量大小排序 遍历空闲区链表找到最合适空闲区 快速适应算法（QF算法） 要求有多个空闲区链表 每个空闲区链表存储一种容量的空闲区 内存回收的过程 空闲区位于回收区前面 不需要新建空闲区链表节点，只需要把空闲区1的容量增大为空闲区即可 空闲区位于回收区后面 将回收区与空闲区合并 新的空闲区使用回收区的地址 回收区位于两个空闲区之间 讲空闲区1、空闲区2和回收区合并，新的空闲区使用空闲区1的地址 回收区没有邻接空闲区 为回收区创建新的空闲节点 插入到响应的空闲区链表中去 ","date":"2021-05-27","objectID":"/operate_system/:1:8","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"存储管理之段页式存储管理页式存储管理 将进程逻辑空间等分成若干大小的页面 响应的吧物理内存空间分成页面大小的物理块 以页面为单位吧进程空间装进物理内存中分散的物理块 页面大小应该适中，过大难以分配，过小内存碎片过多 页面大小通常是512B~8K 页表记录进程逻辑空间与物理空间的映射 段式存储管理 将进程逻辑空间划分为若干段（非等分） 段的长度由连续逻辑的长度决定 主函数MAIN、子程序段X、子函数Y等 段式存储和页式存储都离散的管理了进程的逻辑空间 页是物理单位，段是逻辑单位 分页是为了合理利用空间，分段是满足用户要求 页大小由硬件固定，段长度可动态变化 页表信息是一维的，段表信息是二维的 段页式存储管理 先将逻辑空间按段式管理分成若干段 再把段内空间按页式管理等分成若干页 ","date":"2021-05-27","objectID":"/operate_system/:1:9","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"存储管理之虚拟内存虚拟内存概述 有些进程实际需要的内存很大，超过物理内存的容量 多道程序设计，使得每个进程可用物理内存更加稀缺 不可能无限增加物理内存，物理内存总有不够的时候 虚拟内存是操作系统内存管理的关键技术 使得多道程序运行和大程序运行成为现实 把程序使用内存划分，将程序暂时不使用的内存放置在辅存 程序的局部性原理 局部性原理是指CPU访问存储器的时候，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。 程序运行时，无需全部装入内存，装在部分即可 如果访问页不在内存，则发出缺页中断，发起页面置换 从用户层面，程序拥有很大的空间，即是虚拟内存 虚拟内存实际是对物理内存的扩充，速度接近于内存，成本接近于辅存 虚拟内存的置换算法 先进先出算法（FIFO） 最不经常使用算法（LFU） 最近最少使用算法（LRU） ","date":"2021-05-27","objectID":"/operate_system/:1:10","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"Linux的存储管理Buddy内存管理算法 经典的内存管理算法 基于计算机处理二进制的优势具有极高的效率 主要是为了解决内存碎片的问题 页内碎片：内存碎片是已经被分配出去的内存空间大于请求所需的内存空间，不能被利用的内存空间就是内部碎片。 页外碎片：外部碎片是指还没有分配出去，但是由于大小而无法分配给申请内存空间的新进程的内存空闲快。 Buddy算法： 向上取整为2的幂大小 伙伴系统 “伙伴”指的是内存的“伙伴” 一片连续内存的“伙伴”是相邻的另一片大小一样的连续内存 创建流程 创建一系列空闲快链表，每一个都是2的幂大小 分配内存块时，将剩余的空间补充回空闲快链表 回收流程 判断是否存在伙伴，存在即合并 Linux交换空间 交换空间（Swap）是磁盘的一个分区 Linux物理内存满时，会把一些内存交换至Swap空间 Swap空间是初始化系统时配置的 冷启动内存依赖 系统睡眠依赖 大进程空间依赖 ","date":"2021-05-27","objectID":"/operate_system/:1:11","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"操作系统的文件管理文件的逻辑结构 逻辑结构的文件类型 有结构文件 文本文件、文档、媒体文件 文件内容由定长记录和可变长记录组成 定长记录存储文件格式、文件描述等结构化数据项 可变长记录存储文件具体内容 无结构文件 二进制文件、链接库 也称为流式文件 文件内容长度以字节为单位 exe文件、dll文件、so文件 顺序文件 按照顺序存放在存储介质中的文件 磁带的存储特性使得磁带文件只能存储顺序文件 顺序文件是所有逻辑文件当中存储效率最高的 索引文件 可变长文件不适合使用顺序文件格式存储 索引文件是为了解决可变长文件存储而发明的一种文件格式 索引文件需要配合索引表完成存储的操作 辅存的存储空间分配 辅存的分配方式 连续分配 顺序读取文件内容非常容易，速度很快 对存储要求高，要求满足容量的连续存储空间 链接分配 链接分配可以将文件存储在离散的盘块中 需要额外的存储空间存储文件的盘块链接顺序 按照额外存储空间不同，分为： 隐式链接 隐式分配的下一个链接指向存储在当前盘块内 适合顺序访问，随机访问效率很低 可靠性差，任何一个链接出问题都会影响整个文件 显式链接 单独使用表记录物理块及下一盘块的地址（FAT: File Allocation Table） 不支持高效的直接存储（FAT记录项多） 检索式FAT表占用较大的存储空间（需要将整个FAT加载到内存） 索引分配 把文件的所有盘块集中存储（索引） 读取某个文件时，将文件索引读取进内存即可 优势 每个文件拥有一个索引快，记录所有盘块信息 索引分配方式支持直接访问盘块 文件较大时，索引分配方式具有明显优势 存储空间管理 空闲表 空闲盘区的分配与内存分配类似 首次适应算法、循环适应算法等 回收过程也与内存回收类似 空闲链表 吧所有空闲盘区组成一个空闲链表 每个链表节点存储空闲盘块和空闲的数目 位示图 位示图维护成本很低 位示图可以非常容易找到空闲盘块 位示图使用0/1比特位，占用空间小 目录管理目录树 任何文件或目录都只有唯一路径 ","date":"2021-05-27","objectID":"/operate_system/:1:12","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"linux文件基本操作Linux目录 一切皆文件 相对路径、绝对路径 Linux文件常用操作 目录/文件 创建、删除、读取、写入 Linux文件类型 套接字(s) 普通文件(-) 目录文件(d) 符号链接(l) 设备文件(b、c) FIFO(p) ","date":"2021-05-27","objectID":"/operate_system/:1:13","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"Linux的文件系统文件系统概览 FAT（File Allocation Table） FAT16、FAT32等，微软Dos/Windows使用的文件系统 使用一张表保存盘块的信息 NTFS（New Technology File System） WindowsNT环境的文件系统 NTFS对FAT进行了改进，取代了旧的文件系统 EXT2/3/4 （Extended file syatem）:扩展文件系统 Linux的文件系统 EXT2/3/4数字表示第几代 Ext文件系统 Inode Table 存放文件Inode的地方 每一个文件（目录）都有一个Inode 是每一个文件（目录）的索引节点 Inode 文件类型 文件权限 文件物理地址 文件长度 文件连接计数 文件存取时间 索引节点编号 文件状态 访问技术 链接指针 … 文件名不是存放在Inode节点上的，而是存放在目录的inode节点 列出目录文件的时候无需加载文件的Inode Inode bitmap(位示图) Inode的位示图 记录已分配的Inode和未分配的Inode Data block 存放文件内容的地方 每个block都有唯一的编号 文件的block记录在文件的Inode上 Block bitmap Block的位示图 记录Data block的使用情况 superblock 记录整个文件系统相关信息的地方 Block和Inode的使用情况 时间信息、控制信息等 ","date":"2021-05-27","objectID":"/operate_system/:1:14","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"操作系统的设备管理广义的IO设备 对CPU而言，凡是对CPU进行数据输入的都是输入设备 对CPU而言，凡是CPU进行数据输出的都是输出设备 按使用特性分类 存储设备：U盘、内存、磁盘 交互IO设备：键盘、显示器、鼠标 按设备的共享属性分类 独占设备 共享设备 虚拟设备 按信息交换的单位分类 块设备：磁盘、SD卡 字符设备：打印机、Shell终端 按传输速率分类 低速设备 中速设备 高速设备 IO设备的缓冲区 减少CPU处理IO请求的频率 提高CPU与IO设备之间的并行性 专用缓冲区只适用于特定的IO进程，当这样的IO进程比较多时，对内存的消耗也很大。 操作系统划出可供多个进程使用的公共缓冲区，成为缓冲池 SPOLing技术 是关于慢速字符设备如何与计算机主机交换信息的一种技术 利用高速共享设备将低速的独享设备模拟为高速的共享设备 逻辑上，系统为每一个用户都分配了一台独立的高速独享设备 虚拟设备技术 SPOOLing技术把同步调用低速设备改为异步调用 在输入、输出之间增加了排队转储环节（输入井、输出井） SPOOLing负责输入（出）井与低速设备之间的调度 逻辑上，进程直接与高速设备交互，减少了进程的 ","date":"2021-05-27","objectID":"/operate_system/:1:15","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"操作系统之提升篇","date":"2021-05-27","objectID":"/operate_system/:2:0","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"线程同步之互斥量原子性 原子性是指一系列操作不可被中断的特性。这一些类操作要么全部执行完成，要么全部没有执行，不存在部分执行部分未执行的情况 互斥量是最简单的线程同步的方法 互斥量（互斥锁），处于两态之一的变量：解锁和加锁 两个状态可以保证资源访问的串行 ","date":"2021-05-27","objectID":"/operate_system/:2:1","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"线程同步之自旋锁 自旋锁也是一种多线程同步的变量 使用自旋锁会反复检查锁变量是否可用 自旋锁不会让出CPU，是一种忙等待状态 死循环等待锁被释放 特点： 自旋锁避免了进程或线程上下文切换的开销 操作系统内部很多地方使用的是自旋锁 自旋锁不适合在单核CPU使用 ","date":"2021-05-27","objectID":"/operate_system/:2:2","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"线程同步之读写锁 读写锁是一种特殊的自旋锁 允许多个读者同事访问资源以提高读性能 对于写操作则是互斥的 ","date":"2021-05-27","objectID":"/operate_system/:2:3","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"线程同步之条件变量 条件变量是一种相对复杂的线程同步方法 条件变量允许线程睡眠，知道满足某种条件 当满足条件时，可以像该线程发送信号，通知唤醒 ","date":"2021-05-27","objectID":"/operate_system/:2:4","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"线程同步方法对比 ","date":"2021-05-27","objectID":"/operate_system/:2:5","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"使用fork系统调用创建进程 fork系统调用是用于创建进程的 fork创建的进程初始状态与父进程一样 系统会为fork的进程分配新的资源 fork系统调用无参数 fork会返回两次，分别返回子进程id和0 返回子进程id的是父进程，返回0的是子进程 ","date":"2021-05-27","objectID":"/operate_system/:2:6","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"进程同步之共享内存 在某种程度上，多进程是共同使用武力内存的 由于操作系统的进程管理，进程间的内存空间是独立的 进程默认是不能访问进程空间之外的内存空间的 共享存储允许不相关的进程访问同一片物理内存 共享内存是两个进程之间共享和传递数据最快的方式 共享内存未提供同步机制，需要借助其他机制管理访问 使用步骤： 申请共享内存 连接到进程空间 使用共享内存 脱离进程空间\u0026删除 ","date":"2021-05-27","objectID":"/operate_system/:2:7","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"进程同步之Unix域套接字 域套接字是一种高级的进程间通信的方法 Unix域套接字可以用于同一机器的进程间通信 套接字（socket）原是网络通信中使用的术语 Unix系统提供的域套接字提供了网络套接字类似的功能 服务端流程： 创建套接字 绑定(bind)套接字 监听(listen)套接字 接收\u0026处理信息 客户端流程： 创建套接字 连接套接字 发送信息 优势： 提供了单机简单可靠的进程通信同步服务 只能在单机使用，不能跨机器使用 ","date":"2021-05-27","objectID":"/operate_system/:2:8","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"操作系统实践 实现支持异步任务的线程池 ","date":"2021-05-27","objectID":"/operate_system/:3:0","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"Python同步原语 互斥锁 lock = threading.Lock() lock.acquire() lock.release() 条件变量 condition = threading.Condition() condition.acquire() condition.release() condition.wait() # 等待 condition.notify() # 通知 ","date":"2021-05-27","objectID":"/operate_system/:3:1","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"实现线程安全的队列Queue 队列用于存放多个元素，是存放各种元素的“池” 队列可能有多个线程同时操作，因此需要保证线程安全 ","date":"2021-05-27","objectID":"/operate_system/:3:2","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"实现基本任务对象Task任务处理逻辑 实现基本对象 任务参数 任务唯一标记uuid 任务具体的执行逻辑 ","date":"2021-05-27","objectID":"/operate_system/:3:3","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"线程池简介什么是线程池 线程池是存放多个线程的容器 CPU调度线程执行后不会销毁线程 将线程放回线程池重复利用 为什么使用线程池 线程是稀缺资源，不应该频繁创建和销毁 架构解耦，线程创建和业务处理解耦，更加优雅 线程池是使用线程的最佳实践 ","date":"2021-05-27","objectID":"/operate_system/:3:4","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"实现任务处理线程ProcessThread 任务处理线程需要不断的从任务队列里取任务执行 任务处理线程需要有一个标记，标记线程什么时候应该停止 实现任务处理线程 基本属性（任务队列、标记） 线程执行的逻辑（run） 线程停止（stop） ","date":"2021-05-27","objectID":"/operate_system/:3:5","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"实现任务处理线程池Pool","date":"2021-05-27","objectID":"/operate_system/:3:6","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"编写测试用例","date":"2021-05-27","objectID":"/operate_system/:3:7","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":"实现异步任务处理AsyncTask 不知道任务什么时候执行 不知道任务什么时候执行完成 操作 给任务添加一个标记，任务完成后，则标记为已完成 任务完成时，可直接获取任务运行结果 任务未完成时，获取任务结果，会阻塞获取线程 实现AsyncTask 设置运行结果（set_result） 获取运行结果（get_result） 代码：https://github.com/Cuiks/review ","date":"2021-05-27","objectID":"/operate_system/:3:8","tags":["计算机操作系统"],"title":"计算机操作系统","uri":"/operate_system/"},{"categories":null,"content":" 计算机原理之概述 计算机原理之组成 计算机组成原理之计算 计算机组成原理实践 ","date":"2021-05-27","objectID":"/computer_basic/:0:0","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机原理之概述","date":"2021-05-27","objectID":"/computer_basic/:1:0","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机的发展历史 计算机发展的四个阶段 微型计算机的发展历史 ","date":"2021-05-27","objectID":"/computer_basic/:1:1","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机的分类 超级计算机 大型计算机 迷你计算机（服务器） 工作站 微型计算机 ","date":"2021-05-27","objectID":"/computer_basic/:1:2","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机的体系与结构冯诺依曼体系将程序指令和数据一起存储的计算机设计概念结构 必须有一个存储器 必须有一个控制器 必须有一个运算器 必须有输入设备 必须有输出设备 现代计算机都是冯诺依曼机。 能够把需要的程序和数据送至计算机中 能够长期记忆程序、数据、中间结果及最终运算结果的能力 能够具备算数、逻辑运算和数据传送等数据加工处理的能力 能够按照要求将处理结果输出给用户 现代计算机的结构 现代计算机在冯诺依曼体系结构基础上进行修改 解决CPU与存储设备之间的性能差异问题 ","date":"2021-05-27","objectID":"/computer_basic/:1:3","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机的层次与编程语言程序翻译与程序解释 计算机执行的指令都是L0 翻译过程生成新的L0程序，解释过程不生成新的L0程序 解释过程由L0编写的解释器去解释L1程序 计算机的层次与编程语言 硬件逻辑层 微程序机器层 传统机器层 它们的关系: 一条机器指令对应一个微程序 一个微程序对应一组微指令 操作系统层 汇编语言层 高级语言层 应用层 ","date":"2021-05-27","objectID":"/computer_basic/:1:4","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机的速度单位容量单位 1Byte = 8bits 速度单位 网络速度 100M/S = 100 Mbps = 100 Mbit/s = (100/8)MB/s = 12.5MB/s CPU速度 CPU的速度一般体现在CPU的时钟频率 CPU的时钟频率的单位一般是赫兹(Hz) Hz就是秒分之一 每秒中的周期性变动重复次数的计量 ","date":"2021-05-27","objectID":"/computer_basic/:1:5","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机的字符与编码集字符编码集的历史 ASCII码 使用7个bits就可以完全表示ASCII码 包含95个可打印字符 33个不可打印字符（包括控制字符） 很多应用或者国家中的符号都无法表示。于是7bits-\u003e8bits，出现Extended ASCII码 Extended ASCII码 字符编码集的国际化 GB2312 GBK Unicode。定义了世界通用的符号集，UTF-*实现了编码。UTF-8以字节为单位对Unicode进行编码 ","date":"2021-05-27","objectID":"/computer_basic/:1:6","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机原理之组成","date":"2021-05-27","objectID":"/computer_basic/:2:0","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机的总线总线的概述USB:Universal Serial Bus（通用串行总线） 提供了对外连接的接口 不同设备可以通过USB接口进行连接 连接的标准，促使外围设备接口的统一 PCI总线、ISA总线。。。。。。 解决不同设备之间的通信问题 总线的分类： 片内总线 芯片内部的总线 寄存器与寄存器之间 寄存器与控制器、运算器之间 高集成度芯片内部的信息传输线 系统总线 数据总线 双向传输各个部件的数据信息 数据总线的位数（总线宽度）是数据总线的重要参数。一般与CPU位数相同（32位、64位） 地址总线 指定源数据或目的数据在内存中的地址 地址总线的位数与存储单元有关。地址总线位数=n，寻址范围：0~2^n 控制总线 控制总线是用来发出各种控制信号的传输线 控制信号经由控制总线从一个组件发给另一个组件 控制总线可以见识不同组件之间的状态（就绪/未就绪） 总线的仲裁为什么需要总线的仲裁 为了解决总线使用权的冲突问题 总线仲裁的方法 链式查询 好处：电路复杂度低，仲裁方式简单 坏处：优先级低的设备难以获得总线使用权 坏处：对电路故障敏感 计时器定时查询 仲裁控制器对设备编号并使用计数器累计计数 接收到仲裁信号后，往所有设备发出计数值 计数值与设备编号一致则获得总线使用权 独立请求 每个设备均有总线独立连接仲裁器 设备可单独向仲裁器发送请求和接收请求 当同时收到多个请求信号，仲裁器有权按优先级分配使用权 好处：响应速度快，优先顺序可动态改变 坏处：设备连线多，总线控制复杂 ","date":"2021-05-27","objectID":"/computer_basic/:2:1","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机的输入输出设备常见的输入输出设备 常见输入设备 字符输入设备 图像输入设备 输入输出接口的通用设计 数据线 是I/O设备与主机之间进行数据交换的传送线 单向传输数据线 双向传输数据线 状态线 IO设备状态向主机报告的信号线 查询设备是否已经正常连接并就绪 查询设备是否已经被占用 命令线 CPU向设备发送命令的信号线 发送读写信号 发送启动停止信号 设备选择线 主机选择I/O设备进行操作的信号线 对连在总线上的设备进行选择 CPU与IO设备的通信 程序中断 当外围IO设备就绪时，向CPU发出中断信号 CPU有专门的电路响应中断信号 提供低速设备通知CPU的一种异步的方式 CPU可以高速运转同事兼顾低速设备的响应 DMA(直接存储器访问) DMA直接连接主存与IO设备 DMA工作时不需要CPU的参与 ","date":"2021-05-27","objectID":"/computer_basic/:2:2","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机存储器概览存储器的分类 按照存储介质 半导体存储器。内存、U盘、固态硬盘 磁存储器。磁带、磁盘 按照存取方式 随机存储器(RAM)。随机读取、与位置无关 串行存储器。与位置有关、按顺序查找 只读存储器(ROM)。只读不写 存储器的层次结构读写速度、存储容量、价格。位价：每比特位价格。 缓存、主存、辅存 缓存-主存层次 原理：局部性原理 局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。 实现：在CPU与主存直接增加一层速度快（容量小）的Cache 目的：解决主存速度不足的问题 主存-辅存层次 原理：局部性原理 实现：主存之外增加辅助存储器（磁盘、SD卡、U盘等） 目的：解决主存容量不足的问题 ","date":"2021-05-27","objectID":"/computer_basic/:2:3","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机的主存储器与辅助存储器 主存储器–内存 RAM（随机存取存储器：Random Access Memory） RAM通过电容存储数据，必须隔一段时间刷新一次 如果掉电，那么一段时间后将丢失所有数据 辅助存储器–磁盘 表面是可磁化的硬磁特性材料 移动磁头径向运动读取磁道信息 磁盘调度算法 先来先服务算法 按照顺序访问进程的磁道读写需求 最短寻到时间优先 与磁头当前位置有关 优先访问离磁头最近的磁道 扫描算法（电梯算法） 每次只往一个方向移动 到达一个方向需要服务的尽头再反方向移动 循环扫描算法 只往一个方向移动 ","date":"2021-05-27","objectID":"/computer_basic/:2:4","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机的高速缓存 高速缓存的工作原理 字：是指存放在一个存储单元中的二进制代码组合 字块：存储在连续的存储单元中而被看做是一个单元的一组字 字的地址包含两个部分。前m位指定字块的地址，后b位指定字在字块中的地址 命中率是衡量缓存的重要性能指标 理论上CPU每次都能从高速缓存存取数据的时候，命中率为1 命中率：h = Nc/(Nc+Nm)。访问效率：e = Tc/Ta = Tc/(hTc + (1-h)Tm) 高速缓存的替换策略 随机算法 先进先出算法 FIFO 把高速缓存看做是一个先进先出的队列 优先替换最先进入队列的字块 最不经常使用算法 LFU 优先淘汰最不经常使用的字块 需要额外空间记录字块的使用频率 最近最少使用算法 LRU 优先淘汰一段时间内没有使用的字块 有多种实现方法，一般使用双向链表 把当前访问节点置于链表前面，保证链表头部节点是最近使用的。淘汰链表尾部节点 ","date":"2021-05-27","objectID":"/computer_basic/:2:5","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机的指令系统机器指令的形式 机器指令主要由两部分组成：操作码、地址码 操作码指明指令所要完成的操作 操作码的位数反映了机器的操作种类 地址码直接给出操作数或者操作数的地址 分三地址指令、二地址指令、一地址指令、零地址指令 零地址指令：在机器指令中无地址码。空操作、停机操作、中断返回操作等 机器指令的操作类型 数据传输 寄存器之间、寄存器与存储单元、存储单元之间传送 数据读写、交换地址数据、清零置一等操作 算术逻辑操作 操作数之间的加减乘除运算 操作数的与或非等逻辑位运算 移位操作 数据左移（乘2）、数据右移（除2） 完成数据在算术逻辑单元的必要操作 控制指令 等待指令、停机指令、空操作指令、中断指令等 机器指令的寻址方式 指令寻址 顺序寻址 跳跃寻址 数据寻址 立即寻址 指令直接获取操作数，无需访问存储器 直接寻址 直接给出操作数在主存的地址 寻找操作数简单，无需计算数据地址 间接寻址 指令地址码给出的是操作数地址的地址 需要访问一次或多次主存来获取操作数 ","date":"2021-05-27","objectID":"/computer_basic/:2:6","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机的控制器控制器是协调和控制计算机运行的 控制器分为： 程序计数器 用来存储下一条指令的地址 循环从程序计数器中拿出指令 当指令被拿出时，指向下一条指令 时序发生器 电气工程领域，用于发送时序脉冲 CPU依据不同的时序脉冲有节奏的进行工作 指令译码器 控制器的主要部件之一 计算机指令由操作码和地址码组成 翻译操作码对应的操作以及控制传输地址码对应的数据 各种寄存器 指令寄存器 也是控制器的主要部件之一 从主存或高速缓存取计算机指令 主存地址寄存器 保存当前CPU正要访问的内存单元的地址 主存数据寄存器 保存当前CPU正要读或写的主存数据 通用寄存器 用于暂时存放或传送数据或指令 可保存ALU的运算中间结果 容量比一般专用寄存器要大 ","date":"2021-05-27","objectID":"/computer_basic/:2:7","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机的运算器运算器是用来进行数据运算加工的 数据缓冲器 分为输入缓冲和输出缓冲 输入缓冲暂时存放外设送过来的数据 输出缓冲暂时存放送往外设的数据 ALU ALU：算术逻辑单元，是计算机的主要组成 常见的位运算（左右移、与或非等） 算术运算（加减乘除等） 通用寄存器 用于暂时存放或传送数据或指令 可保存ALU的运算中间结果 容量比一般专用寄存器要大 状态字寄存器 存放运算状态（条件码、进位、溢出、结果正负等） 存放运算控制信息（调试跟踪标记位、允许中断位等） ","date":"2021-05-27","objectID":"/computer_basic/:2:8","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机指令的执行过程 指令执行过程 取指令：从缓存取指令，送到指令寄存器 分析指令：指令译码器译码，发出控制信号，程序计数器+1 执行指令：装载数据到寄存器，ALU处理数据，记录运算状态，送出运算结果 CPU的流水线设计 类似工厂的装配线 工厂的装配线使得多个产品可以同时被加工 在同一个时刻，不同产品均位于不同的加工阶段 ","date":"2021-05-27","objectID":"/computer_basic/:2:9","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机组成原理之计算","date":"2021-05-27","objectID":"/computer_basic/:3:0","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"进制运算的基础进制概述 进制的定义 进位制是一种计数方式，亦称进位计数法或位值记数法 有限种数字符号来表示无限的数值 使用的数字符号的数目成为这种进位制的基数或底数 常见的进制 二进制运算的基础 二进制转化十进制：按权展开法 N = (01100101) = 1*2^6 + 1*2^5 + 1*2^2 + 1 = 101 十进制转换二进制：重复相除法 小数二进制转换十进制：按权展开法 N = (0.11001) = 1*2^-1 + 1*2^-2 + 1*2^-5 = 0.78125 = 25/32 小数十进制转二进制：重复想乘法 ","date":"2021-05-27","objectID":"/computer_basic/:3:1","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"有符号数与无符号数 原码表示法 使用0表示正数、1表示负数 规定符号位位于数值第一位 表达简单明了，是最容易理解的表示法 ","date":"2021-05-27","objectID":"/computer_basic/:3:2","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"二进制的不补码表示法 补码的定义 n=4,x=13。x的补码 = 源码 = 01101 x=-13。x的补码 = 2^5-13 = 100000-1101 = 10011 ","date":"2021-05-27","objectID":"/computer_basic/:3:3","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"二进制的反码表示法 反码的定义 负数的反码等于原码除符号位外按位取反 负数的补码等于反码+1 ","date":"2021-05-27","objectID":"/computer_basic/:3:4","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"小数的补码 二进制小数的补码 ","date":"2021-05-27","objectID":"/computer_basic/:3:5","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"定点数与浮点数定点数的表示方法 小数点固定在某个位置的数成为定点数 纯小数：小数点位于符号位和数值为之间 纯整数：小数点位于符号位和数值位之后 如果不是纯小数也不是纯整数，就需要乘以一个比例因子以满足定点数的保存格式 计算机处理的很大程度上不是纯小数或纯整数 数据范围很大，定点数难以表达 浮点数的表示方法 浮点数的表示格式 浮点数的表示范围 假设阶码数值取m位，尾数取n位 阶码表示范围：[-(2^m-1),2^m-1] 尾数表示范围：[-(1-2^-n),-(2^-n)] [2^-n,1-2^-n] 单精度浮点数：使用4字节、32位来表达浮点数 float 双精度浮点数：使用8字节、64位来表达浮点数 double 浮点数的规格化 尾数规定使用纯小数 尾数最高位必须是1 定点数与浮点数的对比 当定点数与浮点数位数相同时，浮点数表示的范围更大 当浮点数尾数为规格化数时，浮点数的精度更高 浮点数运算包含阶码和尾数，浮点数的运算更为复杂 浮点数在数的表示范围、精度、溢出处理、编程等方便均优于定点数 浮点数在数的运算规则、运算速度、硬件成本方便不如定点数 ","date":"2021-05-27","objectID":"/computer_basic/:3:6","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"定点数的加减法运算定点数的加法运算 数值位与符号位一同运算，并将符号位产生的进位自然丢掉 判断溢出 双符号位判断法 单符号位表示变成双符号位：0=\u003e00,1=\u003e11 双符号位产生的进位丢弃 结果的双符号位不同则表示溢出 定点数的减法运算 ","date":"2021-05-27","objectID":"/computer_basic/:3:7","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"浮点数的加减法运算运算步骤 对阶 对阶的目的是是的两个浮点数阶码一致，使得尾数可以进行运算 浮点数尾数运算简单 浮点数尾数实际小数位与阶码有关 阶码按小阶看齐大阶的原则 尾数求和 使用补码进行运算 减法运算转化为加法运算：A - B = A + (-B) 尾数规格化 对补码进行规格化需要判断两种情况：S\u003e0和S\u003c0 尾数规格化（右移） 一般情况下都是左移 双符号位不一致下需要右移（定点运算的溢出情况） 右移的话需要进行舍入操作 舍入 “0舍1入”法（二进制的四舍五入） 溢出判断 浮点数运尾数双符号位不一致不算溢出，因为尾数双符号位可以右移进行规格化 浮点运算主要通过阶码的双符号位判断是否溢出 如果规格化后，阶码双符号位不一致，则认为溢出 ","date":"2021-05-27","objectID":"/computer_basic/:3:8","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"浮点数的乘除法运算浮点数乘法 浮点数除法 例子 ","date":"2021-05-27","objectID":"/computer_basic/:3:9","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":"计算机组成原理 实践双向链表的原理与实践1 双向链表可以快速找到上一个节点（和下一个节点） 可以快速的去掉链表中的某一个节点 代码：https://github.com/Cuiks/review ","date":"2021-05-27","objectID":"/computer_basic/:4:0","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/computer_basic/"},{"categories":null,"content":" Mysql学习 ","date":"2021-04-25","objectID":"/mysql-45/:0:0","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"01讲 基础架构：一条sql查询语句是如何运行的","date":"2021-04-25","objectID":"/mysql-45/:1:0","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"mysql基本架构 ","date":"2021-04-25","objectID":"/mysql-45/:1:1","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"mysql可以分为Server层和存储引擎层两部分。 Server层包括连接器、查询缓存、分析器、优化器、执行器 存储引擎层负责数据的存储和提取。插件式，支持InnoDB、MyISAM、Memory等 连接器 负责跟客户端建立连接、获取权限、维持和管理连接 mysql -h$ip -P$port -u$user -p 客户端长时间无操作会被连接器自动断开。由参数wait_timeout控制。默认8小时 通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。 查询缓存 将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。 对于确定要使用查询缓存的语句，可以用SQL_CACHE显式指定：select SQL_CACHE * from T where ID=10； MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。 分析器 对SQL语句先做词法分析，然后做语法分析。 优化器 决定使用哪个索引 决定表关联连接顺序 执行器 首先判断用户执行权限 慢查询日志中rows_examined字段，表示这个语句扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。 ","date":"2021-04-25","objectID":"/mysql-45/:1:2","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"02讲 日志系统：一条SQL更新语句是如何执行的","date":"2021-04-25","objectID":"/mysql-45/:2:0","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"日志模块：redo log InooDB引擎特有的日志 WAL技术，全称是Write-Ahead Logging，关键点就是先写日志，再写磁盘 有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。 innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。 ","date":"2021-04-25","objectID":"/mysql-45/:2:1","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"重要的日志模块：binlog Server层日志 redo log和binlog区别 redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。 redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。 redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。 ","date":"2021-04-25","objectID":"/mysql-45/:2:2","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"03讲 事务隔离：为什么你改了我还看不见","date":"2021-04-25","objectID":"/mysql-45/:3:0","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"隔离性与隔离级别 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性） 为了解决脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，于是有了“隔离级别”的概念。 隔离级别 读未提交（read uncommitted）：一个事务还没提交时，它做的变更就能被别的事务看到。 读提交（read committed）：一个事务提交之后，他做的变更才会被其他事务看到。 可重复读（repeatable read)：一个事务执行过程中看到的数据，总是跟这个事务在启动时候看到的数据是一致的。在可重复读隔离级别下，为提交变更对其他事务也是不可见的。 串行化（serializable）：对同一行记录，读写都会加锁。当出现锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 事务隔离的实现事务的启动方式 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。 set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。 查找持续时间超过60S的事务： select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))\u003e60 ","date":"2021-04-25","objectID":"/mysql-45/:3:1","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"04讲 深入浅出索引（上）索引的出现就是为了提高查询的效率，类似书的目录一样。 ","date":"2021-04-25","objectID":"/mysql-45/:4:0","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"索引的常见模型 哈希表、有序数组和搜索树 哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。 哈希表这种结构适用于只有等值查询的场景，比如Memcached及其他一些NoSQL引擎。 有序数组在等值查询和范围查询场景中的性能就都非常优秀 有序数组索引只适用于静态存储引擎，在需要更新数据的时候比较麻烦 ","date":"2021-04-25","objectID":"/mysql-45/:4:1","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"InnoDB索引模型在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表成为索引组织表。InnoDB使用了B+树索引模型，所以数据都是存储在B+树中。 每一个索引在InnoDB中对应一棵B+树。 索引类型分为主键索引和非主键索引： 主键索引的叶子节点存的是整行数据。InnoDB中，主键索引也被称为聚簇索引。 非主键索引的叶子节点存的是主键的值。InnoDB中，非主键索引也被称为二级索引。 基于主键索引和普通索引的查询有什么区别？ 主键查询方式，则只需要搜索ID这棵B+树； 普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。 基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。 ","date":"2021-04-25","objectID":"/mysql-45/:4:2","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"索引维护重建索引alter table T engine=InnoDB ","date":"2021-04-25","objectID":"/mysql-45/:4:3","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"05讲 深入浅出索引（下）回到主键索引树搜索的过程，我们称为回表。 ","date":"2021-04-25","objectID":"/mysql-45/:5:0","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"覆盖索引在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。 select ID from T where k between 3 and 5，这时ID的值已经在k索引树上了 ","date":"2021-04-25","objectID":"/mysql-45/:5:1","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"最左前缀原则在建立联合索引的时候，如何安排索引内的字段顺序。 第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。 然后考虑空间。 ","date":"2021-04-25","objectID":"/mysql-45/:5:2","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"索引下推可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。 select * from tuser where name like '张%' and age=10 and ismale=1;，根据索引搜索的时候，InnoDB在(name,age)索引内部就判断了age，对于不符合的记录，直接判断并跳过。只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。 ","date":"2021-04-25","objectID":"/mysql-45/:5:3","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"06讲 全局锁和表锁根据加锁的范围，Mysql的锁可以分为全局锁、表级锁、行锁 ","date":"2021-04-25","objectID":"/mysql-45/:6:0","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"全局锁对整个数据库实例加锁，一般用于全库逻辑备份。 MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候， 对于支持事务的引擎，可以通过事务，保证拿到一致性视图。官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。 对于不支持事务的引擎，使用FTWRL。 ","date":"2021-04-25","objectID":"/mysql-45/:6:1","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"表级锁Mysql的表级锁有两种，一种是表锁，一种是元数据锁。 表锁的语法是 lock tables … read/write。与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。 另一类表级的锁是MDL（metadata lock)。MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。 如何安全地给小表加字段？ 避免MDL锁冲突，可以在alter table语句里面设定等待时间。ALTER TABLE tbl_name WAIT N add column ... ","date":"2021-04-25","objectID":"/mysql-45/:6:2","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"07讲 行锁功过","date":"2021-04-25","objectID":"/mysql-45/:7:0","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"两阶段锁两阶段锁协议：在InnoDB事务中，行锁是在需要的时候加上的，但并不是不需要了立即释放，而是等事务结束时才释放。 如果在事务中需要锁多行，应该把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。 ","date":"2021-04-25","objectID":"/mysql-45/:7:1","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"死锁和死锁检测出现死锁后，有两种策略： 直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout(默认50s)来设置。 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。 死锁检测是O(n)的操作，因此出现热点数据时，死锁检测要耗费大量的CPU资源。 可以通过修改一行为逻辑上的多行的方式，减少锁冲突。 ","date":"2021-04-25","objectID":"/mysql-45/:7:2","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":"08讲 事务到底是隔离的还是不隔离的","date":"2021-04-25","objectID":"/mysql-45/:8:0","tags":["mysql"],"title":"Mysql实战45讲笔记","uri":"/mysql-45/"},{"categories":null,"content":" 介绍了django-quill-editor在Django中的使用 在django-quill-editor基础上添加了imageResize调整图片大小功能 ","date":"2021-04-08","objectID":"/django-richtext-quill/:0:0","tags":["django","quill"],"title":"Django富文本编辑器django-quill-editor","uri":"/django-richtext-quill/"},{"categories":null,"content":"前言最近在做一个web项目，用到了富文本编辑器，主要目的是为了方便粘贴图片，类似截图后可以直接ctrl+v把粘贴板里的图片粘贴到编辑框中。项目使用了python3+Django，所以也就是使用一个Django的富文本编辑器。Django常用的富文本编辑器django-ckeditor，django-tinymce，django-quill，django-quill-editor等。本文主要介绍django-quill-editor的使用，因为在开发过程中发现粘贴进去的图片不能修改大小，非常不方便，于是通过Quill扩展的方式添加了图片添加大小的扩展，遂写此文章记录。🌝 demo projec: Cuiks/django-quill-editor。该项目fork自kensnyder/quill-image-resize-module。添加了修改图片大小功能。 ","date":"2021-04-08","objectID":"/django-richtext-quill/:1:0","tags":["django","quill"],"title":"Django富文本编辑器django-quill-editor","uri":"/django-richtext-quill/"},{"categories":null,"content":"文章结构 django-quill-editor在Django中的配置及使用 django-quill-editor图片插件的配置及使用 遇到的问题 ","date":"2021-04-08","objectID":"/django-richtext-quill/:2:0","tags":["django","quill"],"title":"Django富文本编辑器django-quill-editor","uri":"/django-richtext-quill/"},{"categories":null,"content":"1、django-quill-editor在Django中的配置及使用官方文档介绍的简单明了，但是也基本够用😐 安装 pip install django-quill-editor Django配置 # 添加到Django INSTALLED_APPS = [ 'django.contrib.admin', ... 'django_quill', ] Django model配置 \u0026\u0026 数据迁移 # models.py from django.db import models from django_quill.fields import QuillField class QuillPost(models.Model): content = QuillField() Django admin注册 from django.contrib import admin from .models import QuillPost @admin.register(QuillPost) class QuillPostAdmin(admin.ModelAdmin): pass 注册完成后看到如下 Form表单使用 # 在前端界面使用该方法引入 \u003chead\u003e {{ form.media }} \u003c/head\u003e # 或使用该方法引入 \u003chead\u003e \u003c!-- django-quill-editor Media --\u003e {% include 'django_quill/media.html' %} \u003c/head\u003e # 表单中配置 # forms.py from django import forms from .models import QuillPost class QuillPostForm(forms.ModelForm): class Meta: model = QuillPost fields = ( 'content', ) # 返回的view使用表单 # views.py from django.shortcuts import render from .forms import QuillPostForm def model_form_view(request): return render(request, 'form_view.html', {'form': QuillPostForm()}) # 前端页面展示表单 \u003c!-- form_view.html --\u003e \u003cform action=\"\" method=\"POST\"\u003e{% csrf_token %} {{ form.content }} \u003c/form\u003e 注：文档分别介绍了Using as form和Using as ModelForm。本文只介绍后者使用。 自定义配置 # 修改Django的配置文件settings.py。添加 QUILL_CONFIGS = { 'default':{ 'theme': 'snow', 'modules': { 'syntax': True, 'toolbar': [ [ {'font': []}, {'header': []}, {'align': []}, 'bold', 'italic', 'underline', 'strike', 'blockquote', {'color': []}, {'background': []}, ], ['code-block', 'link'], ['clean'], ] } } } 关于配置项可参考：Quill Configuration 富文本编辑框的前端回显展示(Django模板语言) # html页面展示 \u003cdiv class=\"form-control ql-editor ql-container ql-snow\"\u003e{{ object.content.html|safe }}\u003c/div\u003e 使用conten.html属性，可以获取该字段html格式，添加safe控制，可在前端进行展示。 ","date":"2021-04-08","objectID":"/django-richtext-quill/:2:1","tags":["django","quill"],"title":"Django富文本编辑器django-quill-editor","uri":"/django-richtext-quill/"},{"categories":null,"content":"2、django-quill-editor图片插件的配置及使用配置完成后，粘贴图片进去会发现往往图片充满了整个编辑框，看起来很不方便。通过查阅Quill文档。会发现Quill的Modules支持自定义扩展，所以确定方向：寻找(让我写，我也不会啊🌚)Quill调整图片大小的扩展。QuillJS是一个比较热门的项目，很像web框架都开发了响应的扩展。在网上搜索发现项目quill-image-resize-module就是专门为Quill开发的扩展用于调整图片大小。到此我们就找到了Quill调节图片大小的方案。 接下来介绍怎么在django-quill-editor中使用自定义Modules。 下载Modules 或 使用CDN引入Modules。此处我使用后者。google上找的CDN地址，也不知道稳不稳🌑 项目中引入。此处需要注意，Modules必须在Quill后面引入，否则会报错。 \u003chead\u003e {% include 'django_quill/media.html' %} \u003c!-- Quill resize-image.js --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/quill-image-resize-module@3.0.0/image-resize.min.js\"\u003e\u003c/script\u003e \u003c/head\u003e 修改Django项目settings.py，引入imageResize # Quill config QUILL_CONFIGS = { \"default\": { 'theme': 'snow', 'modules': { 'syntax': True, 'toolbar': [ [ {'font': []}, {'header': []}, {'align': []}, 'bold', 'italic', 'underline', 'strike', 'blockquote', {'color': []}, {'background': []}, ], ['code-block', 'link', 'image', 'video'], ['clean'], ], 'imageResize': { # open imageResize 'displaySize': True } } } } 前端实现效果 admin引入imageResize # admin.py。添加静态文件并控制引入顺序 @admin.register(QuillPost) class QuillPostAdmin(admin.ModelAdmin): class Media: js = ( 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js', 'django_quill/django_quill.js', 'https://cdn.quilljs.com/1.3.7/quill.min.js', \"https://cdn.jsdelivr.net/npm/quill-image-resize-module@3.0.0/image-resize.min.js\", ) ","date":"2021-04-08","objectID":"/django-richtext-quill/:2:2","tags":["django","quill"],"title":"Django富文本编辑器django-quill-editor","uri":"/django-richtext-quill/"},{"categories":null,"content":"3、遇到的问题上面已经强调过，Quill的Modules必须要在Quill之后引入，否则就会报找不到的错误，如下： Uncaught TypeError: Cannot read property 'imports' of undefined at Object.\u003canonymous\u003e (image-resize.min.js:1) at e (image-resize.min.js:1) at Object.\u003canonymous\u003e (image-resize.min.js:1) at e (image-resize.min.js:1) at image-resize.min.js:1 at image-resize.min.js:1 at image-resize.min.js:1 at image-resize.min.js:1 quill.min.js:7 quill Cannot import modules/imageResize. Are you sure it was registered? quill.min.js:7 quill Cannot load imageResize module. Are you sure you registered it? quill.min.js:7 quill Cannot import modules/imageResize. Are you sure it was registered? quill.min.js:7 Uncaught TypeError: e is not a constructor at e.value (quill.min.js:7) at e.value (quill.min.js:7) at quill.min.js:7 at Array.forEach (\u003canonymous\u003e) at e.value (quill.min.js:7) at new t (quill.min.js:7) at new QuillWrapper (VM153 django_quill.js:9) at (index):157 at (index):159 django_quill.js:1 Uncaught SyntaxError: Identifier 'QuillWrapper' has already been declared 如果使用框架应该就没有引入顺序这些麻烦了吧😐 ","date":"2021-04-08","objectID":"/django-richtext-quill/:2:3","tags":["django","quill"],"title":"Django富文本编辑器django-quill-editor","uri":"/django-richtext-quill/"},{"categories":null,"content":"结束语OK。本文就介绍在这里，有什么问题欢迎在评论区与我讨论。实现/修改代码在仓库Cuiks/django-quill-editor。 🔚 ","date":"2021-04-08","objectID":"/django-richtext-quill/:3:0","tags":["django","quill"],"title":"Django富文本编辑器django-quill-editor","uri":"/django-richtext-quill/"},{"categories":null,"content":" postgre远程访问 postgre账号授权 ","date":"2021-04-06","objectID":"/postgre-config/:0:0","tags":["database","postgresql"],"title":"postgresql配置远程访问、账号授权","uri":"/postgre-config/"},{"categories":null,"content":"前言因为工作中用到PostgreSQL。数据库装在物理机中，对外提供服务。 ","date":"2021-04-06","objectID":"/postgre-config/:1:0","tags":["database","postgresql"],"title":"postgresql配置远程访问、账号授权","uri":"/postgre-config/"},{"categories":null,"content":"远程访问 查看配置文件位置 # 连接pgsql psql -U \u003c用户名\u003e # 查看配置文件位置 select name,setting from pg_settings where category='File Locations'; 修改服务监听地址 # 修改配置文件postgresql.conf。上述步骤获取 vim \u003cconfig_file 配置文件地址\u003e # 修改监听地址。打开配置项 listen_addresses listen_addresses = '*' 修改Client Authentication # 修改配置文件pg_hba.conf。第一步获取 vim \u003chba_file 配置文件地址\u003e # 修改`IPv4 local connections:`行配置。允许所有用户所有IP以MD5加密方式访问。 IPv4 local connections: host all all 0.0.0.0/0 md5 重启pgsql服务 sudo systemctl restart postgresql.service ","date":"2021-04-06","objectID":"/postgre-config/:2:0","tags":["database","postgresql"],"title":"postgresql配置远程访问、账号授权","uri":"/postgre-config/"},{"categories":null,"content":"账号授权 创建新的数据库角色 create user \u003cuser_name\u003e with password '******'; 更新用户默认为只读事务 alter user \u003cuser_name\u003e set default_transaction_read_only=on; 给用户赋予所有库的USAGE权限 GRANT USAGE ON SCHEMA public to \u003cuser_name\u003e; 进入具体数据库，赋予用户该库具体表的读取权限。 \\c \u003cdatabase\u003e grant select on all tables in schema public to \u003cuser_name\u003e; ","date":"2021-04-06","objectID":"/postgre-config/:3:0","tags":["database","postgresql"],"title":"postgresql配置远程访问、账号授权","uri":"/postgre-config/"},{"categories":null,"content":"参考:postgres文档 ","date":"2021-04-06","objectID":"/postgre-config/:4:0","tags":["database","postgresql"],"title":"postgresql配置远程访问、账号授权","uri":"/postgre-config/"},{"categories":null,"content":" Hugo安装及使用 腾讯云CloudBase部署 ","date":"2021-03-30","objectID":"/hugo-blog/:0:0","tags":["hugo","CloudBase","blog"],"title":"Hugo + 腾讯云CloudBase 搭建个人博客","uri":"/hugo-blog/"},{"categories":null,"content":"前言当前有很多成熟的个人博客搭建方案。 例如动态博客WordPress，静态博客Hexo、Jekyll等。相较于Wordpress，静态博客的使用及部署成本更低，更便于迁移。 选择Hugo主要是出于好奇，因为Hugo官网给出的slogan：The world’s fastest framework for building websites 😎 ","date":"2021-03-30","objectID":"/hugo-blog/:0:1","tags":["hugo","CloudBase","blog"],"title":"Hugo + 腾讯云CloudBase 搭建个人博客","uri":"/hugo-blog/"},{"categories":null,"content":"准备工作 Hugo 安装教程 # windows 直接下载releases安装。然后设置环境变量添加hugo https://github.com/gohugoio/hugo/releases # mac。先安装homebrew 然后brew安装hugo /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" brew install hugo # linux。github releases下载安装 或 使用包管理工具 sudo apt-get install hugo sudo pacman -Sy hugo sudo dnf install hugo git 下载地址 远程仓库(本文使用GitHub) 腾讯云 云开发 CloudBase – 静态网站托管 对象存储 域名 已备案 已购买SSL证书（可以免费申请一年证书，各大云服务厂商也都会提供一键申请服务） ","date":"2021-03-30","objectID":"/hugo-blog/:0:2","tags":["hugo","CloudBase","blog"],"title":"Hugo + 腾讯云CloudBase 搭建个人博客","uri":"/hugo-blog/"},{"categories":null,"content":"Hugo搭建网站几个环节（各环节的解决方案） 框架学习 代码的版本控制及存储 服务的部署 服务器端配置 GitHub CI/CD 成本问题 ","date":"2021-03-30","objectID":"/hugo-blog/:0:3","tags":["hugo","CloudBase","blog"],"title":"Hugo + 腾讯云CloudBase 搭建个人博客","uri":"/hugo-blog/"},{"categories":null,"content":"框架学习Hugo是一种用Go语言编写的快速，现代的静态网站生成器，旨在让网站创建再次变得有趣。（照抄原文😐） 刚开始使用Hugo所以对Hugo也不熟悉，这边只会列举几条简单常用的命令，后续使用中继续深入了解Hugo🙊 创建站点 hugo new site quickstart 主题安装 Hugo官方提供了多种[主题][https://themes.gohugo.io/]。下载到站点下的themes目录下 cd quickstart git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke # 使用主题 echo theme = \\\"ananke\\\" \u003e\u003e config.toml 新建文章 hugo new posts/my-first-post.md 启动服务 hugo server -D 生成静态文件 hugo -D 该命令会在当前文件夹生成public/文件夹，包含生成的静态文件 ","date":"2021-03-30","objectID":"/hugo-blog/:0:4","tags":["hugo","CloudBase","blog"],"title":"Hugo + 腾讯云CloudBase 搭建个人博客","uri":"/hugo-blog/"},{"categories":null,"content":"代码的版本控制及存储我是使用git作为我的版本控制工具，远程仓库使用GitHub。相关使用及配置可以自行Google。 ","date":"2021-03-30","objectID":"/hugo-blog/:0:5","tags":["hugo","CloudBase","blog"],"title":"Hugo + 腾讯云CloudBase 搭建个人博客","uri":"/hugo-blog/"},{"categories":null,"content":"服务的部署1、服务器端配置最初考虑的方案是使用github的pages服务，之前的hexo也是使用的pages，但是该服务存在两个问题。 访问不通畅 经常404 然后考虑的是使用gitee的pages服务。这样最大的优势就是免费。但是我比较习惯使用github，并且考虑到响应速度和404的问题，最终决定使用云服务厂商的文件存储及CDN加速。后续可能会使用gitee做仓库备份和中转，因为github慢 之所以选用腾讯云，原因很简单：便宜，便宜，便宜👍，并且还有免费额度，免费额度，免费额度👍。对我们这种三分钟热度的简直太友好了。 最初定的方案是准备使用腾讯云COS+CDN部署服务。但是注册腾讯云的时候发现他们提供静态网站托管服务，这也太爽了。到底有多爽的呢：他们的官方文档手把手教给你 创建Hugo + GitHub托管 + 腾讯云部署 + GitHub CI/CD。我* 简直是神仙产品啊。（当然，他们提供的部分教程可能也并不完善，后续会说明 *坑1） 服务购买及开通直接访问腾讯云控制台， 注册登录一气呵成。左上角“云产品–静态网站托管”，服务开通，一把梭。然后选择按量付费开通静态托管服务。因为腾讯与会给一些免费使用额度，所以是可以放心开通的，腾讯云CloudBase免费额度。CloudBase就是腾讯云的ServerLess服务。（后面会讲 *坑2） 创建模板：选择空模板，下一步，按量付费\u0026开启免费资源，下一步，开通。 注：腾讯云静态网站托管使用的是CDN+COS部署，所以速度和稳定性是很不错的。 服务配置开通成功后，可以看到下面页面。我这边已经配置好了域名的解析。点击基础配置，添加域名。域名配置 到这里服务的配置基本完成。 2、GitHub CI/CD上面我是使用GitHub作为远程仓库，最终想要的效果是：本地push代码到远程仓库，远程仓库部署至静态资源代理服务器。（当前编译在本地，后续放在github action *坑3） 直接整活： 进入github项目页面，点击Action，然后\"Skip this and set up a workflow yourself “。github会在项目根目录下的创建.github/workflows/main.yml 我的配置文件。此处用到的secrets key等可参考腾讯云文档，或自行google github secrets key设置。 配置文件里面deploy的部署action我是基于腾讯云提供的脚本，自己改写的action脚本，这个脚本在腾讯云提供脚本基础上添加了部署时，首先删除之前的文件，不然服务端之前的文件会一直存在不会删除。 到这里。我们就实现了push代码，自动部署至腾讯云静态网站托管。 ","date":"2021-03-30","objectID":"/hugo-blog/:0:6","tags":["hugo","CloudBase","blog"],"title":"Hugo + 腾讯云CloudBase 搭建个人博客","uri":"/hugo-blog/"},{"categories":null,"content":"填坑坑1：这里说腾讯云提供的教程不完善，主要是指自动部署的配置文件。他们提供的配置文件最新的2.0版本运行时报错找不到cloudbaserc.json文件。该文件主要是为了使用tcb framework deploy命令 行41。于是我直接修改该脚本，使用CLI的方式进行部署，并在部署前添加清理历史数据问题。 注：处理该问题带来的问题，因为会删除文件，会导致10-30秒(取决于github action速度)网站404。因为是个人博客，暂时可以接受。 坑2：这里主要讲解腾讯云的免费额度及兜底方案。主要还是穷😢 因为在之前工作中做过服务的迁移，所以多云服务有一定的了解。也被LB的按量付费坑过，也看过serverless应用被攻击导致的流量暴增而造成的费用激增。因为静态网站托管使用的是按量付费，所以害怕被攻击导致的费用激增。就此问题咨询过腾讯云的技术，是否可以服务自动关闭，答案是：no。 他们技术给出方案是设置告警，然后手动关停。额度监控在“云开发 – 环境 – 安全配置 – 额度监控” 这里就涉及到阈值的问题。文章前面讲到过腾讯云的免费额度。 腾讯云CloudBase按量计费免费额度规则：DOC 每月更新免费用量 云存储 容量 5G/月 下载次数 2000/月 上传次数 1000/月 CDN回溯流量 1G/月 CDN 流量 1G/月 云函数 资源使用量 1000GBs/月 数据库 读次数 500/天 写次数 300/天 一次性免费用量 静态网站托管 流量 5G/月 按照上面的限制，把资源限额平分到每天，然后设置监控告警，这样就能实现0费用。 第二个月开始，静态网站托管流量不再赠送，网站托管流量是0.21元/GB。所以服务部署运行近乎0成本。 坑3：关于hugo编译的问题。当前编译是放在本地生成静态文件，然后push到github。后续会继续完善action，把项目的编译也自动完成，实现完整的CI/CD。 ","date":"2021-03-30","objectID":"/hugo-blog/:0:7","tags":["hugo","CloudBase","blog"],"title":"Hugo + 腾讯云CloudBase 搭建个人博客","uri":"/hugo-blog/"},{"categories":null,"content":"nothing ","date":"2021-03-30","objectID":"/about/about/:0:0","tags":null,"title":"About","uri":"/about/about/"}]