<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1"><meta name="robots" content="noodp"/><title>Redis设计与实现 | </title><meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content=""/>
<meta name="twitter:title" content="Redis设计与实现"/>
<meta name="twitter:description" content=""/><meta name="Description" content="cuiks&#39;s Note"><meta property="og:title" content="Redis设计与实现" />
<meta property="og:description" content="
内部数据结构
内存映射数据结构
Redis数据类型
功能的实现
内部运作机制
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cuiks.top/redis_design_and_implement/" />
<meta property="og:image" content="https://cuiks.top/logo.png"/>
<meta property="article:published_time" content="2021-07-14T17:40:56+08:00" />
<meta property="article:modified_time" content="2021-07-14T17:40:56+08:00" />
<meta name="application-name" content="Note Site">
<meta name="apple-mobile-web-app-title" content="Note Site"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://cuiks.top/redis_design_and_implement/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/lib/prismjs/prism.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Redis设计与实现",
        "inLanguage": "en",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/cuiks.top\/redis_design_and_implement\/"
        },"genre": "posts","keywords": "redis, 读书笔记","wordCount":  1916 ,
        "url": "https:\/\/cuiks.top\/redis_design_and_implement\/","datePublished": "2021-07-14T17:40:56+08:00","dateModified": "2021-07-14T17:40:56+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script>(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header>
    <div class="desktop header" id="header-desktop">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Note Site" class="header-logo logo-svg"><span class="header-title-pre"><i class='fas fa-pencil-alt fa-fw'></i></span>Note Site</a>
            </div>
            <div class="menu">
                <nav>
                    <h2 class="display-hidden">Основная навигация</h2>
                    <ul class="menu-inner"><li>
                            <a class="menu-item" href="/posts/"> Posts </a>
                        </li><li>
                            <a class="menu-item" href="/tags/"> Tags </a>
                        </li><li>
                            <a class="menu-item" href="/about/about"> About </a>
                        </li><li>
                            <a class="menu-item" href="https://github.com/cuiks" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a>
                        </li></ul>
                </nav><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <span class="svg-icon icon-search"></span>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <span class="svg-icon icon-cancel"></span>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <span class="svg-icon icon-loading"></span>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <span class="svg-icon icon-moon"></span>
                </a>
            </div>
        </div>
    </div><div class="mobile header" id="header-mobile">
        <div class="header-container">
            <div class="header-wrapper">
                <div class="header-title">
                    <a href="/" title="Note Site" class="header-logo"><span class="header-title-pre"><i class='fas fa-pencil-alt fa-fw'></i></span>Note Site</a>
                </div>
                <div class="menu-toggle" id="menu-toggle-mobile">
                    <span></span><span></span><span></span>
                </div>
            </div>
            <div class="menu" id="menu-mobile"><div class="search-wrapper">
                        <div class="search mobile" id="search-mobile">
                            <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                            <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                                <span class="svg-icon icon-search"></span>
                            </a>
                            <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                                <span class="svg-icon icon-cancel"></span>
                            </a>
                            <span class="search-button search-loading" id="search-loading-mobile">
                                <span class="svg-icon icon-loading"></span>
                            </span>
                        </div>
                        <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                            Cancel
                        </a>
                    </div><nav>
                    <h2 class="display-hidden">Основная навигация</h2>
                    <ul><li>
                            <a class="menu-item" href="/posts/" title="">Posts</a>
                        </li><li>
                            <a class="menu-item" href="/tags/" title="">Tags</a>
                        </li><li>
                            <a class="menu-item" href="/about/about" title="">About</a>
                        </li><li>
                            <a class="menu-item" href="https://github.com/cuiks" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a>
                        </li></ul>
                </nav>
                <a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <span class="svg-icon icon-moon"></span>
                </a></div>
        </div>
    </div><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div></header><main class="main">
<div class="container content-article page-toc theme-classic"><div class="toc" id="toc-auto">
            <div class="toc-title">Contents</div>
            <div class="toc-content" id="toc-content-auto"></div>
        </div>

    
    
    <article>
    

        <header class="header-post">

            

            
            <div class="post-title">

                    <div class="post-all-meta">
                        <nav class="breadcrumbs">
    <ol>
        <li><a href="/">Home </a></li><li>Redis设计与实现</li>
    </ol>
</nav>
                        <h1 class="single-title flipInX">Redis设计与实现</h1><div class="post-meta summary-post-meta"><span class="post-meta-date meta-item">
                                <span class="svg-icon icon-clock"></span><time class="timeago" datetime="2021-07-14">2021-07-14</time>
                            </span><span class="post-meta-words meta-item">
                                <span class="svg-icon icon-pencil"></span>1916 words
                            </span>
                            <span class="post-meta-reading meta-item">
                                <span class="svg-icon icon-stopwatch"></span>9 minutes
                            </span>
                        </div>

                    </div>

                </div>

                </header>

        <div class="article-post toc-start">

            <div class="content-block content-block-first content-block-position">

                <div class="post single"><div class="details toc" id="toc-static"  data-kept="">
                        <div class="details-summary toc-title">
                            <span>Contents</span>
                        </div>
                        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1内部数据结构">1、内部数据结构</a>
          <ul>
            <li><a href="#11-简单动态字符串">1.1 简单动态字符串</a>
              <ul>
                <li><a href="#111-sds的用途">1.1.1 sds的用途</a></li>
                <li><a href="#112-redis中的字符串">1.1.2 Redis中的字符串</a></li>
                <li><a href="#113-优化追加操作">1.1.3 优化追加操作</a></li>
                <li><a href="#114-sds模块的api">1.1.4 sds模块的API</a></li>
                <li><a href="#115小结">1.1.5小结</a></li>
              </ul>
            </li>
            <li><a href="#12-双端链表">1.2 双端链表</a>
              <ul>
                <li><a href="#121-双端链表的应用">1.2.1 双端链表的应用</a></li>
                <li><a href="#122-双端链表的实现">1.2.2 双端链表的实现</a></li>
                <li><a href="#123-迭代器">1.2.3 迭代器</a></li>
                <li><a href="#124-小结">1.2.4 小结</a></li>
              </ul>
            </li>
            <li><a href="#13-字典">1.3 字典</a>
              <ul>
                <li><a href="#131-字典的应用">1.3.1 字典的应用</a></li>
                <li><a href="#132-字典的实现">1.3.2 字典的实现</a></li>
                <li><a href="#133-创建新字典">1.3.3 创建新字典</a></li>
                <li><a href="#134-添加键值对到字典">1.3.4 添加键值对到字典</a></li>
                <li><a href="#135-添加新元素到空白字典">1.3.5 添加新元素到空白字典</a></li>
                <li><a href="#136-添加新键值对时发生碰撞处理">1.3.6 添加新键值对时发生碰撞处理</a></li>
                <li><a href="#137-添加新键值对时触发了rehash操作">1.3.7 添加新键值对时触发了rehash操作</a></li>
                <li><a href="#138-rehash执行过程">1.3.8 rehash执行过程</a></li>
                <li><a href="#139-渐进式rehash">1.3.9 渐进式rehash</a></li>
                <li><a href="#1310-字典的收缩">1.3.10 字典的收缩</a></li>
                <li><a href="#1311-字典其他操作">1.3.11 字典其他操作</a></li>
                <li><a href="#1312-字典的迭代">1.3.12 字典的迭代</a></li>
                <li><a href="#1313-小结">1.3.13 小结</a></li>
              </ul>
            </li>
            <li><a href="#14-跳跃表">1.4 跳跃表</a>
              <ul>
                <li><a href="#141-跳跃表的实现">1.4.1 跳跃表的实现</a></li>
                <li><a href="#142-跳跃表的应用">1.4.2 跳跃表的应用</a></li>
                <li><a href="#143-小结">1.4.3 小结</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#2内存映射数据结构">2、内存映射数据结构</a>
          <ul>
            <li><a href="#21-整数集合">2.1 整数集合</a>
              <ul>
                <li><a href="#211-整数集合的应用">2.1.1 整数集合的应用</a></li>
                <li><a href="#222-数据结构和主要操作">2.2.2 数据结构和主要操作</a></li>
                <li><a href="#213-intset-运行实例">2.1.3 intset 运行实例</a></li>
                <li><a href="#214-升级">2.1.4 升级</a></li>
                <li><a href="#215-关于升级">2.1.5 关于升级</a></li>
                <li><a href="#216-关于元素移动">2.1.6 关于元素移动</a></li>
                <li><a href="#217-其他操作">2.1.7 其他操作</a></li>
                <li><a href="#218-小结">2.1.8 小结</a></li>
              </ul>
            </li>
            <li><a href="#22-压缩列表">2.2 压缩列表</a>
              <ul>
                <li><a href="#221-ziplist的构成">2.2.1 ziplist的构成</a></li>
                <li><a href="#222-节点的构成">2.2.2 节点的构成</a></li>
                <li><a href="#223-创建新-ziplist">2.2.3 创建新 ziplist</a></li>
                <li><a href="#224-将节点添加到末端">2.2.4 将节点添加到末端</a></li>
                <li><a href="#225-将节点添加到某个某些节点的前面">2.2.5 将节点添加到某个/某些节点的前面</a></li>
                <li><a href="#226-删除节点">2.2.6 删除节点</a></li>
                <li><a href="#227-遍历">2.2.7 遍历</a></li>
                <li><a href="#228-查找元素根据值定位节点">2.2.8 查找元素，根据值定位节点</a></li>
                <li><a href="#229-小结">2.2.9 小结</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#3redis数据类型">3、Redis数据类型</a>
          <ul>
            <li><a href="#31-对象处理机制">3.1 对象处理机制</a>
              <ul>
                <li><a href="#311-redisobject数据结构以及redis的数据类型">3.1.1 redisObject数据结构，以及Redis的数据类型</a></li>
                <li><a href="#312-命令的类型检查和多态">3.1.2 命令的类型检查和多态</a></li>
                <li><a href="#313-对象共享">3.1.3 对象共享</a></li>
                <li><a href="#314-引用计数以及对象的销毁">3.1.4 引用计数以及对象的销毁</a></li>
                <li><a href="#315-小结">3.1.5 小结</a></li>
              </ul>
            </li>
            <li><a href="#32-字符串">3.2 字符串</a>
              <ul>
                <li><a href="#321-字符串编码">3.2.1 字符串编码</a></li>
                <li><a href="#322-编码的选择">3.2.2 编码的选择</a></li>
                <li><a href="#323-字符串命令的实现">3.2.3 字符串命令的实现</a></li>
              </ul>
            </li>
            <li><a href="#33-哈希表">3.3 哈希表</a>
              <ul>
                <li><a href="#331-字典编码的哈希表">3.3.1 字典编码的哈希表</a></li>
                <li><a href="#332-压缩列表编码的哈希表">3.3.2 压缩列表编码的哈希表</a></li>
                <li><a href="#333-编码的选择">3.3.3 编码的选择</a></li>
                <li><a href="#334-哈希命令的实现">3.3.4 哈希命令的实现</a></li>
              </ul>
            </li>
            <li><a href="#34-列表">3.4 列表</a>
              <ul>
                <li><a href="#341-编码的选择">3.4.1 编码的选择</a></li>
                <li><a href="#342-列表命令的实现">3.4.2 列表命令的实现</a></li>
                <li><a href="#343-阻塞的条件">3.4.3 阻塞的条件</a></li>
                <li><a href="#344-阻塞">3.4.4 阻塞</a></li>
                <li><a href="#345-阻塞因lpushrpushlinsert等添加命令而被取消">3.4.5 阻塞因LPUSH、RPUSH、LINSERT等添加命令而被取消</a></li>
                <li><a href="#346-先阻塞先服务fbfs策略">3.4.6 先阻塞先服务（FBFS）策略</a></li>
                <li><a href="#347-阻塞因超过最大等待时间而被取消">3.4.7 阻塞因超过最大等待时间而被取消</a></li>
              </ul>
            </li>
            <li><a href="#35-集合">3.5 集合</a>
              <ul>
                <li><a href="#351-编码的选择">3.5.1 编码的选择</a></li>
                <li><a href="#352-编码的切换">3.5.2 编码的切换</a></li>
                <li><a href="#353-字典编码的集合">3.5.3 字典编码的集合</a></li>
                <li><a href="#354-集合命令的实现">3.5.4 集合命令的实现</a></li>
                <li><a href="#355-求交集算法">3.5.5 求交集算法</a></li>
                <li><a href="#356-求并集算法">3.5.6 求并集算法</a></li>
                <li><a href="#357-求差集算法">3.5.7 求差集算法</a></li>
              </ul>
            </li>
            <li><a href="#36-有序集">3.6 有序集</a>
              <ul>
                <li><a href="#361-编码的选择">3.6.1 编码的选择</a></li>
                <li><a href="#362-编码的转换">3.6.2 编码的转换</a></li>
                <li><a href="#363-ziplist编码的有序集">3.6.3 ZIPLIST编码的有序集</a></li>
                <li><a href="#364-skiplist编码的有序集">3.6.4 SKIPLIST编码的有序集</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#4功能的实现">4、功能的实现</a>
          <ul>
            <li><a href="#41-事务">4.1 事务</a>
              <ul>
                <li><a href="#411-事务">4.1.1 事务</a></li>
                <li><a href="#412-开始事务">4.1.2 开始事务</a></li>
                <li><a href="#413-命令入队">4.1.3 命令入队</a></li>
                <li><a href="#414-执行事务">4.1.4 执行事务</a></li>
                <li><a href="#415-在事务和非事务状态下执行命令">4.1.5 在事务和非事务状态下执行命令</a></li>
                <li><a href="#416-事务状态下的discardmultiwatch">4.1.6 事务状态下的DISCARD、MULTI、WATCH</a></li>
                <li><a href="#417-带watch的事务">4.1.7 带WATCH的事务</a></li>
                <li><a href="#418-watch命令的实现">4.1.8 WATCH命令的实现</a></li>
                <li><a href="#419-watch的触发">4.1.9 WATCH的触发</a></li>
                <li><a href="#4110-事务的acid性质">4.1.10 事务的ACID性质</a></li>
                <li><a href="#4111-小结">4.1.11 小结</a></li>
              </ul>
            </li>
            <li><a href="#42-订阅与发布">4.2 订阅与发布</a>
              <ul>
                <li><a href="#421-频道的订阅与信息发送">4.2.1 频道的订阅与信息发送</a></li>
                <li><a href="#422-订阅频道">4.2.2 订阅频道</a></li>
                <li><a href="#423-发送信息到频道">4.2.3 发送信息到频道</a></li>
                <li><a href="#424-退订频道">4.2.4 退订频道</a></li>
                <li><a href="#425-模式的订阅与信息发送">4.2.5 模式的订阅与信息发送</a></li>
                <li><a href="#426-订阅模式">4.2.6 订阅模式</a></li>
                <li><a href="#427-发送信息到模式">4.2.7 发送信息到模式</a></li>
                <li><a href="#428-退订模式">4.2.8 退订模式</a></li>
                <li><a href="#429-小结">4.2.9 小结</a></li>
              </ul>
            </li>
            <li><a href="#43-lua脚本">4.3 Lua脚本</a>
              <ul>
                <li><a href="#431-初始化lua环境">4.3.1 初始化Lua环境</a></li>
                <li><a href="#432-脚本的安全性">4.3.2 脚本的安全性</a></li>
                <li><a href="#433-脚本的执行">4.3.3 脚本的执行</a></li>
                <li><a href="#434-eval命令的实现">4.3.4 EVAL命令的实现</a></li>
                <li><a href="#435-evalsha命令的实现">4.3.5 EVALSHA命令的实现</a></li>
                <li><a href="#436-小结">4.3.6 小结</a></li>
              </ul>
            </li>
            <li><a href="#44-慢查询日志">4.4 慢查询日志</a>
              <ul>
                <li><a href="#441-相关数据结构">4.4.1 相关数据结构</a></li>
                <li><a href="#442-慢查询日志的记录">4.4.2 慢查询日志的记录</a></li>
                <li><a href="#443-慢查询日志的操作">4.4.3 慢查询日志的操作</a></li>
                <li><a href="#444-小结">4.4.4 小结</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#5内部运作机制">5、内部运作机制</a>
          <ul>
            <li><a href="#51-数据库">5.1 数据库</a>
              <ul>
                <li><a href="#511-数据库的结构">5.1.1 数据库的结构</a></li>
                <li><a href="#512-数据库的切换">5.1.2 数据库的切换</a></li>
                <li><a href="#513-数据库键空间">5.1.3 数据库键空间</a></li>
                <li><a href="#514-键空间的操作">5.1.4 键空间的操作</a></li>
                <li><a href="#515-键的过期时间">5.1.5 键的过期时间</a></li>
                <li><a href="#516-过期时间的保存">5.1.6 过期时间的保存</a></li>
                <li><a href="#517-设置生存时间">5.1.7 设置生存时间</a></li>
                <li><a href="#518-过期键的判定">5.1.8 过期键的判定</a></li>
                <li><a href="#519-过期键的清除">5.1.9 过期键的清除</a></li>
                <li><a href="#5110-过期键的惰性删除策略">5.1.10 过期键的惰性删除策略</a></li>
                <li><a href="#5111-过期键的定期删除策略">5.1.11 过期键的定期删除策略</a></li>
                <li><a href="#5112-过期键对aofrdb和复制的影响">5.1.12 过期键对AOF、RDB和复制的影响</a></li>
                <li><a href="#5113-数据库空间的收缩和扩展">5.1.13 数据库空间的收缩和扩展</a></li>
                <li><a href="#5114-小结">5.1.14 小结</a></li>
              </ul>
            </li>
            <li><a href="#52-rdb">5.2 RDB</a>
              <ul>
                <li><a href="#521-保存">5.2.1 保存</a></li>
                <li><a href="#522-savebgsaveaof写入bgrewritefof">5.2.2 SAVE、BGSAVE、AOF写入、BGREWRITEFOF</a></li>
                <li><a href="#523-载入">5.2.3 载入</a></li>
                <li><a href="#524-rdb文件结构">5.2.4 RDB文件结构</a></li>
                <li><a href="#525-小结">5.2.5 小结</a></li>
              </ul>
            </li>
            <li><a href="#53-aof">5.3 AOF</a>
              <ul>
                <li><a href="#531--aof命令同步">5.3.1  AOF命令同步</a></li>
                <li><a href="#532-命令传播">5.3.2 命令传播</a></li>
                <li><a href="#533-缓存追加">5.3.3 缓存追加</a></li>
                <li><a href="#534-文件写入和保存">5.3.4 文件写入和保存</a></li>
                <li><a href="#535-aof保存模式">5.3.5 AOF保存模式</a></li>
                <li><a href="#536-aof保存模式对性能和安全的影响">5.3.6 AOF保存模式对性能和安全的影响</a></li>
                <li><a href="#537-aof文件的读取和数据还原">5.3.7 AOF文件的读取和数据还原</a></li>
                <li><a href="#538-aof重写">5.3.8 AOF重写</a></li>
                <li><a href="#539-aof重写的实现">5.3.9 AOF重写的实现</a></li>
                <li><a href="#5310-aof后台重写">5.3.10 AOF后台重写</a></li>
                <li><a href="#5311-aof后台重写的出发条件">5.3.11 AOF后台重写的出发条件</a></li>
                <li><a href="#5312-小结">5.3.12 小结</a></li>
              </ul>
            </li>
            <li><a href="#54-事件">5.4 事件</a>
              <ul>
                <li><a href="#541-文件事件">5.4.1 文件事件</a></li>
                <li><a href="#542-时间事件">5.4.2 时间事件</a></li>
                <li><a href="#543-时间事件应用实例服务器常规操作">5.4.3 时间事件应用实例：服务器常规操作</a></li>
                <li><a href="#544-事件的执行与调度">5.4.4 事件的执行与调度</a></li>
                <li><a href="#545-小结">5.4.5 小结</a></li>
              </ul>
            </li>
            <li><a href="#55-服务器与客户端">5.5 服务器与客户端</a>
              <ul>
                <li><a href="#551-初始化服务器">5.5.1 初始化服务器</a></li>
                <li><a href="#552-客户端连接到服务器">5.5.2 客户端连接到服务器</a></li>
                <li><a href="#553-命令的请求处理和结果返回">5.5.3 命令的请求、处理和结果返回</a></li>
                <li><a href="#554-命令请求实例set的执行过程">5.5.4 命令请求实例：SET的执行过程</a></li>
                <li><a href="#555-小结">5.5.5 小结</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
                    </div><ul>
<li>内部数据结构</li>
<li>内存映射数据结构</li>
<li>Redis数据类型</li>
<li>功能的实现</li>
<li>内部运作机制</li>
</ul>
<h3 id="1内部数据结构" class="headerLink"><a href="#1%e5%86%85%e9%83%a8%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="header-mark"></a>1、内部数据结构</h3><h4 id="11-简单动态字符串" class="headerLink"><a href="#11-%e7%ae%80%e5%8d%95%e5%8a%a8%e6%80%81%e5%ad%97%e7%ac%a6%e4%b8%b2" class="header-mark"></a>1.1 简单动态字符串</h4><h5 id="111-sds的用途" class="headerLink"><a href="#111-sds%e7%9a%84%e7%94%a8%e9%80%94" class="header-mark"></a>1.1.1 sds的用途</h5><ul>
<li><code>sds</code>（<code>Simple Dynamic String</code>）简单动态字符串
<ul>
<li>Redis底层所使用的的字符串表示</li>
</ul>
</li>
<li>用途
<ul>
<li>实现字符串对象</li>
<li>用作<code>char*</code>类型替代品</li>
</ul>
</li>
</ul>
<h5 id="112-redis中的字符串" class="headerLink"><a href="#112-redis%e4%b8%ad%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2" class="header-mark"></a>1.1.2 Redis中的字符串</h5><ul>
<li>
<p><code>sds</code>的实现</p>
<ul>
<li>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#204a87;font-weight:bold">char</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">sds</span>
      
 <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">sdshdr</span> <span style="color:#000;font-weight:bold">{</span>
   <span style="color:#204a87;font-weight:bold">int</span> <span style="color:#000">len</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// buf已占用长度
</span><span style="color:#8f5902;font-style:italic"></span>   <span style="color:#204a87;font-weight:bold">int</span> <span style="color:#000">free</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// bug剩余可用长度
</span><span style="color:#8f5902;font-style:italic"></span>   <span style="color:#204a87;font-weight:bold">char</span> <span style="color:#000">buf</span><span style="color:#000;font-weight:bold">[];</span> <span style="color:#8f5902;font-style:italic">//实际保存字符串数据的地方
</span><span style="color:#8f5902;font-style:italic"></span> <span style="color:#000;font-weight:bold">}</span>
</code></pre></div></li>
</ul>
</li>
</ul>
<h5 id="113-优化追加操作" class="headerLink"><a href="#113-%e4%bc%98%e5%8c%96%e8%bf%bd%e5%8a%a0%e6%93%8d%e4%bd%9c" class="header-mark"></a>1.1.3 优化追加操作</h5><ul>
<li>如果free空间足够，无须再分配空间。如果不够计算新字符串的总长度。</li>
<li>如果追加字符串小于<code>1M</code>，分配多余所需空间一倍(新字符串长度1倍)的空间。否则，额外多分配<code>1MB</code>。</li>
</ul>
<h5 id="114-sds模块的api" class="headerLink"><a href="#114-sds%e6%a8%a1%e5%9d%97%e7%9a%84api" class="header-mark"></a>1.1.4 sds模块的API</h5><p>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708163819.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708163819.png"
         title="20210708163819.png"
    /></p>
<h5 id="115小结" class="headerLink"><a href="#115%e5%b0%8f%e7%bb%93" class="header-mark"></a>1.1.5小结</h5><ul>
<li>Redis的字符串表示为<code>sds</code>，而不是C字符串（以\0结尾的char*）</li>
<li>对比C字符串，<code>sds</code>有以下特性
<ul>
<li>可以高效计算长度</li>
<li>可以高效执行追加操作</li>
<li>二进制安全</li>
</ul>
</li>
<li><code>sds</code>为追加操作进行优化：加快追加操作速度，并降低内存分配的次数。代价是多占用内存，并且这些内存不会被主动释放</li>
</ul>
<h4 id="12-双端链表" class="headerLink"><a href="#12-%e5%8f%8c%e7%ab%af%e9%93%be%e8%a1%a8" class="header-mark"></a>1.2 双端链表</h4><h5 id="121-双端链表的应用" class="headerLink"><a href="#121-%e5%8f%8c%e7%ab%af%e9%93%be%e8%a1%a8%e7%9a%84%e5%ba%94%e7%94%a8" class="header-mark"></a>1.2.1 双端链表的应用</h5><ul>
<li>实现Redis的列表类型
<ul>
<li>Redis列表使用两种数据结构作为底层实现
<ul>
<li>双端链表</li>
<li>压缩列表</li>
<li>创建新的列表键时，优先考虑使用压缩列表，在有需要的时候在转换为双端链表</li>
</ul>
</li>
</ul>
</li>
<li>Redis自身功能的构建
<ul>
<li>事务模块保存命令</li>
<li>服务器模块保存多个客户端</li>
<li>订阅/发送模块保存订阅模式的多个客户端</li>
<li>事件模块保存时间事件</li>
<li>。。。</li>
</ul>
</li>
</ul>
<h5 id="122-双端链表的实现" class="headerLink"><a href="#122-%e5%8f%8c%e7%ab%af%e9%93%be%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>1.2.2 双端链表的实现</h5><p>双端链表的实现由<code>listNode</code>和<code>list</code>两个数据结构构成</p>
<p>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708160613.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708160613.png"
         title="20210708160613.png"
    /></p>
<ul>
<li>
<p>listNode是双端链表的节点</p>
<ul>
<li>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">listNode</span><span style="color:#000;font-weight:bold">{</span>
  <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">listNode</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">prev</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 前驱结点
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">listNode</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">next</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 后继节点
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">value</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 值
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">}</span> <span style="color:#000">listNode</span><span style="color:#000;font-weight:bold">;</span>
</code></pre></div></li>
<li>
<p><code>value</code>的属性是<code>void *</code>，说明对保存的值的类型不做限制</p>
</li>
<li></li>
</ul>
</li>
<li>
<p>list是双端链表本身</p>
<ul>
<li>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">list</span><span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000">listNode</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">head</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">//表头指针
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">listNode</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">tail</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">//表尾指针
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">unsigned</span> <span style="color:#204a87;font-weight:bold">long</span> <span style="color:#000">len</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 节点数量
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000;font-weight:bold">(</span><span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">dup</span><span style="color:#000;font-weight:bold">)(</span><span style="color:#204a87;font-weight:bold">void</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">ptr</span><span style="color:#000;font-weight:bold">);</span> <span style="color:#8f5902;font-style:italic">// 复制函数
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">free</span><span style="color:#000;font-weight:bold">)(</span><span style="color:#204a87;font-weight:bold">void</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">ptr</span><span style="color:#000;font-weight:bold">);</span> <span style="color:#8f5902;font-style:italic">// 释放函数
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">match</span><span style="color:#000;font-weight:bold">)(</span><span style="color:#204a87;font-weight:bold">void</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">ptr</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">key</span><span style="color:#000;font-weight:bold">);</span> <span style="color:#8f5902;font-style:italic">// 比对函数
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">}</span> <span style="color:#000">list</span><span style="color:#000;font-weight:bold">;</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>双端链表API</p>
<ul>
<li>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708163837.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708163837.png"
         title="20210708163837.png"
    /></li>
</ul>
</li>
</ul>
<h5 id="123-迭代器" class="headerLink"><a href="#123-%e8%bf%ad%e4%bb%a3%e5%99%a8" class="header-mark"></a>1.2.3 迭代器</h5><p>Redis为双端链表实现了一个迭代器，可以从两个方向进行迭代</p>
<ul>
<li>沿着next指针从表头向表尾</li>
<li>沿着prev指针从表尾向表头</li>
</ul>
<p>结构定义：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">listIter</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000">listNode</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">next</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">//下一节点
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">int</span> <span style="color:#000">direction</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 迭代方向
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">}</span> <span style="color:#000">listIter</span><span style="color:#000;font-weight:bold">;</span>
</code></pre></div><ul>
<li>direction选项
<ul>
<li><code>adlist.h/AL_START_HEAD</code>  从表头到表尾</li>
<li><code>adlist.h/AL_START_TAIL</code>  从表尾到表头</li>
</ul>
</li>
<li>迭代器API
<ul>
<li>![image-20210708163935798](/Users/cks/Library/Application Support/typora-user-images/image-20210708163935798.png)</li>
</ul>
</li>
</ul>
<h5 id="124-小结" class="headerLink"><a href="#124-%e5%b0%8f%e7%bb%93" class="header-mark"></a>1.2.4 小结</h5><ul>
<li>Redis实现了自己的双端链表</li>
<li>双端链表的主要作用
<ul>
<li>列表类型的底层实现之一</li>
<li>作为通用数据结构，被其他功能模块使用</li>
</ul>
</li>
<li>双端链表及其节点的性能特性
<ul>
<li>访问前驱结点和后继节点复杂度都是O(1)，并且对链表的迭代可以从表头和表尾两个方式开始</li>
<li>对表头和表尾处理的复杂度为O(1)</li>
<li>计算链表长度复杂度O(1)</li>
</ul>
</li>
</ul>
<h4 id="13-字典" class="headerLink"><a href="#13-%e5%ad%97%e5%85%b8" class="header-mark"></a>1.3 字典</h4><h5 id="131-字典的应用" class="headerLink"><a href="#131-%e5%ad%97%e5%85%b8%e7%9a%84%e5%ba%94%e7%94%a8" class="header-mark"></a>1.3.1 字典的应用</h5><p>字典应用广泛</p>
<ul>
<li>实现数据库键空间
<ul>
<li>数据库中键值对由字典保存，每个数据库都有一个与之相对的字典，成为键空间</li>
</ul>
</li>
<li>用作Hash类型键的一种底层实现
<ul>
<li>Redis的Hash类型键使用两种数据结构作为底层实现
<ul>
<li>字典</li>
<li>压缩列表</li>
<li>创建新的<code>Hash</code>键时,默认使用压缩列表作为底层实现，有需要再转换字典</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="132-字典的实现" class="headerLink"><a href="#132-%e5%ad%97%e5%85%b8%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>1.3.2 字典的实现</h5><p>实现方法有多种：</p>
<ul>
<li>最简单，使用链表或数组，但是只适用于元素个数不多的情况</li>
<li>兼顾高效和简单，使用哈希表</li>
<li>最求稳定性并且希望高效地实现排序，可以使用平衡树</li>
</ul>
<p>Redis选择了高效且简繁的哈希表作为字典的底层实现。</p>
<ul>
<li>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">dict</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000">dictType</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">type</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 特定于类型的处理函数
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">privdata</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 类型处理函数的私有数据
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">dictht</span> <span style="color:#000">ht</span><span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">2</span><span style="color:#000;font-weight:bold">];</span> <span style="color:#8f5902;font-style:italic">// 哈希表(2个)
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">int</span> <span style="color:#000">rehashidx</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 记录rehash进度的标志，值为-1表示rehash未进行
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">int</span> <span style="color:#000">iterators</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 当前正在运作的安全迭代器数量
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">}</span> <span style="color:#000">dict</span><span style="color:#000;font-weight:bold">;</span>
</code></pre></div></li>
<li>
<p>dict的API</p>
<ul>
<li>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708164006.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708164006.png"
         title="20210708164006.png"
    /></li>
</ul>
</li>
</ul>
<p>哈希表的实现</p>
<ul>
<li>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8f5902;font-style:italic">// dict.h/dicht
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">dictht</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000">dictEntry</span> <span style="color:#ce5c00;font-weight:bold">**</span><span style="color:#000">table</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 哈希表节点指针数组（俗称桶，bucket）
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">unsigned</span> <span style="color:#204a87;font-weight:bold">long</span> <span style="color:#000">size</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 指针数组的大小
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">unsigned</span> <span style="color:#204a87;font-weight:bold">long</span> <span style="color:#000">sizemask</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 指针数组的长度掩码，用于计算索引值
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">unsigned</span> <span style="color:#204a87;font-weight:bold">long</span> <span style="color:#000">used</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 哈希表现有的节点数量
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">}</span> <span style="color:#000">dictht</span><span style="color:#000;font-weight:bold">;</span>
</code></pre></div></li>
<li>
<p><code>table</code>属性是一个数组，数组每个元素都是一个指向<code>dictEntry</code>结构的指针。</p>
</li>
<li>
<p>每个<code>dictEntry</code>都保存着一个键值对，以及一个指向另一个<code>dictEntry</code>结构的指针：</p>
</li>
<li>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">dictEntry</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">key</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 键
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">union</span> <span style="color:#000;font-weight:bold">{</span>
    <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">val</span><span style="color:#000;font-weight:bold">;</span>
    <span style="color:#000">uint64_t</span> <span style="color:#000">u64</span><span style="color:#000;font-weight:bold">;</span>
    <span style="color:#000">int64_t</span> <span style="color:#000">s64</span><span style="color:#000;font-weight:bold">;</span>
  <span style="color:#000;font-weight:bold">}</span> <span style="color:#000">v</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 值
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">dictEntry</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">next</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 链往后继节点
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">}</span>
</code></pre></div></li>
</ul>
<p>整个字典结构：</p>
<ul>
<li>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708164900.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708164900.png"
         title="20210708164900.png"
    /></li>
</ul>
<p>哈希算法</p>
<ul>
<li>
<p>Redis使用两种不同的哈希算法</p>
<ul>
<li><code>MurmurHash2 32 bit 算法</code> <a href="https://github.com/aappleby/smhasher" target="_blank" rel="noopener noreffer">https://github.com/aappleby/smhasher</a></li>
<li>基于djb算法实现的一个大小写无关散列算法 <a href="http://www.cse.yorku.ca/~oz/hash.html" target="_blank" rel="noopener noreffer">http://www.cse.yorku.ca/~oz/hash.html</a></li>
</ul>
</li>
<li>
<p>使用哪种算法取决于具体应用所处理的数据：</p>
<ul>
<li>命令表以及Lua脚本缓存使用算法2</li>
<li>数据库、集群、哈希键、阻塞操作等功能使用算法1</li>
</ul>
</li>
</ul>
<h5 id="133-创建新字典" class="headerLink"><a href="#133-%e5%88%9b%e5%bb%ba%e6%96%b0%e5%ad%97%e5%85%b8" class="header-mark"></a>1.3.3 创建新字典</h5><p><code>dict *d = dictCreate(&amp;hash_type, NULL)</code></p>
<h5 id="134-添加键值对到字典" class="headerLink"><a href="#134-%e6%b7%bb%e5%8a%a0%e9%94%ae%e5%80%bc%e5%af%b9%e5%88%b0%e5%ad%97%e5%85%b8" class="header-mark"></a>1.3.4 添加键值对到字典</h5><p>添加流程：</p>
<ul>
<li>如果字典未初始化(即字典的0号哈希表的table属性为空)，那么程序需要对0号哈希表进行初始化</li>
<li>如果在插入时发生了键碰撞，那么程序需要处理碰撞</li>
<li>如果插入新元素使得字典满足<code>rehash</code>条件，那么需要启动响应的<code>rehash</code>程序</li>
</ul>
<h5 id="135-添加新元素到空白字典" class="headerLink"><a href="#135-%e6%b7%bb%e5%8a%a0%e6%96%b0%e5%85%83%e7%b4%a0%e5%88%b0%e7%a9%ba%e7%99%bd%e5%ad%97%e5%85%b8" class="header-mark"></a>1.3.5 添加新元素到空白字典</h5><p>当第一次往空字典里添加键值对时，程序会根据<code>dict.h/DICT_HT_INITIAL_SIZE</code>里指定的大小为<code>d-&gt;ht[0]-&gt;table</code>分配空间（目前为值4）。</p>
<h5 id="136-添加新键值对时发生碰撞处理" class="headerLink"><a href="#136-%e6%b7%bb%e5%8a%a0%e6%96%b0%e9%94%ae%e5%80%bc%e5%af%b9%e6%97%b6%e5%8f%91%e7%94%9f%e7%a2%b0%e6%92%9e%e5%a4%84%e7%90%86" class="header-mark"></a>1.3.6 添加新键值对时发生碰撞处理</h5><p>使用<code>链地址法</code>，将新的键值对链接到存在的键值对上。</p>
<h5 id="137-添加新键值对时触发了rehash操作" class="headerLink"><a href="#137-%e6%b7%bb%e5%8a%a0%e6%96%b0%e9%94%ae%e5%80%bc%e5%af%b9%e6%97%b6%e8%a7%a6%e5%8f%91%e4%ba%86rehash%e6%93%8d%e4%bd%9c" class="header-mark"></a>1.3.7 添加新键值对时触发了rehash操作</h5><ul>
<li>
<p>对于使用<code>链地址法</code>来解决碰撞问题的哈希表，性能依赖于它的大小(size属性)和它所保存的节点的数量(used属性)之间的比率：</p>
<ul>
<li>比率1:1，哈希表性能最好</li>
<li>如果节点数量比哈希表大小要大很多，哈希表就会退化成多个链表，性能优势不再存在</li>
</ul>
</li>
<li>
<p>为了保证性能，字典需要对所使用的的哈希表(ht[0])进行<code>rehash</code>操作：在不修改任何键值对的情况下，对哈希表进行扩容，尽量将比率维持在1:1左右。</p>
</li>
<li>
<p>每次向字典添加新键值对都会进行检查，对于ht[0]的<code>size</code>和<code>used</code>属性，<code>ratio = used/size</code>满足一下任何一个条件，激活<code>rehash</code>:</p>
<ul>
<li>自然<code>rehash</code>： <code>ratio &gt;= 1</code>， 且变量<code>dict_can_resize</code>为真
<ul>
<li>在<code>BGSAVE</code>、<code>BGREWRITEAOF</code>时，<code>dict_can_resize</code>会暂时设为假，为了最大化利用系统的<code>copy on write</code>机制，减少程序对内存的碰撞。</li>
</ul>
</li>
<li>强制<code>rehash</code>：<code>ratio</code>大于变量<code>dict_force_resize_ratio</code>(目前默认为5)。</li>
</ul>
</li>
</ul>
<h5 id="138-rehash执行过程" class="headerLink"><a href="#138-rehash%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b" class="header-mark"></a>1.3.8 rehash执行过程</h5><p>执行步骤：</p>
<ol>
<li>创建一个比<code>ht[0]-&gt;table</code>更大的<code>ht[1]-&gt;table</code>
<ol>
<li>为<code>ht[1]-&gt;table</code>分配空间至少是<code>ht[0]-&gt;used</code>的两倍</li>
</ol>
</li>
<li>将<code>ht[0]-&gt;table</code>中的键值对迁移到<code>ht[1]-&gt;table</code></li>
<li>将原有的<code>ht[0]</code>的数据清空，并将<code>ht[1]</code>替换为新的<code>ht[0]</code>
<ol>
<li>释放<code>ht[0]</code>的空间</li>
<li>用<code>ht[1]</code>来代替<code>ht[0]</code></li>
<li>创建新的哈希表，设置为<code>ht[1]</code></li>
<li>将字典的<code>rehashidx</code>属性设置为-1，标识<code>rehash</code>已停止</li>
</ol>
</li>
</ol>
<h5 id="139-渐进式rehash" class="headerLink"><a href="#139-%e6%b8%90%e8%bf%9b%e5%bc%8frehash" class="header-mark"></a>1.3.9 渐进式rehash</h5><ul>
<li>
<p><code>rehash</code>程序不是在激活只会就马上执行知道完成的，而是分多次、渐进式地完成</p>
<ul>
<li>添加键值对触发<code>rehash</code>需要用户等很久不合理</li>
<li>服务器阻塞不可接受</li>
</ul>
</li>
<li>
<p>渐进式<code>rehash</code>由<code>_dictRehashStep</code>和 <code>dictRehashMilliseconds</code>两个函数进行</p>
<ul>
<li><code>_dictRehashStep</code>用于对数据库字典、以及哈希表的字典进行被动<code>rehash</code></li>
<li><code>dictRehashMilliseconds</code>由Redis服务器常规任务程序(server cron jon)执行，用于数据库字典进行主动<code>rehash</code></li>
</ul>
</li>
<li>
<p>_dictRehashStep</p>
<ul>
<li>每次执行<code>_dictRehashStep</code>，<code>ht[0]-&gt;table</code>哈希表第一个不为空的索引上的所有节点就会全部迁移到<code>ht[1]-&gt;table</code></li>
<li>在<code>rehash</code>开始之后，每次执行一次添加、查找、删除操作，<code>_dictRehashStep</code>都会执行一次</li>
</ul>
</li>
<li>
<p>dictRehashMilliseconds</p>
<ul>
<li><code>dictRehashMilliseconds</code>可以在指定的毫秒数内，对字典进行<code>rehash</code></li>
</ul>
</li>
<li>
<p>其他措施</p>
<ul>
<li><code>rehash</code>时，字典同时存在两个哈希表，所以查找、删除等操作除了在<code>ht[0]</code>上进行，还需要在ht[1]上进行。</li>
<li>在执行添加操作时，新的节点直接添加到<code>ht[1]</code></li>
</ul>
</li>
</ul>
<h5 id="1310-字典的收缩" class="headerLink"><a href="#1310-%e5%ad%97%e5%85%b8%e7%9a%84%e6%94%b6%e7%bc%a9" class="header-mark"></a>1.3.10 字典的收缩</h5><ul>
<li>
<p>如果哈希表的可用节点比已用节点数大很多，也可以对哈希表进行<code>rehash</code>来收缩字典</p>
</li>
<li>
<p>收缩规则定义：</p>
<ul>
<li>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8f5902;font-style:italic">// redis.c/htNeedResize
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">int</span> <span style="color:#000">htNeedsResize</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">dict</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">dict</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span> 
  <span style="color:#204a87;font-weight:bold">long</span> <span style="color:#204a87;font-weight:bold">long</span> <span style="color:#000">size</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">used</span><span style="color:#000;font-weight:bold">;</span>
  <span style="color:#000">size</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">dictSlots</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">dict</span><span style="color:#000;font-weight:bold">);</span> <span style="color:#8f5902;font-style:italic">// 哈希表已用节点数量 
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">used</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">dictSize</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">dict</span><span style="color:#000;font-weight:bold">);</span> <span style="color:#8f5902;font-style:italic">// 哈希表大小
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#8f5902;font-style:italic">// 当哈希表的大小大于 DICT_HT_INITIAL_SIZE 并且字典的填充率低于 REDIS_HT_MINFILL 时 返回 1
</span><span style="color:#8f5902;font-style:italic"></span>    <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">size</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#000">used</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#000">size</span> <span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">DICT_HT_INITIAL_SIZE</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">used</span><span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#0000cf;font-weight:bold">100</span><span style="color:#ce5c00;font-weight:bold">/</span><span style="color:#000">size</span> <span style="color:#ce5c00;font-weight:bold">&lt;</span> <span style="color:#000">REDIS_HT_MINFILL</span><span style="color:#000;font-weight:bold">));</span>
    
<span style="color:#000;font-weight:bold">}</span>
</code></pre></div></li>
<li>
<p>默认情况下，<code>DICT_HT_INITIAL_SIZE</code>的值为10。也就是当字典填充率低于10%时，程序就可以对这个字典进行收缩操作的。</p>
</li>
</ul>
</li>
<li>
<p>收缩和扩展的区别</p>
<ul>
<li>扩展操作时自动触发的。而收缩操作时由程序手动执行</li>
</ul>
</li>
<li>
<p>使用字典的程序可以决定何时对字典进行收缩</p>
<ul>
<li>字典用于实现哈希键：每次从字典删除一个键值对，会立即执行<code>htNeedsResize</code>函数，判断是否需要收缩</li>
<li>字典用于实现数据库键空间：由<code>redis.c/tryResizeHashTables</code>函数决定</li>
</ul>
</li>
</ul>
<h5 id="1311-字典其他操作" class="headerLink"><a href="#1311-%e5%ad%97%e5%85%b8%e5%85%b6%e4%bb%96%e6%93%8d%e4%bd%9c" class="header-mark"></a>1.3.11 字典其他操作</h5><h5 id="1312-字典的迭代" class="headerLink"><a href="#1312-%e5%ad%97%e5%85%b8%e7%9a%84%e8%bf%ad%e4%bb%a3" class="header-mark"></a>1.3.12 字典的迭代</h5><ul>
<li>
<p>字典带有自己的迭代器实现（对字典迭代实际上是对字典所使用的的哈希表迭代）</p>
<ul>
<li>迭代器首先迭代第一个哈希表，如果正在<code>rehash</code>，就继续对第二个哈希表进行迭代</li>
<li>当迭代哈希表时，找到第一个不为空的索引，然后迭代这个索引上的所有节点</li>
<li>当这个索引迭代完了，继续查找下一个不为空的索引，如此循环，一直到整个哈希表都迭代完为止。</li>
</ul>
</li>
<li>
<p>字典的迭代器有两种</p>
<ul>
<li>安全迭代器：在迭代过程中，可以对字典进行修改</li>
<li>不安全迭代器：在迭代过程中，不对字典进行修改</li>
</ul>
</li>
<li>
<p>迭代器的数据结构定义：</p>
<ul>
<li>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">dictIterator</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000">dict</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">d</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">//正在迭代的字典
</span><span style="color:#8f5902;font-style:italic"></span>      
  <span style="color:#204a87;font-weight:bold">int</span> <span style="color:#000">table</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#8f5902;font-style:italic">// 正在迭代的哈希表的号码(0或者1)
</span><span style="color:#8f5902;font-style:italic"></span>        <span style="color:#000">index</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#8f5902;font-style:italic">// 正在迭代的哈希数组的索引
</span><span style="color:#8f5902;font-style:italic"></span>        <span style="color:#000">safe</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 是否安全？
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">dictEntry</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">entry</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#8f5902;font-style:italic">// 当前哈希节点
</span><span style="color:#8f5902;font-style:italic"></span>                    <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">nextEntry</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 当前哈希节点的后继节点
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">}</span> <span style="color:#000">dictIterator</span><span style="color:#000;font-weight:bold">;</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>迭代器API</p>
<ul>
<li>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708174305.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708174305.png"
         title="20210708174305.png"
    /></li>
</ul>
</li>
</ul>
<h5 id="1313-小结" class="headerLink"><a href="#1313-%e5%b0%8f%e7%bb%93" class="header-mark"></a>1.3.13 小结</h5><ul>
<li>字典由键值对构成的抽象数据结构</li>
<li>Redis中的数据库和哈希键都基于字典来实现</li>
<li>Redis字典的底层实现为哈希表，每个字典使用两个哈希表。一般情况下只是用0号哈希表，只有<code>rehash</code>时，才会同时使用0号和1号哈希表</li>
<li>哈希表使用<code>链地址法</code>解决键冲突</li>
<li><code>Rehash</code>可以用于扩展和收缩哈希表</li>
<li>对哈希表的<code>rehash</code>是分多次、渐进式地进行的</li>
</ul>
<h4 id="14-跳跃表" class="headerLink"><a href="#14-%e8%b7%b3%e8%b7%83%e8%a1%a8" class="header-mark"></a>1.4 跳跃表</h4><ul>
<li>一种随机化的数据</li>
<li>以有序的方式在层次化的链表中保存元素</li>
<li>效率可以和平衡树媲美，查找、删除、添加都可以在对数期望时间下完成</li>
</ul>
<p>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709140155.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709140155.png"
         title="20210709140155.png"
    /></p>
<ul>
<li>表头(head)：负责维护跳跃表的节点指针</li>
<li>跳跃表节点：保存元素值，以及多个层</li>
<li>层：保存着指向其他元素的指针。高层的指针越过的元素数量大于底层的指针，为了提高查找效率，从高层开始访问，随着元素值范围缩小，慢慢降低层次</li>
<li>表尾：全部由NULL组成，表示跳跃表的末尾</li>
</ul>
<h5 id="141-跳跃表的实现" class="headerLink"><a href="#141-%e8%b7%b3%e8%b7%83%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>1.4.1 跳跃表的实现</h5><p>为了适应功能需要，redis做了修改:</p>
<ul>
<li>允许重复的<code>score</code>值：多个不同的<code>member</code>的<code>score</code>值可以相同</li>
<li>进行对比操作时，不仅要检查<code>score</code>值，还要检查<code>member</code></li>
<li>每个节点都带有一个高度为1层的后退至真，用于从表尾方向向表头方向迭代</li>
</ul>
<p>结构定义：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8f5902;font-style:italic">// redis.h/zskiplist
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">zskiplist</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">zskiplistNode</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">header</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">tail</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 头节点，尾节点
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">unsigned</span> <span style="color:#204a87;font-weight:bold">long</span> <span style="color:#000">length</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 节点数量
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">int</span> <span style="color:#000">level</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 目前表内节点的最大层数
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">}</span> <span style="color:#000">zskiplist</span><span style="color:#000;font-weight:bold">;</span>
</code></pre></div><p>跳跃表节点定义：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8f5902;font-style:italic">// redis.h/zskiplistNode
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">zskiplistNode</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000">robj</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">obj</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// member对象
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">double</span> <span style="color:#000">score</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 分值
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">zskiplistNode</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">backward</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 后退指针
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">zskiplistLevel</span> <span style="color:#000;font-weight:bold">{</span> <span style="color:#8f5902;font-style:italic">// 层
</span><span style="color:#8f5902;font-style:italic"></span>    <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">zskiplistNode</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">forward</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 前进指针
</span><span style="color:#8f5902;font-style:italic"></span>    <span style="color:#204a87;font-weight:bold">unsigned</span> <span style="color:#204a87;font-weight:bold">int</span> <span style="color:#000">span</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 这个层跨越的节点数量
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000;font-weight:bold">}</span> <span style="color:#000">level</span><span style="color:#000;font-weight:bold">[];</span>
<span style="color:#000;font-weight:bold">}</span> <span style="color:#000">zskiplistNode</span><span style="color:#000;font-weight:bold">;</span>
</code></pre></div><p>操作这两个数据结构API：</p>
<p>![image-20210709144926947](/Users/cks/Library/Application Support/typora-user-images/image-20210709144926947.png)</p>
<h5 id="142-跳跃表的应用" class="headerLink"><a href="#142-%e8%b7%b3%e8%b7%83%e8%a1%a8%e7%9a%84%e5%ba%94%e7%94%a8" class="header-mark"></a>1.4.2 跳跃表的应用</h5><ul>
<li>实现有序集数据类型
<ul>
<li>跳跃表将指向有序集的<code>score</code>值和<code>member</code>域的指针作为元素，并以<code>score</code>值作为索引，对有序集元素进行排序。</li>
</ul>
</li>
</ul>
<h5 id="143-小结" class="headerLink"><a href="#143-%e5%b0%8f%e7%bb%93" class="header-mark"></a>1.4.3 小结</h5><ul>
<li>跳跃表是一种随机化数据结构，查找、添加、删除都可以在对数期望时间下完成</li>
<li>跳跃表目前在Redis的唯一作用就是作为有序集类型的底层数据结构之一（另一个构成有序集的结构是字典）</li>
<li>为了适应功能，redis基于<code>William Pugh</code>论文中描述的跳跃表进行修改：
<ul>
<li><code>score</code>值可重复</li>
<li>对比元素同时检查<code>score</code>和<code>member</code></li>
<li>每个节点带有高度为1的后退指针，用于从表尾向表头迭代</li>
</ul>
</li>
</ul>
<h3 id="2内存映射数据结构" class="headerLink"><a href="#2%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="header-mark"></a>2、内存映射数据结构</h3><ul>
<li>虽然<code>内部数据结构</code>非常强大，但是耗费内存。对于元素本身体积不大，代价昂贵。
<ul>
<li>Redis允许使用<code>内存映射数据结构</code>来代替<code>内部数据结构</code></li>
</ul>
</li>
<li><code>内存映射数据</code>是一系列经过特殊编码的字节序列，节省大量内存</li>
<li>因为<code>内存映射数据结构</code>复杂得多，所以占用CPU时间要多</li>
</ul>
<h4 id="21-整数集合" class="headerLink"><a href="#21-%e6%95%b4%e6%95%b0%e9%9b%86%e5%90%88" class="header-mark"></a>2.1 整数集合</h4><ul>
<li>整数集合（<code>ineset</code>）用于有序、无重复地保存多个整数值。会根据元素的值，自动选择(调整)该用什么长度的整数类型保存数据。</li>
</ul>
<h5 id="211-整数集合的应用" class="headerLink"><a href="#211-%e6%95%b4%e6%95%b0%e9%9b%86%e5%90%88%e7%9a%84%e5%ba%94%e7%94%a8" class="header-mark"></a>2.1.1 整数集合的应用</h5><p><code>Intset</code>是集合键的底层实现之一，如果一个集合满足：</p>
<ul>
<li>只保存整数数据</li>
<li>元素数量不多</li>
</ul>
<h5 id="222-数据结构和主要操作" class="headerLink"><a href="#222-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%92%8c%e4%b8%bb%e8%a6%81%e6%93%8d%e4%bd%9c" class="header-mark"></a>2.2.2 数据结构和主要操作</h5><ul>
<li>定义</li>
</ul>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8f5902;font-style:italic">// intset.h/intset
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">intset</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000">uint32_t</span> <span style="color:#000">encoding</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 保存元素所使用的的类型的长度
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">uint32_t</span> <span style="color:#000">length</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 元素个数
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">int8_t</span> <span style="color:#000">contents</span><span style="color:#000;font-weight:bold">[];</span> <span style="color:#8f5902;font-style:italic">// 保存元素的数组
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">}</span> <span style="color:#000">intset</span><span style="color:#000;font-weight:bold">;</span>
</code></pre></div><ul>
<li><code>encoding</code>的值：</li>
</ul>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8f5902;font-style:italic">// intset.c
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#8f5902;font-style:italic"># define INTSET_ENC_INT16 (sizeof(int16_t))
</span><span style="color:#8f5902;font-style:italic">#define INTSET_ENC_INT32 (sizeof(int32_t)) 
</span><span style="color:#8f5902;font-style:italic">#define INTSET_ENC_INT64 (sizeof(int64_t))
</span></code></pre></div><ul>
<li>
<p><code>content</code>数组是实际保存数据的地方，特性：</p>
<ul>
<li>没有重复元素</li>
<li>元素在数组中从小到大排列</li>
</ul>
</li>
<li>
<p><code>content</code>数组的<code>int8_t</code>类型声明做为占位符使用。程序根据<code>encoding</code>的值，对<code>content</code>进行类型转换和指针运算。</p>
</li>
<li>
<p>inset主要操作</p>
<ul>
<li>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709154323.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709154323.png"
         title="20210709154323.png"
    /></li>
</ul>
</li>
</ul>
<h5 id="213-intset-运行实例" class="headerLink"><a href="#213-intset-%e8%bf%90%e8%a1%8c%e5%ae%9e%e4%be%8b" class="header-mark"></a>2.1.3 intset 运行实例</h5><ul>
<li>创建新<code>inset</code>
<ul>
<li><code>intset *is = intsetNew();</code>  // <code>intset.c/intsetNew</code></li>
</ul>
</li>
<li>添加新元素到<code>intset</code>。<code>intset.c/intsetAdd</code>
<ul>
<li>处理情况
<ul>
<li>元素已存在，不做动作</li>
<li>元素不存在，并且添加新元素不需要升级</li>
<li>元素不存在，需要升级后，才能添加元素</li>
</ul>
</li>
<li><code>intsetAdd</code>需要维持<code>intset-&gt;contents</code>的以下性质
<ul>
<li>没有重复元素</li>
<li>从小到大排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="214-升级" class="headerLink"><a href="#214-%e5%8d%87%e7%ba%a7" class="header-mark"></a>2.1.4 升级</h5><ul>
<li>
<p><code>intsetAdd</code>发现新元素不能用现有编码方式保存，就会使用<code>intsetUpgradeAndAdd</code>函数升级</p>
</li>
<li>
<p><code>intsetUpgradeAndAdd</code>任务</p>
<ol>
<li>检测新元素需要编码类型</li>
<li>设置<code>encoding</code>属性为新编码类型，根据新编码类型对整个<code>contents</code>数组进行内存重分配</li>
<li>调整<code>contents</code>数组原有元素在内存中排列方式，从旧编码调整为新编码</li>
<li>将新元素添加到集合</li>
</ol>
</li>
</ul>
<h5 id="215-关于升级" class="headerLink"><a href="#215-%e5%85%b3%e4%ba%8e%e5%8d%87%e7%ba%a7" class="header-mark"></a>2.1.5 关于升级</h5><ul>
<li>从较短整数到较长整数的转换，并不会更改元素里面的值</li>
<li>集合编码元素的方式，由元素中长度最大的那个值来决定</li>
</ul>
<h5 id="216-关于元素移动" class="headerLink"><a href="#216-%e5%85%b3%e4%ba%8e%e5%85%83%e7%b4%a0%e7%a7%bb%e5%8a%a8" class="header-mark"></a>2.1.6 关于元素移动</h5><ul>
<li>元素移动不仅出现在升级(<code>intsetUpgradeAndAdd</code>)操作中，还出现在对<code>contents</code>数组的增删(<code>intsetAdd</code>和<code>intsetRemove</code>)操作上。复杂度都不低于O(n)</li>
</ul>
<h5 id="217-其他操作" class="headerLink"><a href="#217-%e5%85%b6%e4%bb%96%e6%93%8d%e4%bd%9c" class="header-mark"></a>2.1.7 其他操作</h5><ul>
<li>读取
<ul>
<li><code>_intsetGet</code>：接受一个索引<code>pos</code>，根据<code>intset-&gt;encoding</code>的值进行指针运算，计算出给定索引的值。</li>
<li><code>intsetSearch</code> 二分查找，判断元素的索引</li>
</ul>
</li>
<li>写入
<ul>
<li><code>_intsetSet</code>：接受一个索引<code>pos</code>以及一个<code>new_value</code>，将<code>pos</code>位置设置为<code>new_value</code></li>
</ul>
</li>
<li>删除
<ul>
<li><code>intsetRemove</code>：删除单个元素。先<code>intsetSearch</code>获取需要删除元素索引，然后济宁内存移位操作，最后通过内存重新分配，调整数组长度</li>
</ul>
</li>
<li>降级
<ul>
<li><code>Intset</code>不支持降级操作</li>
</ul>
</li>
</ul>
<h5 id="218-小结" class="headerLink"><a href="#218-%e5%b0%8f%e7%bb%93" class="header-mark"></a>2.1.8 小结</h5><ul>
<li><code>Intset</code>用于有序、无重复地保存多个整数值，它会根据元素的值，自动选择该用什么长度 的整数类型来保存元素。</li>
<li>当一个位长度更长的整数值添加到 <code>intset</code> 时，需要对 <code>intset</code> 进行升级，新 <code>intset</code> 中每个 元素的位长度都等于新添加值的位长度，但原有元素的值不变。</li>
<li>升级会引起整个 <code>intset</code> 进行内存重分配，并移动集合中的所有元素，这个操作的复杂度 为 O(N) 。</li>
<li><code>Intset</code>只支持升级，不支持降级。</li>
<li><code>Intset</code> 是有序的，程序使用二分查找算法来实现查找操作，复杂度为 O(lg N) 。</li>
</ul>
<h4 id="22-压缩列表" class="headerLink"><a href="#22-%e5%8e%8b%e7%bc%a9%e5%88%97%e8%a1%a8" class="header-mark"></a>2.2 压缩列表</h4><ul>
<li><code>Ziplist</code>是由一系列特殊编码的内存块构成的列表</li>
<li>一个<code>ziplist</code>可以包含多个节点<code>entry</code></li>
<li>每个节点可以保存一个长度首先的字符数组或者整数
<ul>
<li>字符数组
<ul>
<li>长度小于等于 63 （2 6− 1）字节的字符数组</li>
<li>长度小于等于 16383 （2 14− 1）字节的字符数组</li>
<li>长度小于等于 4294967295 （2 32− 1）字节的字符数组</li>
</ul>
</li>
<li>整数
<ul>
<li>4 位长，介于 0 至 12 之间的无符号整数</li>
<li>1 字节长，有符号整数</li>
<li>3 字节长，有符号整数</li>
<li>int16_t 类型整数</li>
<li>int32_t 类型整数</li>
<li>int64_t 类型整数</li>
</ul>
</li>
</ul>
</li>
<li>因为<code>ziplist</code>节省内存。被哈希键、列表建、有序集合键作为初始化的底层实现来使用</li>
</ul>
<h5 id="221-ziplist的构成" class="headerLink"><a href="#221-ziplist%e7%9a%84%e6%9e%84%e6%88%90" class="header-mark"></a>2.2.1 ziplist的构成</h5><p>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709161202.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709161202.png"
         title="20210709161202.png"
    /></p>
<p><code>ziplist</code>宏：</p>
<p>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709161324.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709161324.png"
         title="20210709161324.png"
    /></p>
<p>操作<code>ziplist</code>的函数</p>
<p>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709161400.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709161400.png"
         title="20210709161400.png"
    /></p>
<h5 id="222-节点的构成" class="headerLink"><a href="#222-%e8%8a%82%e7%82%b9%e7%9a%84%e6%9e%84%e6%88%90" class="header-mark"></a>2.2.2 节点的构成</h5><p>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709161450.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709161450.png"
         title="20210709161450.png"
    /></p>
<ul>
<li>pre_entry_length
<ul>
<li>记录了前一个节点的长度。通过这个值可以进行指针运算，从而跳转到上一个节点</li>
</ul>
</li>
<li>encoding
<ul>
<li><code>content</code>部分数据类型</li>
</ul>
</li>
<li>length
<ul>
<li><code>content</code>部分数据长度</li>
</ul>
</li>
<li>content
<ul>
<li>保存节点内容</li>
</ul>
</li>
</ul>
<h5 id="223-创建新-ziplist" class="headerLink"><a href="#223-%e5%88%9b%e5%bb%ba%e6%96%b0-ziplist" class="header-mark"></a>2.2.3 创建新 ziplist</h5><ul>
<li><code>ziplistNew</code></li>
</ul>
<h5 id="224-将节点添加到末端" class="headerLink"><a href="#224-%e5%b0%86%e8%8a%82%e7%82%b9%e6%b7%bb%e5%8a%a0%e5%88%b0%e6%9c%ab%e7%ab%af" class="header-mark"></a>2.2.4 将节点添加到末端</h5><ol>
<li>记录到达末端所需的偏移量</li>
<li>根据需要保存的值，计算所需的空间大小以及编码它前一个节点的长度所需的空间大小，然后进行内存重分配</li>
<li>设置新节点的各项属性</li>
<li>更新<code>ziplist</code>的各项属性</li>
</ol>
<h5 id="225-将节点添加到某个某些节点的前面" class="headerLink"><a href="#225-%e5%b0%86%e8%8a%82%e7%82%b9%e6%b7%bb%e5%8a%a0%e5%88%b0%e6%9f%90%e4%b8%aa%e6%9f%90%e4%ba%9b%e8%8a%82%e7%82%b9%e7%9a%84%e5%89%8d%e9%9d%a2" class="header-mark"></a>2.2.5 将节点添加到某个/某些节点的前面</h5><ol>
<li>
<p>为新节点扩大<code>ziplist</code>的空间</p>
</li>
<li>
<p>设置新节点的各项属性</p>
</li>
<li>
<p>更新新节点到<code>ziplist</code>。更新<code>next</code>节点的<code>pre_entry_length</code></p>
<ol>
<li><code>pre_entry_length</code>正好够新元素的长度</li>
<li><code>pre_entry_length</code>只有1字节长，新元素需要5字节</li>
<li><code>pre_entry_length</code>有5字节长，新元素需要1字节</li>
</ol>
<p>1、3情况，直接更新<code>pre_entry_length</code>。2情况需要对<code>ziplist</code>进行内存重分配，从<code>next</code>开始往后逐个判断是否扩展长度。所以复杂度为O(n^2)</p>
</li>
<li>
<p>更新<code>ziplist</code>各项属性</p>
</li>
</ol>
<h5 id="226-删除节点" class="headerLink"><a href="#226-%e5%88%a0%e9%99%a4%e8%8a%82%e7%82%b9" class="header-mark"></a>2.2.6 删除节点</h5><ol>
<li>定位目标节点，计算节点的空间长度</li>
<li>进行内存移位覆盖原本数据，然后内存重新分配，收缩多余空间</li>
<li>检查<code>next</code>、<code>next+1</code>等后续节点是否满足新前驱节点的编码。类似添加操作，也会引起连锁更新。</li>
</ol>
<h5 id="227-遍历" class="headerLink"><a href="#227-%e9%81%8d%e5%8e%86" class="header-mark"></a>2.2.7 遍历</h5><ul>
<li>可以对<code>ziplist</code>进行从前向后的遍历，或者从后向前的遍历。</li>
</ul>
<h5 id="228-查找元素根据值定位节点" class="headerLink"><a href="#228-%e6%9f%a5%e6%89%be%e5%85%83%e7%b4%a0%e6%a0%b9%e6%8d%ae%e5%80%bc%e5%ae%9a%e4%bd%8d%e8%8a%82%e7%82%b9" class="header-mark"></a>2.2.8 查找元素，根据值定位节点</h5><ul>
<li>类似遍历原理</li>
</ul>
<h5 id="229-小结" class="headerLink"><a href="#229-%e5%b0%8f%e7%bb%93" class="header-mark"></a>2.2.9 小结</h5><ul>
<li><code>ziplist</code> 是由一系列特殊编码的内存块构成的列表，它可以保存字符数组或整数值，它还是 哈希键、列表键和有序集合键的底层实现之一。</li>
<li><code>ziplist</code> 的结构</li>
<li><code>ziplist</code> 的节点<code>entry</code>结构</li>
<li>添加和删除<code>ziplist</code> 节点有可能会引起连锁更新，因此最坏复杂度O(n^2)。不过连锁更新概率不高，所以可以视为O(n)</li>
</ul>
<h3 id="3redis数据类型" class="headerLink"><a href="#3redis%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" class="header-mark"></a>3、Redis数据类型</h3><h4 id="31-对象处理机制" class="headerLink"><a href="#31-%e5%af%b9%e8%b1%a1%e5%a4%84%e7%90%86%e6%9c%ba%e5%88%b6" class="header-mark"></a>3.1 对象处理机制</h4><ul>
<li>问题
<ul>
<li>Redis必须让每个键都带有类型信息，使得程序可以检查键的类型，并为它选择合适的处理方式</li>
<li>需要根据数据类型的不同编码进行多态处理</li>
</ul>
</li>
<li>为了解决上述问题，Redis构建了自己的类型系统，主要功能：
<ul>
<li><code>redisObject</code>对象</li>
<li>基于<code>redisObject</code>对象的类型检查</li>
<li>基于<code>redisObject</code>对象的显式多态函数</li>
<li>对<code>redisObject</code>进行分配、共享和销毁的机制</li>
</ul>
</li>
</ul>
<h5 id="311-redisobject数据结构以及redis的数据类型" class="headerLink"><a href="#311-redisobject%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%bb%a5%e5%8f%8aredis%e7%9a%84%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" class="header-mark"></a>3.1.1 redisObject数据结构，以及Redis的数据类型</h5><ul>
<li>定义</li>
</ul>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8f5902;font-style:italic">// redis.h
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">redisObject</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#204a87;font-weight:bold">unsigned</span> <span style="color:#f57900">type</span><span style="color:#000;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">4</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 类型
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">unsigned</span> <span style="color:#f57900">notused</span><span style="color:#000;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">2</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 对齐位
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">unsigned</span> <span style="color:#f57900">encoding</span><span style="color:#000;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">4</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 编码方式
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">unsigned</span> <span style="color:#f57900">lru</span><span style="color:#000;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">22</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// LRU时间(相对于 server.lruclock)
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">unsigned</span> <span style="color:#000">refcount</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 引用计数
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">ptr</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 指向对象的值
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">}</span> <span style="color:#000">robj</span><span style="color:#000;font-weight:bold">;</span>
</code></pre></div><ul>
<li><code>type</code>记录了对象所保存的值的类型</li>
</ul>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8f5902;font-style:italic">#define REDIS_STRING 0 </span><span style="color:#8f5902;font-style:italic">// 字符串
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#8f5902;font-style:italic">#define REDIS_LIST 1 </span><span style="color:#8f5902;font-style:italic">// 列表
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#8f5902;font-style:italic">#define REDIS_SET 2 </span><span style="color:#8f5902;font-style:italic">// 集合
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#8f5902;font-style:italic">#define REDIS_ZSET 3 </span><span style="color:#8f5902;font-style:italic">// 有序集
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#8f5902;font-style:italic">#define REDIS_HASH 4 </span><span style="color:#8f5902;font-style:italic">// 哈希表
</span></code></pre></div><ul>
<li><code>encoding</code>记录了对象所保存的值的编码</li>
</ul>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8f5902;font-style:italic">#define REDIS_ENCODING_RAW 0 </span><span style="color:#8f5902;font-style:italic">// 编码为字符串
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#8f5902;font-style:italic">#define REDIS_ENCODING_INT 1 </span><span style="color:#8f5902;font-style:italic">// 编码为整数
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#8f5902;font-style:italic">#define REDIS_ENCODING_HT 2 </span><span style="color:#8f5902;font-style:italic">// 编码为哈希表
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#8f5902;font-style:italic">#define REDIS_ENCODING_ZIPMAP 3 </span><span style="color:#8f5902;font-style:italic">// 编码为 zipmap
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#8f5902;font-style:italic">#define REDIS_ENCODING_LINKEDLIST 4 </span><span style="color:#8f5902;font-style:italic">// 编码为双端链表
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#8f5902;font-style:italic">#define REDIS_ENCODING_ZIPLIST 5 </span><span style="color:#8f5902;font-style:italic">// 编码为压缩列表
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#8f5902;font-style:italic">#define REDIS_ENCODING_INTSET 6 </span><span style="color:#8f5902;font-style:italic">// 编码为整数集合
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#8f5902;font-style:italic">#define REDIS_ENCODING_SKIPLIST 7 </span><span style="color:#8f5902;font-style:italic">// 编码为跳跃表
</span></code></pre></div><ul>
<li>ptr是一个指针，指向实际保存值的数据结构，这个数据结构由<code>type</code>属性和<code>encoding</code>属性决定</li>
</ul>
<h5 id="312-命令的类型检查和多态" class="headerLink"><a href="#312-%e5%91%bd%e4%bb%a4%e7%9a%84%e7%b1%bb%e5%9e%8b%e6%a3%80%e6%9f%a5%e5%92%8c%e5%a4%9a%e6%80%81" class="header-mark"></a>3.1.2 命令的类型检查和多态</h5><ul>
<li>当执行一个处理数据类型的命令时：
<ol>
<li>根据给定的<code>key</code>，在数据字典查找<code>redisObject</code>，如果没找到返回NULL</li>
<li>检查<code>redisObject</code>的<code>type</code>属性和执行命令所需的类型是否相符，如果不相符，返回类型错误</li>
<li>根据<code>redisObject</code>的<code>encoding</code>属性所指定的编码，选择合适的操作函数来处理底层的数据结构</li>
<li>返回数据结构的操作结果作为命令的返回值</li>
</ol>
</li>
</ul>
<h5 id="313-对象共享" class="headerLink"><a href="#313-%e5%af%b9%e8%b1%a1%e5%85%b1%e4%ba%ab" class="header-mark"></a>3.1.3 对象共享</h5><ul>
<li>Flyweight 模式
<ul>
<li>通过预分配一个常见的值对象，并在多个数据结构之间共存这些对象，避免重复分配，也节约CPU时间</li>
</ul>
</li>
<li>Redis预分配的值对象
<ul>
<li>各种命令的返回值。<code>OK</code>、<code>ERROR</code>等</li>
<li>包括0在不，小于<code>redis.h/REDIS_SHARED_INTEGERS</code>的所有整数。（默认10000）</li>
</ul>
</li>
<li>共享对象只能被带指针的数据结构使用。</li>
</ul>
<h5 id="314-引用计数以及对象的销毁" class="headerLink"><a href="#314-%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%e4%bb%a5%e5%8f%8a%e5%af%b9%e8%b1%a1%e7%9a%84%e9%94%80%e6%af%81" class="header-mark"></a>3.1.4 引用计数以及对象的销毁</h5><ul>
<li>问题
<ul>
<li><code>redisObject</code>用作数据库的键或者值，生命周期非常长，C语言本身没有自动释放内存的相关机制</li>
<li>对象的引用次数问题</li>
</ul>
</li>
<li>解决方案。使用引用计数技术负责维持和销毁对象
<ul>
<li>每个<code>redisObject</code>都有一个<code>refcount</code>属性，记录被引用次数</li>
<li>新建对象，<code>refcount</code>值为1</li>
<li>对一个对象进行共享时， <code>refcount</code>加一</li>
<li>当用完一个对象之后，或者取消引用之后，程序对对象的<code>refcount</code>减一</li>
<li>当对象的<code>refcount</code>降至0时，这个<code>redisObject</code>以及它所引用的数据结构的内存，就会被释放</li>
</ul>
</li>
</ul>
<h5 id="315-小结" class="headerLink"><a href="#315-%e5%b0%8f%e7%bb%93" class="header-mark"></a>3.1.5 小结</h5><ul>
<li>Redis使用自己实现的对象机制来实现类型判断、命令多态和基于引用计数的垃圾回收。</li>
<li>一种 Redis 类型的键可以有多种底层实现</li>
<li>Redis 会预分配一些常用的数据对象，并通过共享这些对象来减少内存占用，和避免频繁 地为小对象分配内存。</li>
</ul>
<h4 id="32-字符串" class="headerLink"><a href="#32-%e5%ad%97%e7%ac%a6%e4%b8%b2" class="header-mark"></a>3.2 字符串</h4><ul>
<li><code>REDIS_STRING</code>是Redis使用最广泛的数据类型</li>
</ul>
<h5 id="321-字符串编码" class="headerLink"><a href="#321-%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%bc%96%e7%a0%81" class="header-mark"></a>3.2.1 字符串编码</h5><ul>
<li>字符串类型分别使用<code>REDIS_ENCODING_INT</code>和<code>REDIS_ENCODING_RAW</code>两种编码
<ul>
<li><code>REDIS_ENCODING_INT</code>使用<code>long</code>类型来保存<code>long</code>类型值</li>
<li><code>REDIS_ENCODING_RAW</code>使用<code>sdshdr</code>结构来保存<code>sds(char *)</code>、<code>long long</code>、<code>double</code>、<code>long double</code>类型</li>
</ul>
</li>
</ul>
<h5 id="322-编码的选择" class="headerLink"><a href="#322-%e7%bc%96%e7%a0%81%e7%9a%84%e9%80%89%e6%8b%a9" class="header-mark"></a>3.2.2 编码的选择</h5><ul>
<li>新创建的字符串默认使用<code>REDIS_ENCODING_RAW</code>编码</li>
<li>在字符串作为键或者值保存进数据库时，会尝试转为<code>REDIS_ENCODING_INT</code></li>
</ul>
<h5 id="323-字符串命令的实现" class="headerLink"><a href="#323-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>3.2.3 字符串命令的实现</h5><ul>
<li>通过包装<code>sds</code>数据结构的操作函数来实现</li>
</ul>
<h4 id="33-哈希表" class="headerLink"><a href="#33-%e5%93%88%e5%b8%8c%e8%a1%a8" class="header-mark"></a>3.3 哈希表</h4><ul>
<li><code>REDIS_HASH</code>是<code>HSET</code>、<code>HLEN</code>等命令的操作对象，它使用<code>REDIS_ENCODING_ZIPLIST</code> (压缩列表)和 <code>REDIS_ENCODING_HT </code>(字典)两种编码方式</li>
</ul>
<h5 id="331-字典编码的哈希表" class="headerLink"><a href="#331-%e5%ad%97%e5%85%b8%e7%bc%96%e7%a0%81%e7%9a%84%e5%93%88%e5%b8%8c%e8%a1%a8" class="header-mark"></a>3.3.1 字典编码的哈希表</h5><ul>
<li>当使用字典编码时，程序将哈希表的键保存为字典的键，哈希表的值保存为字典的值</li>
</ul>
<h5 id="332-压缩列表编码的哈希表" class="headerLink"><a href="#332-%e5%8e%8b%e7%bc%a9%e5%88%97%e8%a1%a8%e7%bc%96%e7%a0%81%e7%9a%84%e5%93%88%e5%b8%8c%e8%a1%a8" class="header-mark"></a>3.3.2 压缩列表编码的哈希表</h5><ul>
<li>程序将键和值一同推入压缩列表，从而形成保存哈希表所需的键值对结构
<ul>
<li>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709173251.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709173251.png"
         title="20210709173251.png"
    /></li>
</ul>
</li>
<li>新添加的键值对会被添加到压缩列表的表尾</li>
<li>当进行查找/删除或者更新操作时，程序先定位到键的位置，然后在通过对键的位置来定位值的位置</li>
</ul>
<h5 id="333-编码的选择" class="headerLink"><a href="#333-%e7%bc%96%e7%a0%81%e7%9a%84%e9%80%89%e6%8b%a9" class="header-mark"></a>3.3.3 编码的选择</h5><ul>
<li>创建空白哈希表，默认使用<code>REDIS_ENCODING_ZIPLIST</code>。</li>
<li>满足以下任何一个条件，编码会切换为<code>REDIS_ENCODING_HT</code>：
<ul>
<li>哈希表中的某个键或者某个值的长度大于<code>server.hash_max_ziplist_value</code>(默认64)</li>
<li>压缩列表中的节点数量大于<code>server.hash_max_ziplist_entries</code> (默认512)</li>
</ul>
</li>
</ul>
<h5 id="334-哈希命令的实现" class="headerLink"><a href="#334-%e5%93%88%e5%b8%8c%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>3.3.4 哈希命令的实现</h5><ul>
<li>对字典和压缩列表操作函数的封装，以及在两种编码之间进行转换的函数</li>
</ul>
<h4 id="34-列表" class="headerLink"><a href="#34-%e5%88%97%e8%a1%a8" class="header-mark"></a>3.4 列表</h4><ul>
<li><code>REDIS_LIST</code>是<code>LPUSH</code>、<code>LRANGE</code>等命令的操作对象，它使用<code>REDIS_ENCODING_ZIPLIST</code> 和 <code>REDIS_ENCODING_LINKEDLIST</code>这两种方式编码</li>
</ul>
<h5 id="341-编码的选择" class="headerLink"><a href="#341-%e7%bc%96%e7%a0%81%e7%9a%84%e9%80%89%e6%8b%a9" class="header-mark"></a>3.4.1 编码的选择</h5><ul>
<li>默认使用<code>REDIS_ENCODING_ZIPLIST</code></li>
<li>满足以下任一条件，会转换为<code>REDIS_ENCODING_LINKEDLIST</code>
<ul>
<li>新增字符串长度超过<code>server.list_max_ziplist_value</code> (默认64)</li>
<li><code>ziplist</code>包含的节点超过 <code>server.list_max_ziplist_entries </code>(默认值512)</li>
</ul>
</li>
</ul>
<h5 id="342-列表命令的实现" class="headerLink"><a href="#342-%e5%88%97%e8%a1%a8%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>3.4.2 列表命令的实现</h5><ul>
<li>两种底层实现的抽象方式和列表的抽象方式非常接近，所以列表命令几乎就是通过一对一 地映射到底层数据结构的操作来实现的</li>
</ul>
<h5 id="343-阻塞的条件" class="headerLink"><a href="#343-%e9%98%bb%e5%a1%9e%e7%9a%84%e6%9d%a1%e4%bb%b6" class="header-mark"></a>3.4.3 阻塞的条件</h5><ul>
<li><code>BLPOP</code> 、<code>BRPOP</code> 和 <code>BRPOPLPUSH</code>三个命令都可能造成客户端被阻塞，以下将这些命令统 称为列表的阻塞原语。</li>
<li>阻塞原语并不是一定会造成客户端阻塞：
<ul>
<li>只有当这些命令并用于空列表时，才会阻塞客户端</li>
<li>如果被处理的列表不为空，就执行物阻塞版本的<code>LPOP</code> 、<code>RPOP</code>或<code>RPOPLPUSH</code>命令</li>
</ul>
</li>
</ul>
<h5 id="344-阻塞" class="headerLink"><a href="#344-%e9%98%bb%e5%a1%9e" class="header-mark"></a>3.4.4 阻塞</h5><ul>
<li>当一个阻塞原语的处理目标为空键时，执行该阻塞原语的客户端就会被阻塞</li>
<li>阻塞一个客户端需要执行的步骤
<ol>
<li>将客户端设置为“正在阻塞”，并记录阻塞客户端的各个键以及阻塞的最长时限</li>
<li>将客户端的信息记录到<code>server.db[1]-&gt;blocking_keys</code>中（其中<code>i</code>为客户端所使用的的数据库号码）</li>
<li>继续维持客户端和服务端之间的网络连接，但不在向客户端传送任何信息，造成客户端阻塞</li>
</ol>
</li>
<li>客户端脱离阻塞状态的方法：
<ol>
<li>被动脱离：其他客户端为造成阻塞的键推入了新元素</li>
<li>主动脱离：超过最大阻塞时间</li>
<li>强制脱离：客户端强制终止和服务器的链接，或者服务器停机</li>
</ol>
</li>
</ul>
<h5 id="345-阻塞因lpushrpushlinsert等添加命令而被取消" class="headerLink"><a href="#345-%e9%98%bb%e5%a1%9e%e5%9b%a0lpushrpushlinsert%e7%ad%89%e6%b7%bb%e5%8a%a0%e5%91%bd%e4%bb%a4%e8%80%8c%e8%a2%ab%e5%8f%96%e6%b6%88" class="header-mark"></a>3.4.5 阻塞因LPUSH、RPUSH、LINSERT等添加命令而被取消</h5><ul>
<li>这三个添加新元素到列表命令底层都是由<code>pushGenericCommand</code>函数实现</li>
<li>当向一个空键推入新元素时，该函数执行两件事：
<ol>
<li>检查键是存在于<code>server.db[i]-&gt;blocking_keys</code>字典里，如果有，为这个键创建一个<code>redis.h/readyList</code>结构，并将它添加到<code>server.ready_keys</code>链表中。</li>
<li>将给定的值添加到列表键中</li>
</ol>
</li>
</ul>
<p><code>readyList</code>结构定义：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">readyList</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000">redisDb</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">db</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 指向该键所在的数据库
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">robj</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">key</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 指向造成阻塞的键
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">}</span> <span style="color:#000">readyList</span><span style="color:#000;font-weight:bold">;</span>
</code></pre></div><p>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210712140713.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210712140713.png"
         title="20210712140713.png"
    /></p>
<ul>
<li>Redis主进程执行完<code>pushGenericCommand</code>函数后，继续调用<code>handleClientsBlockedOnLists</code>：
<ol>
<li>如果<code>server.ready_keys</code>不为空，弹出表头元素，并取出元素中的<code>readyList</code>值</li>
<li>根据<code>readyList</code>在<code>server.blocking_keys</code>中查找因为<code>key</code>被阻塞的客户端（以链表形式保存）</li>
<li>如果<code>key</code>不为空，弹出一个元素，并弹出客户端链表的第一个客户端，然后将被弹出的元素返回给被弹出客户端作为阻塞原语的返回值</li>
<li>根据<code>readyList</code>结构的属性，删除<code>server.blocking_keys</code>中响应的客户端数据，取消客户端的阻塞状态</li>
<li>继续执行步骤3和4直到<code>key</code>没有元素可弹出，或者没有阻塞的客户端</li>
<li>继续执行步骤1，直到<code>server.ready_keys</code>链表所有的<code>readyList</code>都被处理完</li>
</ol>
</li>
</ul>
<h5 id="346-先阻塞先服务fbfs策略" class="headerLink"><a href="#346-%e5%85%88%e9%98%bb%e5%a1%9e%e5%85%88%e6%9c%8d%e5%8a%a1fbfs%e7%ad%96%e7%95%a5" class="header-mark"></a>3.4.6 先阻塞先服务（FBFS）策略</h5><h5 id="347-阻塞因超过最大等待时间而被取消" class="headerLink"><a href="#347-%e9%98%bb%e5%a1%9e%e5%9b%a0%e8%b6%85%e8%bf%87%e6%9c%80%e5%a4%a7%e7%ad%89%e5%be%85%e6%97%b6%e9%97%b4%e8%80%8c%e8%a2%ab%e5%8f%96%e6%b6%88" class="header-mark"></a>3.4.7 阻塞因超过最大等待时间而被取消</h5><ul>
<li>每次Redis常规操作函数（server cron job）执行时，程序都会检查所有连接到服务器的客户端，查看哪些处于“正在阻塞”状态的客户端的最大阻塞时限是否已经过期</li>
<li>如果已经过期，给客户端返回空白回复，然后撤销对客户端阻塞</li>
</ul>
<h4 id="35-集合" class="headerLink"><a href="#35-%e9%9b%86%e5%90%88" class="header-mark"></a>3.5 集合</h4><ul>
<li><code>REDIS_SET</code>是<code>SADD</code>、<code>SRANDMEMBER</code>等命令的操作对象，它使用<code>REDIS_ENCODING_INTSET</code>和<code>REDIS_ENCODING_HT</code>两种方式编码</li>
</ul>
<h5 id="351-编码的选择" class="headerLink"><a href="#351-%e7%bc%96%e7%a0%81%e7%9a%84%e9%80%89%e6%8b%a9" class="header-mark"></a>3.5.1 编码的选择</h5><ul>
<li>第一个添加到集合的元素，决定了创建集合所使用的编码
<ul>
<li>第一个元素可以表示成<code>long long</code>类型，集合初始编码为<code>REDIS_ENCODING_INTSET</code></li>
<li>否则，初始编码为<code>REDIS_ENCODING_HT</code></li>
</ul>
</li>
</ul>
<h5 id="352-编码的切换" class="headerLink"><a href="#352-%e7%bc%96%e7%a0%81%e7%9a%84%e5%88%87%e6%8d%a2" class="header-mark"></a>3.5.2 编码的切换</h5><ul>
<li><code>REDIS_ENCODING_INTSET</code>切换到REDIS_ENCODING_HT。以下任一条件：
<ul>
<li><code>intset</code>保存的整数值个数超过<code>server.set_max_intset_entries</code> （默认512）</li>
<li>试图往集合添加一个新元素，并且这个元素不能被表示为<code>long long</code>类型</li>
</ul>
</li>
</ul>
<h5 id="353-字典编码的集合" class="headerLink"><a href="#353-%e5%ad%97%e5%85%b8%e7%bc%96%e7%a0%81%e7%9a%84%e9%9b%86%e5%90%88" class="header-mark"></a>3.5.3 字典编码的集合</h5><ul>
<li>当使用<code>REDIS_ENCODING_HT</code>编码时，集合将元素保存在字典的键里面，值统一为NULL</li>
</ul>
<h5 id="354-集合命令的实现" class="headerLink"><a href="#354-%e9%9b%86%e5%90%88%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>3.5.4 集合命令的实现</h5><ul>
<li>主要对<code>intset</code>和<code>dict</code>两个数据结构的操作函数的包装，以及一些两种编码之间进行转换的函数</li>
</ul>
<h5 id="355-求交集算法" class="headerLink"><a href="#355-%e6%b1%82%e4%ba%a4%e9%9b%86%e7%ae%97%e6%b3%95" class="header-mark"></a>3.5.5 求交集算法</h5><ul>
<li><code>SINTER</code>  <code>SINTERSTORE</code></li>
<li>O(n^2)</li>
</ul>
<h5 id="356-求并集算法" class="headerLink"><a href="#356-%e6%b1%82%e5%b9%b6%e9%9b%86%e7%ae%97%e6%b3%95" class="header-mark"></a>3.5.6 求并集算法</h5><ul>
<li><code>SUNION</code>  <code>SUNIONSTORE</code></li>
<li>O(n)</li>
</ul>
<h5 id="357-求差集算法" class="headerLink"><a href="#357-%e6%b1%82%e5%b7%ae%e9%9b%86%e7%ae%97%e6%b3%95" class="header-mark"></a>3.5.7 求差集算法</h5><ul>
<li><code>SDIFF</code>  <code>SDIFFSTORE</code></li>
<li>O(n^2)</li>
</ul>
<h4 id="36-有序集" class="headerLink"><a href="#36-%e6%9c%89%e5%ba%8f%e9%9b%86" class="header-mark"></a>3.6 有序集</h4><p><code>REDIS_SET</code>是<code>ZADD</code>、<code>ZCOUNT</code>等命令的操作对象，它使用<code>REDIS_ENCODING_ZIPLIST</code>和<code>REDIS_ENCODING_SKIPLIST</code>两种方式编码：</p>
<h5 id="361-编码的选择" class="headerLink"><a href="#361-%e7%bc%96%e7%a0%81%e7%9a%84%e9%80%89%e6%8b%a9" class="header-mark"></a>3.6.1 编码的选择</h5><ul>
<li>通过<code>ZADD</code>添加第一个元素到空<code>key</code>时，决定
<ul>
<li>满足以下条件，使用<code>REDIS_ENCODING_ZIPLIST</code>
<ul>
<li>服务器属性<code>server.zset_max_ziplist_entries</code>的值大于0 （默认128）</li>
<li>元素的<code>member</code>长度小于服务器属性<code>server.zset_max_ziplist_value</code>的值（默认64）</li>
</ul>
</li>
<li>否则，创建<code>REDIS_ENCODING_SKIPLIST</code>编码的有序集</li>
</ul>
</li>
</ul>
<h5 id="362-编码的转换" class="headerLink"><a href="#362-%e7%bc%96%e7%a0%81%e7%9a%84%e8%bd%ac%e6%8d%a2" class="header-mark"></a>3.6.2 编码的转换</h5><ul>
<li><code>REDIS_ENCODING_ZIPLIST</code>转换为<code>REDIS_ENCODING_SKIPLIST</code>，满足以下任一条件：
<ul>
<li><code>ziplist</code>所保存的元素超过<code>server.zset_max_ziplist_entries</code> （默认128）</li>
<li>新添加元素<code>member</code>的长度大于<code>server.zset_max_ziplist_value</code> （默认64）</li>
</ul>
</li>
</ul>
<h5 id="363-ziplist编码的有序集" class="headerLink"><a href="#363-ziplist%e7%bc%96%e7%a0%81%e7%9a%84%e6%9c%89%e5%ba%8f%e9%9b%86" class="header-mark"></a>3.6.3 ZIPLIST编码的有序集</h5><ul>
<li>每个有序集元素以两个相邻的<code>ziplist</code>节点表示，第一个节点保存元素的<code>member</code>域，第二个元素保存元素的<code>score</code>域</li>
<li>多个元素之间按<code>score</code>值从小到大排序，如果两个元素的<code>score</code>相同，那么按字典序对<code>member</code>进行对比，决定元素顺序</li>
</ul>
<p>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210712145033.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210712145033.png"
         title="20210712145033.png"
    /></p>
<ul>
<li>查找复杂度O(n)</li>
<li>添加/删除/更新复杂度都不低于O(n)</li>
</ul>
<h5 id="364-skiplist编码的有序集" class="headerLink"><a href="#364-skiplist%e7%bc%96%e7%a0%81%e7%9a%84%e6%9c%89%e5%ba%8f%e9%9b%86" class="header-mark"></a>3.6.4 SKIPLIST编码的有序集</h5><ul>
<li>
<p>当使用<code>REDIS_ENCODING_SKIPLIST</code>编码时，有序集元素由<code>redis.h/zset</code>结构来保存：</p>
<ul>
<li>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#204a87;font-weight:bold">struct</span>  <span style="color:#000">zset</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000">dict</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">dict</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 字典
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">zskiplist</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">zsl</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 跳跃表
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">}</span> <span style="color:#000">zset</span><span style="color:#000;font-weight:bold">;</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p><code>zset</code>同时使用字典和跳跃表两个数据结构来保存有序集元素</p>
</li>
<li>
<p>元素的成员由一个<code>redisObject</code>结构表示，元素的<code>score</code>则是一个<code>double</code>类型的浮点数，字典和跳跃表两个结构通过将指针共同指向这两个值来节约空间</p>
</li>
<li>
<p>字典结构：<code>member</code>作为键，<code>score</code>作为值，有序集可以在O(1)负责度内：</p>
<ul>
<li>检查<code>member</code>是否存在</li>
<li>取出<code>member</code>对应的<code>score</code>值 （<code>ZSCORE</code>）</li>
</ul>
</li>
<li>
<p>跳跃表：可以让有序集支持一下操作：</p>
<ul>
<li>O(logN)期望时间、O(n)最坏时间内根据<code>score</code>对<code>member</code>进行定位</li>
<li>范围行查找和处理操作  <code>ZRANGE</code>  <code>ZRANK</code>  <code>ZINTERSTORE</code>等</li>
</ul>
</li>
</ul>
<h3 id="4功能的实现" class="headerLink"><a href="#4%e5%8a%9f%e8%83%bd%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>4、功能的实现</h3><h4 id="41-事务" class="headerLink"><a href="#41-%e4%ba%8b%e5%8a%a1" class="header-mark"></a>4.1 事务</h4><ul>
<li>Redis通过<code>MULTI</code>、<code>DISCARD</code>、<code>EXEC</code>、<code>WATCH</code>四个命令来实现事务功能</li>
</ul>
<h5 id="411-事务" class="headerLink"><a href="#411-%e4%ba%8b%e5%8a%a1" class="header-mark"></a>4.1.1 事务</h5><ul>
<li>
<p>事务提供一种“将多个命令打包，然后一次性、按顺序地执行”的机制，并且事务在执行期间不会主动终端&mdash;服务器在执行完事务中所有的命令后，才会继续处理其他客户端的其他命令</p>
</li>
<li>
<p>事务执行阶段</p>
<ol>
<li>开始事务</li>
<li>命令入队</li>
<li>执行事务</li>
</ol>
</li>
</ul>
<h5 id="412-开始事务" class="headerLink"><a href="#412-%e5%bc%80%e5%a7%8b%e4%ba%8b%e5%8a%a1" class="header-mark"></a>4.1.2 开始事务</h5><ul>
<li><code>WATCH</code>命令的执行标记着事务的开始</li>
<li>这个命令唯一做的，将客户端<code>REDIS_MULTI</code>选项打开，让客户端从非事务状态切换到事务状态</li>
</ul>
<h5 id="413-命令入队" class="headerLink"><a href="#413-%e5%91%bd%e4%bb%a4%e5%85%a5%e9%98%9f" class="header-mark"></a>4.1.3 命令入队</h5><ul>
<li>当客户端处于<code>非事务状态</code>时，所有发送给服务端的命令都会立即被执行</li>
<li>当客户端处于<code>事务状态</code>时，服务器在收到客户端命令时，不会立即执行，而是将这些命令全部让如一个事务队列，然后返回<code>QUEUED</code>，表示命令已入队</li>
<li>事务队列是一个数组，每个元素包含三个属性
<ul>
<li>要执行的命令（cmd）</li>
<li>命令的参数（argv）</li>
<li>参数的个数（argc）</li>
</ul>
</li>
</ul>
<h5 id="414-执行事务" class="headerLink"><a href="#414-%e6%89%a7%e8%a1%8c%e4%ba%8b%e5%8a%a1" class="header-mark"></a>4.1.4 执行事务</h5><ul>
<li>不是所有命令都会被放入事务队列：<code>EXEC</code>、<code>DISCARD</code>、<code>MULTI</code>、<code>WATCH</code>这四个命令会被立即执行</li>
<li>当<code>EXEC</code>命令执行时
<ul>
<li>服务器根据客户端所保存的事务队列，以先进先出（FIFO）方式执行</li>
</ul>
</li>
</ul>
<h5 id="415-在事务和非事务状态下执行命令" class="headerLink"><a href="#415-%e5%9c%a8%e4%ba%8b%e5%8a%a1%e5%92%8c%e9%9d%9e%e4%ba%8b%e5%8a%a1%e7%8a%b6%e6%80%81%e4%b8%8b%e6%89%a7%e8%a1%8c%e5%91%bd%e4%bb%a4" class="header-mark"></a>4.1.5 在事务和非事务状态下执行命令</h5><ul>
<li>无论事务状态还是非事务状态，Redis命令都是由同一个函数执行，所以他们共享服务器一般配置，比如<code>AOF</code>配置、<code>RDB</code>配置以及内存限制等</li>
<li>事务中的命令和普通命令区别：
<ul>
<li>非事务状态下的命令以单个命令为单位执行，前一个命令和后一个的客户端不一定是同一个；事务状态则是以事务为单位：除非当前事务执行完毕，否则服务器不会中断事务，也不会执行其他客户端的其他命令。</li>
<li>非事务状态下，执行命令结果立即返回给客户端；事务状态下所有命令的结果集合到回复队列，在做<code>EXEC</code>命令的结果返回客户端。</li>
</ul>
</li>
</ul>
<h5 id="416-事务状态下的discardmultiwatch" class="headerLink"><a href="#416-%e4%ba%8b%e5%8a%a1%e7%8a%b6%e6%80%81%e4%b8%8b%e7%9a%84discardmultiwatch" class="header-mark"></a>4.1.6 事务状态下的DISCARD、MULTI、WATCH</h5><ul>
<li><code>DISCARD</code>用于取消一个事务，清空客户端的整个事务队列，然后将客户端从事务状态调整回非事务状态，最后返回OK</li>
<li>Redis的事务不可嵌套。事务状态下发送<code>MULTI</code>，服务器只是简繁返回错误，然后继续等待其他命令入队。不会造成事务失败或修改</li>
<li><code>WATCH</code>只能在客户端进入事务之前执行，否则会引发错误。但它不会造成事务失败，也不会修改事务队列已有数据。</li>
</ul>
<h5 id="417-带watch的事务" class="headerLink"><a href="#417-%e5%b8%a6watch%e7%9a%84%e4%ba%8b%e5%8a%a1" class="header-mark"></a>4.1.7 带WATCH的事务</h5><ul>
<li><code>WATCH</code>命令用于在事务开始之前监视任意数量的键：当调用<code>EXEC</code>命令执行事务时，如果任意一个被监视的键已经被其他客户端修改了，那么整个事务不在执行，直接返回失败。</li>
</ul>
<h5 id="418-watch命令的实现" class="headerLink"><a href="#418-watch%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>4.1.8 WATCH命令的实现</h5><ul>
<li>在每个数据库<code>redis.h/redisDb</code>的数据类型中，保存了一个<code>watched_keys</code>字典，字典的键时整个数据库被监视的键，字典的值则是一个链表，链表中保存了所有监视这个键的客户端。</li>
<li><code>WATCH</code>命令的作用就是：将当前客户端和要监视的键在<code>watched_keys</code>中进行关联</li>
</ul>
<h5 id="419-watch的触发" class="headerLink"><a href="#419-watch%e7%9a%84%e8%a7%a6%e5%8f%91" class="header-mark"></a>4.1.9 WATCH的触发</h5><ul>
<li>在任何对数据库键空间进行修改的命令成功执行之后，<code>multi.c/touchWatchKey</code>函数都会被调用，它检查数据库的<code>watched_keys</code>字典，看是否有客户端在监视已经被命令修改的键，如果有，程序将所有监视这个键的客户端的<code>REDIS_DIRTY_CAS</code>选项打开</li>
<li>当客户端发送<code>EXEC</code>命令、出发事务执行时，会对客户端状态进行检查
<ul>
<li>如果<code>REDIS_DIRTY_CAS</code>被打开，直接返回空回复，表示事物执行失败</li>
<li>如果<code>REDIS_DIRTY_CAS</code>没有打开，说明安全，正式执行事务</li>
</ul>
</li>
<li>最后，当一个客户端结束他的事务时，无论事务成功失败，<code>watched_keys</code>字典中和这个客户端有关的资料都会别清除</li>
</ul>
<h5 id="4110-事务的acid性质" class="headerLink"><a href="#4110-%e4%ba%8b%e5%8a%a1%e7%9a%84acid%e6%80%a7%e8%b4%a8" class="header-mark"></a>4.1.10 事务的ACID性质</h5><ul>
<li>原子性（Atomicity）
<ul>
<li>单个Redis命令的执行事原子性的，但Redis没有在事务上增加任何维持原子性的机制，所以Redis事务不是原子性的</li>
<li>如果一个事务队列所有命令都被成功执行，那么称这个事务执行成功</li>
<li>如果Redis服务器进程在执行事务过程中被停止，那么事务执行失败</li>
<li>事务失败时，Redis也不会进行任何的重试或者回滚操作</li>
</ul>
</li>
<li>一致性（Consistency）
<ul>
<li>Redis的一致性：入队错误、执行错误、Redis进程被终结</li>
<li>入队错误
<ul>
<li>在命令入队时，如果客户端发送错误的命令，服务端会向客户端返回一个出错信息，并且将客户端的事务状态设置为<code>REDIS_DIRTY_EXEC</code></li>
<li>当客户端执行<code>EXEC</code>时，Redis拒绝执行状态为<code>REDIS_DIRTY_EXEC</code>的事务，并返回失败信息</li>
<li>因此，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性</li>
</ul>
</li>
<li>执行错误
<ul>
<li>如果命令在事务执行过程中发生错误，Redis只会将错误包含在事务的结果中，不会引起事务的中断或整个失败</li>
<li>不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令</li>
<li>所以它对事务的一致性没有影响</li>
</ul>
</li>
<li>Redis进程被终结
<ul>
<li>根据Redis持久化模式：
<ul>
<li>内存模式：没有任何持久化机制，重启后数据库总是空白，所以数据总是一致</li>
<li>RDB模式：事务进行中，不会中断Redis执行保存RDB保存工作，所以数据库是一致的</li>
<li>AOF模式：因为AOF后台进行：
<ol>
<li>事务语句未被写入AOF文件，还原后是一致的</li>
<li>事务语句被写入AOF文件。重启Redis，程序会检测AOF文件并不完整，Redis会退出，并报告错误。需要使用<code>redis-check-aof</code>工具将部分成功事务命令移除之后，才能再次启动服务器。还原后是一致的</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>隔离性（Isolation）
<ul>
<li>Redis是单进程程序，并且保证执行事务时不会对事务进行中断，所以具有隔离性</li>
</ul>
</li>
<li>持久性（Durability）
<ul>
<li>因为事务只是用队列包裹了一组Redis命令，没有提供任何额外的持久性功能，所以事务的持久性由Redis所使用的的持久化模式决定
<ul>
<li>内存模式：不持久</li>
<li>RDB模式：不持久</li>
<li>AOF模式：异步保存有时间间隔，也不持久</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4111-小结" class="headerLink"><a href="#4111-%e5%b0%8f%e7%bb%93" class="header-mark"></a>4.1.11 小结</h5><ul>
<li>事务提供一种将多个命令打包，然后一次性、有序地执行的机制</li>
<li>事务执行过程中不会被中断，所有事务命令执行完之后，事务才能结束</li>
<li>多个命令会被入队到事务队列中，然后按先进先出（<code>FIFO</code>）的顺序执行。</li>
<li>带<code>WATCH</code>命令的事务会将客户端和被监视的键在数据库的 <code>watched_keys</code> 字典中进行关 联，当键被修改时，程序会将所有监视被修改键的客户端的 <code>REDIS_DIRTY_CAS</code> 选项打开。</li>
<li>只有在客户端的 <code>REDIS_DIRTY_CAS</code> 选项未被打开时，才能执行事务，否则事务直接返回 失败。</li>
<li>Redis 的事务保证了 ACID 中的一致性（C）和隔离性（I），但并不保证原子性（A）和 持久性（D）。</li>
</ul>
<h4 id="42-订阅与发布" class="headerLink"><a href="#42-%e8%ae%a2%e9%98%85%e4%b8%8e%e5%8f%91%e5%b8%83" class="header-mark"></a>4.2 订阅与发布</h4><ul>
<li>Redis通过<code>PUBLISH</code>、<code>SUBSCRIBE</code>等命令实现了订阅与发布模式</li>
</ul>
<h5 id="421-频道的订阅与信息发送" class="headerLink"><a href="#421-%e9%a2%91%e9%81%93%e7%9a%84%e8%ae%a2%e9%98%85%e4%b8%8e%e4%bf%a1%e6%81%af%e5%8f%91%e9%80%81" class="header-mark"></a>4.2.1 频道的订阅与信息发送</h5><ul>
<li><code>SUBSCRIBE</code>命令可以让客户端订阅任意数量的频道</li>
<li>当有消息通过<code>PUBLISH</code>命令发送给频道时，这个消息就会被发送给订阅他的所有客户端</li>
</ul>
<h5 id="422-订阅频道" class="headerLink"><a href="#422-%e8%ae%a2%e9%98%85%e9%a2%91%e9%81%93" class="header-mark"></a>4.2.2 订阅频道</h5><ul>
<li>
<p>每个Redis服务器进程都维持这个一个表示服务器状态的<code>redis.h/redisServer</code>结构，结构的<code>pubsub_channels</code>属性是一个字典，用于保存订阅频道的信息</p>
<ul>
<li>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">redisSercer</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000">dict</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">pubsub_channels</span><span style="color:#000;font-weight:bold">;</span>
<span style="color:#000;font-weight:bold">}</span>
</code></pre></div></li>
<li>
<p>字典的键为正在被订阅的频道，值为一个链表，保存了所有订阅这个频道的客户端</p>
</li>
<li>
<p>当客户端调用<code>SUBSCRIBE</code>时，程序就将客户端和要订阅的频道在<code>pubsub_channels</code>字典中关联起来</p>
</li>
</ul>
</li>
</ul>
<h5 id="423-发送信息到频道" class="headerLink"><a href="#423-%e5%8f%91%e9%80%81%e4%bf%a1%e6%81%af%e5%88%b0%e9%a2%91%e9%81%93" class="header-mark"></a>4.2.3 发送信息到频道</h5><ol>
<li>首先根据<code>channel</code>定位到字典的键</li>
<li>将信息发送给字典链表中的所有客户端</li>
</ol>
<h5 id="424-退订频道" class="headerLink"><a href="#424-%e9%80%80%e8%ae%a2%e9%a2%91%e9%81%93" class="header-mark"></a>4.2.4 退订频道</h5><ul>
<li><code>UNSUBSCRIBE</code>，从<code>pubsub_channels</code>字典的给定频道（键）中，删除关于当前客户端的信息</li>
</ul>
<h5 id="425-模式的订阅与信息发送" class="headerLink"><a href="#425-%e6%a8%a1%e5%bc%8f%e7%9a%84%e8%ae%a2%e9%98%85%e4%b8%8e%e4%bf%a1%e6%81%af%e5%8f%91%e9%80%81" class="header-mark"></a>4.2.5 模式的订阅与信息发送</h5><h5 id="426-订阅模式" class="headerLink"><a href="#426-%e8%ae%a2%e9%98%85%e6%a8%a1%e5%bc%8f" class="header-mark"></a>4.2.6 订阅模式</h5><ul>
<li>
<p><code>redisServer.pubsub_patterns</code>属性是一个链表，保存着所有和模式先关的信息</p>
<ul>
<li>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">redisServer</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000">list</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">pubsub_patterns</span><span style="color:#000;font-weight:bold">;</span>
<span style="color:#000;font-weight:bold">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>链表的每个节点都包含一个<code>redis.h/pubsubPattern</code>结构</p>
<ul>
<li>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">pubsubPattern</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000">redisClient</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">client</span><span style="color:#000;font-weight:bold">;</span>  <span style="color:#8f5902;font-style:italic">// 订阅模式的客户端
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">robj</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">pattern</span><span style="color:#000;font-weight:bold">;</span>  <span style="color:#8f5902;font-style:italic">// 被订阅的模式
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">}</span> <span style="color:#000">pubsubPattern</span><span style="color:#000;font-weight:bold">;</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>调用<code>PSUBSCRIBE</code>时，程序就创建一个包含客户端和被订阅模式的<code>pubsubPattern</code>结构，并将该结构添加到<code>redisServer.pubsub_patterns</code>链表中</p>
</li>
</ul>
<h5 id="427-发送信息到模式" class="headerLink"><a href="#427-%e5%8f%91%e9%80%81%e4%bf%a1%e6%81%af%e5%88%b0%e6%a8%a1%e5%bc%8f" class="header-mark"></a>4.2.7 发送信息到模式</h5><ul>
<li><code>PUBLISH</code></li>
</ul>
<h5 id="428-退订模式" class="headerLink"><a href="#428-%e9%80%80%e8%ae%a2%e6%a8%a1%e5%bc%8f" class="header-mark"></a>4.2.8 退订模式</h5><ul>
<li><code>PUNSUBSCRIBE</code></li>
</ul>
<h5 id="429-小结" class="headerLink"><a href="#429-%e5%b0%8f%e7%bb%93" class="header-mark"></a>4.2.9 小结</h5><ul>
<li>订阅信息由服务器进程维持的<code>redisServer.pubsub_channels</code>字典保存，字典的键为被订阅的频道，字典的值为订阅频道的所有客户端</li>
<li>当有新消息发送到频道时，程序遍历频道所对应的所有客户端，然后将消息发送到订阅频道的客户端上</li>
<li>订阅模式的信息由服务器进程维持的<code>redisServer.pubsub_patterns</code>链表来保存，链表的每个节点都保存一个<code>pubsubPattern</code>结构。</li>
<li>当有新消息发送到频道时，除了订阅频道的客户端回收到消息之外，所有订阅了匹配频道的模式的客户端，也同样会收到消息</li>
<li>退订频道和退订模式分别的订阅频道和订阅模式的反操作</li>
</ul>
<h4 id="43-lua脚本" class="headerLink"><a href="#43-lua%e8%84%9a%e6%9c%ac" class="header-mark"></a>4.3 Lua脚本</h4><h5 id="431-初始化lua环境" class="headerLink"><a href="#431-%e5%88%9d%e5%a7%8b%e5%8c%96lua%e7%8e%af%e5%a2%83" class="header-mark"></a>4.3.1 初始化Lua环境</h5><ul>
<li>在初始化Redis服务器时</li>
<li>Redis对Lua环境进行了一系列修改，包括添加数据库、更换随机函数、保护全局变量等</li>
<li>初始化步骤
<ol>
<li>调用<code>lua_open</code>函数，创建一个新的Lua环境</li>
<li>载入指定的Lua函数库，包括：
<ul>
<li>基础库（<code>base lib</code>）</li>
<li>表格库（<code>table lib</code>）</li>
<li>字符串库（<code>string lib</code>）</li>
<li>数学库（<code>math lib</code>）</li>
<li>调试库（<code>debug lib</code>）</li>
<li>用于处理JSON的<code>cjson</code>库</li>
<li>在Lua值和C结构（<code>struct</code>）之间进行转换的<code>struct</code>库</li>
<li>处理<code>MessagePack</code>数据的<code>cmsgpack</code>库</li>
</ul>
</li>
<li>屏蔽一些可能对Lua环境产生安全问题的函数，比如<code>loadfile</code></li>
<li>创建一个Redis字典，保存Lua脚本，并在复制（<code>replication</code>）脚本时使用。字典的键为SHA1校验和，字典的值为Lua脚本</li>
<li>创建一个redis全局表格到Lua环境，表格中包含了各种对Redis进行操作的函数</li>
<li>用Redis自己定义的随机生成函数，替换<code>math</code>表原有的<code>math.random</code>函数和<code>math.randommseed</code>函数</li>
<li>创建一个对Redis多批量回复（<code>multi bulk reply</code>）进行排序的辅助函数</li>
<li>对Lua环境中的全局变量进行保护，以免被传入的脚本修改</li>
<li>因为Redis命令必须客户端执行，所以需要在服务器状态中创建一个无网络链接的伪客户端（<code>fake client</code>），专门用于执行Lua脚本中包含的Redis命令。</li>
<li>将Lua环境的指针记录到Redis服务器的全局状态中，等候Redis的调用。</li>
</ol>
</li>
</ul>
<h5 id="432-脚本的安全性" class="headerLink"><a href="#432-%e8%84%9a%e6%9c%ac%e7%9a%84%e5%ae%89%e5%85%a8%e6%80%a7" class="header-mark"></a>4.3.2 脚本的安全性</h5><ul>
<li>问题
<ul>
<li>如果一段Lua脚本带有随机性质或作用，那么当这段脚本在附属节点运行时，或者从AOF文件载入重新运行时，带到的结果可能和之前运行的结果完全不同</li>
</ul>
</li>
<li>解决
<ul>
<li>Redis对Lua环境所能执行的脚本做了一个严格的限制：所有的脚本都必须是无副作用的纯函数（<code>pure function</code>）</li>
</ul>
</li>
<li>策略
<ul>
<li>不提供访问系统状态的库（比如系统时间库）</li>
<li>进制使用<code>loadfile</code>函数</li>
<li>阻止带有随机性质命令的脚本执行</li>
<li>如果脚本执行带有随机命令的读，会先被执行一个自动的字典序排序，保证输出结果有序</li>
<li>用Redis自己定义的随机生成函数，替换Lua环境中<code>math</code>表原有的随机函数。新函数性质：每次执行Lua脚本，除非显式地调用<code>math.randomseed</code>，否则<code>math.random</code> 生成的伪随机数序列总是相同的。</li>
</ul>
</li>
<li>保证：
<ul>
<li>无副作用</li>
<li>没有有害的随机性</li>
<li>对于同样的输入参数和数据集，总是产生相同的写入命令</li>
</ul>
</li>
</ul>
<h5 id="433-脚本的执行" class="headerLink"><a href="#433-%e8%84%9a%e6%9c%ac%e7%9a%84%e6%89%a7%e8%a1%8c" class="header-mark"></a>4.3.3 脚本的执行</h5><ul>
<li><code>EVAL</code>、<code>EVALSHA</code> 执行Lua脚本</li>
<li><code>EVALSHA</code>基于<code>EVAL</code></li>
</ul>
<h5 id="434-eval命令的实现" class="headerLink"><a href="#434-eval%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>4.3.4 EVAL命令的实现</h5><ul>
<li>
<p><code>EVAL</code>的执行分为以下步骤：</p>
<ul>
<li>为输入脚本定义一个Lua函数</li>
<li>执行这个Lua函数</li>
</ul>
</li>
<li>
<p>定义Lua函数</p>
<ul>
<li>
<p>函数名以<code>f_</code>为前缀，后跟脚本的<code>SHA1</code>校验和</p>
<ul>
<li>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8f5902;font-style:italic">// EVAL &#34;return &#39;hello world&#39;&#34; 0
</span><span style="color:#8f5902;font-style:italic"></span>      
<span style="color:#000">function</span> <span style="color:#000">f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91</span><span style="color:#000;font-weight:bold">()</span> 
  <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#a40000">&#39;</span><span style="color:#000">hello</span> <span style="color:#000">world</span><span style="color:#a40000">&#39;</span> <span style="color:#000">end</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>好处：</p>
<ul>
<li>执行步骤简单，只要调用和脚本相对应的函数</li>
<li>Lua环境保持清洁，已有的脚本和新加入的脚本不会互相干扰，可以将重置Lua环境和调用Lua GC的次数降到最低</li>
<li>如果某个脚本对应的函数的Lua被定义过，只需要记得这个脚本的<code>SHA1</code>校验和</li>
</ul>
</li>
</ul>
</li>
<li>
<p>执行Lua函数</p>
<ol>
<li>将<code>EVAL</code>命令输入的<code>KEYS</code>参数和<code>ARGV</code>参数以全局数组的方式传入到Lua环境中</li>
<li>设置伪客户端的目标数据为调用者客户端的目标数据库</li>
<li>为Lua环境装载超时钩子，保证脚本执行超时可以杀死脚本，或者停止Redis服务器</li>
<li>执行脚本对应的Lua函数</li>
<li>如果脚本有<code>SELECT</code>命令，那么需要对调用者客户端的目标数据库进行更新</li>
<li>执行清理操作：清除钩子；清除指向调用者客户端的指针等</li>
<li>将Lua函数指定所得结果转换成Redis回复，传给客户端</li>
<li>对Lua环境进行一次单步的渐进式GC</li>
</ol>
</li>
</ul>
<h5 id="435-evalsha命令的实现" class="headerLink"><a href="#435-evalsha%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>4.3.5 EVALSHA命令的实现</h5><ul>
<li>只要脚本对应的函数在Lua里定义过，即使用户不知道脚本的内容本身，也可以直接通过脚本的<code>SHA1</code>校验和来掉调用</li>
</ul>
<h5 id="436-小结" class="headerLink"><a href="#436-%e5%b0%8f%e7%bb%93" class="header-mark"></a>4.3.6 小结</h5><ul>
<li>初始化Lua脚本环境需要一系列步骤</li>
<li>Redis通过一系列措施保证Lua脚本无副作用，也没有有害的写随机性</li>
<li><code>EVAL</code>命令为输入脚本定义一个Lua函数，然后通过函数执行脚本</li>
<li><code>EVALSHA</code>通过构建函数名，直接调用Lua中定义的函数，从而执行脚本</li>
</ul>
<h4 id="44-慢查询日志" class="headerLink"><a href="#44-%e6%85%a2%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97" class="header-mark"></a>4.4 慢查询日志</h4><ul>
<li>慢查询日志是Redis提供的一个用于观察系统性能的功能</li>
</ul>
<h5 id="441-相关数据结构" class="headerLink"><a href="#441-%e7%9b%b8%e5%85%b3%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="header-mark"></a>4.4.1 相关数据结构</h5><ul>
<li>慢日志结构定义：</li>
</ul>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8f5902;font-style:italic">// slowlog.h/slowlogEntry
</span><span style="color:#8f5902;font-style:italic"></span>
<span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">slowlogEntry</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000">robj</span> <span style="color:#ce5c00;font-weight:bold">**</span><span style="color:#000">argv</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 命令参数
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">int</span> <span style="color:#000">argc</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 命令参数数量
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">long</span> <span style="color:#204a87;font-weight:bold">long</span> <span style="color:#000">id</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 唯一标识符
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">long</span> <span style="color:#204a87;font-weight:bold">long</span> <span style="color:#000">duration</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 执行消耗的时间，以纳秒为单位
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">time_t</span> <span style="color:#000">time</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 命令执行时间
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">}</span> <span style="color:#000">slowlogEntry</span><span style="color:#000;font-weight:bold">;</span>
</code></pre></div><ul>
<li>
<p>记录服务器状态的<code>redis.h/redisServer</code>结构</p>
<ul>
<li>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">redisServer</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000">list</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">slowlog</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 保存慢查询日志的链表
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">long</span> <span style="color:#204a87;font-weight:bold">long</span> <span style="color:#000">slowlog_entry_id</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 慢查询日志当前id值
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">long</span> <span style="color:#204a87;font-weight:bold">long</span> <span style="color:#000">slowlog_log_slower_than</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 慢查询时间限制
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">unsigned</span> <span style="color:#204a87;font-weight:bold">long</span> <span style="color:#000">slowlog_max_len</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 慢查询日志最大条目数量
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">}</span>
</code></pre></div></li>
<li>
<p><code>slowlog</code>从新到旧排序链表</p>
</li>
<li>
<p><code>slowlog_entry_id</code>在创建慢日志后加一，用于产生慢查询日志ID（<code>SLOW LOG</code>之后被重置）</p>
</li>
<li>
<p><code>slowlog_log_slower_than</code>：命令执行时间上限</p>
</li>
<li>
<p><code>slowlog_max_len</code>：日志数量等于这个值，添加新日志，最旧的日志会被删除</p>
</li>
</ul>
</li>
</ul>
<h5 id="442-慢查询日志的记录" class="headerLink"><a href="#442-%e6%85%a2%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97%e7%9a%84%e8%ae%b0%e5%bd%95" class="header-mark"></a>4.4.2 慢查询日志的记录</h5><ul>
<li>Redis记录命令执行前的时间，执行完成后计算耗费时间<code>duration</code>，并传给<code>slowlogPushEntryIfNeed</code>函数</li>
<li>如果<code>duration</code>超过<code>server.slowlog_log_slower_than</code>，<code>slowlogPushEntryIfNeed</code>就会创建一条心的慢查询日志，加入慢查询日志链表</li>
</ul>
<h5 id="443-慢查询日志的操作" class="headerLink"><a href="#443-%e6%85%a2%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97%e7%9a%84%e6%93%8d%e4%bd%9c" class="header-mark"></a>4.4.3 慢查询日志的操作</h5><ul>
<li>查看日志 O(n)</li>
<li>清空日志 O(n)</li>
<li>获取日志数量 O(1)</li>
</ul>
<h5 id="444-小结" class="headerLink"><a href="#444-%e5%b0%8f%e7%bb%93" class="header-mark"></a>4.4.4 小结</h5><ul>
<li>Redis用一个链表以<code>FIFO</code>的顺序保存所有的慢查询日志</li>
<li>每条慢查询日志记录执行超时的命令、命令的参数、命令执行时间、命令所消耗的时间等信息</li>
</ul>
<h3 id="5内部运作机制" class="headerLink"><a href="#5%e5%86%85%e9%83%a8%e8%bf%90%e4%bd%9c%e6%9c%ba%e5%88%b6" class="header-mark"></a>5、内部运作机制</h3><h4 id="51-数据库" class="headerLink"><a href="#51-%e6%95%b0%e6%8d%ae%e5%ba%93" class="header-mark"></a>5.1 数据库</h4><h5 id="511-数据库的结构" class="headerLink"><a href="#511-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e7%bb%93%e6%9e%84" class="header-mark"></a>5.1.1 数据库的结构</h5><ul>
<li>
<p>Redis中的每个数据库，都是由一个<code>redis.h/redisDb</code>结构表示：</p>
<ul>
<li>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">redisDb</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#204a87;font-weight:bold">int</span> <span style="color:#000">id</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 保存着数据库以整数表示的号码
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">dict</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">dict</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 保存着数据库中的所有键值对数据。也被称为键空间
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">dict</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">expires</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 保存着键的过期信息
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">dict</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">blocking_keys</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 实现列表阻塞原语
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">dict</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">ready_keys</span><span style="color:#000;font-weight:bold">;</span>
      
  <span style="color:#000">dict</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">watched_keys</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic">// 用于MATCH命令。事务
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">}</span> <span style="color:#000">redisDb</span><span style="color:#000;font-weight:bold">;</span>
</code></pre></div></li>
</ul>
</li>
</ul>
<h5 id="512-数据库的切换" class="headerLink"><a href="#512-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e5%88%87%e6%8d%a2" class="header-mark"></a>5.1.2 数据库的切换</h5><ul>
<li><code> redisDb</code>结构的<code>id</code>保存着数据库的号码</li>
<li>Redis初始化时，会创建<code>redis.h/REDIS_DEFAULT_DBNUM</code>个数据库，并将所有数据库保存到<code>redis.h/redisServer.db</code>数组中，每个数据库<code>id</code>从0到<code>REDIS_DEFAULT_DBNUM - 1</code></li>
<li>当执行<code>SELECT number</code>时，程序使用<code>redisServer.db[number]</code>来切换数据库</li>
</ul>
<h5 id="513-数据库键空间" class="headerLink"><a href="#513-%e6%95%b0%e6%8d%ae%e5%ba%93%e9%94%ae%e7%a9%ba%e9%97%b4" class="header-mark"></a>5.1.3 数据库键空间</h5><ul>
<li>Redis是键值对数据库，所以它的数据库本身也是一个字典(<code>key space</code>)
<ul>
<li>字典的键是一个字符串对象</li>
<li>字典的值则可以使包括字符串、列表、哈希表、集合、有序集在内的任意一种Redsi类型对象</li>
</ul>
</li>
<li><code>redisDb</code>结构的<code>dict</code>属性，保存着数据库所有的键值对数据</li>
</ul>
<h5 id="514-键空间的操作" class="headerLink"><a href="#514-%e9%94%ae%e7%a9%ba%e9%97%b4%e7%9a%84%e6%93%8d%e4%bd%9c" class="header-mark"></a>5.1.4 键空间的操作</h5><ul>
<li>
<p>因为数据库本身是一个字典，所以对数据库的操作基本上都是对字典的操作，加上一些维护操作</p>
</li>
<li>
<p>添加新键</p>
</li>
<li>
<p>删除键</p>
</li>
<li>
<p>更新键</p>
</li>
<li>
<p>取值</p>
</li>
<li>
<p>其他操作</p>
<ul>
<li><code>FLUSHDB</code></li>
<li><code>RANDOMKEY</code></li>
<li><code>DBSIZE</code></li>
<li><code>EXISTS</code></li>
<li><code>RENAME</code></li>
</ul>
</li>
</ul>
<h5 id="515-键的过期时间" class="headerLink"><a href="#515-%e9%94%ae%e7%9a%84%e8%bf%87%e6%9c%9f%e6%97%b6%e9%97%b4" class="header-mark"></a>5.1.5 键的过期时间</h5><ul>
<li><code>EXPIRE</code>、<code>PEXPIRE</code>、<code>EXPIREAT</code>、<code>PEXPIREAT</code></li>
</ul>
<h5 id="516-过期时间的保存" class="headerLink"><a href="#516-%e8%bf%87%e6%9c%9f%e6%97%b6%e9%97%b4%e7%9a%84%e4%bf%9d%e5%ad%98" class="header-mark"></a>5.1.6 过期时间的保存</h5><ul>
<li><code>redisDb</code>结构的<code>expires</code>字典里
<ul>
<li><code>expires</code>字典的键是一个执行<code>dict</code>字典里某个键的指针，字典的值是过期时间<code>long long</code>类型</li>
</ul>
</li>
</ul>
<h5 id="517-设置生存时间" class="headerLink"><a href="#517-%e8%ae%be%e7%bd%ae%e7%94%9f%e5%ad%98%e6%97%b6%e9%97%b4" class="header-mark"></a>5.1.7 设置生存时间</h5><ul>
<li>Redis有四个命令设置键的生存时间和过期时间</li>
<li>但是，<code>expires</code>字典的值只保存“以毫秒为单位的过期UNIX时间戳”</li>
</ul>
<h5 id="518-过期键的判定" class="headerLink"><a href="#518-%e8%bf%87%e6%9c%9f%e9%94%ae%e7%9a%84%e5%88%a4%e5%ae%9a" class="header-mark"></a>5.1.8 过期键的判定</h5><ul>
<li>通过<code>expires</code>字典，通过以下步骤检查
<ol>
<li>检查键是否在<code>expires</code>字典；如果存在，那么取出键的过期时间</li>
<li>通过与当前UNIX时间戳对比没判断是否过期</li>
</ol>
</li>
</ul>
<h5 id="519-过期键的清除" class="headerLink"><a href="#519-%e8%bf%87%e6%9c%9f%e9%94%ae%e7%9a%84%e6%b8%85%e9%99%a4" class="header-mark"></a>5.1.9 过期键的清除</h5><ul>
<li>三种删除方式
<ul>
<li>定时删除：在设置键的过期时间时，创建一个定时事件，当过期时间到达时，由事件处理器自动执行键的删除操作</li>
<li>惰性删除：放任键过期不管，但是在每次从<code>dict</code>字典取出键时，检查是否过期，过期则删除并返回空</li>
<li>定期删除：每隔一段时间，对<code>expires</code>字典进行检查，删除过期键</li>
</ul>
</li>
<li>定时删除
<ul>
<li>对内存最友好：因为能保证过期键第一时间被删除</li>
<li>缺点：
<ul>
<li>对CPU时间最不友好：因为删除操作可能会占用大量的CPU时间</li>
<li>目前Redis事件处理器对时间事件的实现方式&ndash;无序链表，查找复杂度O(n)，不适合用来处理大量时间事件</li>
</ul>
</li>
</ul>
</li>
<li>惰性删除
<ul>
<li>对CPU最友好：只会在取出键时进行检查</li>
<li>缺点
<ul>
<li>对内存最不友好：内存已知占用不被释放</li>
</ul>
</li>
</ul>
</li>
<li>定期删除
<ul>
<li>上述两种的折中策略</li>
<li>每隔一段时间执行一次删除操作，并通过限制删除操作执行的时长和频率，来减少删除操作对CPU时间的影响</li>
<li>通过定期删除过期键，有效的减少内存浪费</li>
</ul>
</li>
<li>Redis使用的策略
<ul>
<li>惰性删除 + 定期删除</li>
</ul>
</li>
</ul>
<h5 id="5110-过期键的惰性删除策略" class="headerLink"><a href="#5110-%e8%bf%87%e6%9c%9f%e9%94%ae%e7%9a%84%e6%83%b0%e6%80%a7%e5%88%a0%e9%99%a4%e7%ad%96%e7%95%a5" class="header-mark"></a>5.1.10 过期键的惰性删除策略</h5><ul>
<li><code>db.c/expireIfNeeded</code>函数。</li>
<li>所有命令在读取或写入数据库之前都会调用<code>expireIfNeeded</code>函数对键进行检查</li>
<li><code>expireIfNeeded</code>的作用是，如果输入键过期的话，将键、值、键保存在<code>expires</code>字典中的过期时间都删除掉</li>
</ul>
<h5 id="5111-过期键的定期删除策略" class="headerLink"><a href="#5111-%e8%bf%87%e6%9c%9f%e9%94%ae%e7%9a%84%e5%ae%9a%e6%9c%9f%e5%88%a0%e9%99%a4%e7%ad%96%e7%95%a5" class="header-mark"></a>5.1.11 过期键的定期删除策略</h5><ul>
<li><code>redis.c/activeExpireCycle</code>函数。</li>
<li>每当Redis的例行处理程序<code>serverCron</code>执行时，<code>activeExpireCycle</code>都会被调用</li>
<li>这个函数在规定时间限制内，尽可能地遍历各个数据库的<code>expires</code>字典，随机的检查一部分键的过期时间，并删除其中的过期键</li>
</ul>
<h5 id="5112-过期键对aofrdb和复制的影响" class="headerLink"><a href="#5112-%e8%bf%87%e6%9c%9f%e9%94%ae%e5%af%b9aofrdb%e5%92%8c%e5%a4%8d%e5%88%b6%e7%9a%84%e5%bd%b1%e5%93%8d" class="header-mark"></a>5.1.12 过期键对AOF、RDB和复制的影响</h5><ul>
<li>更新后的RDB文件
<ul>
<li>在创建RDB文件时，程序会对键进行检查，过期的键不会被写入到更新后的RDB文件中</li>
</ul>
</li>
<li>AOF文件
<ul>
<li>过期键在被惰性删除或定期删除之前，不会有任何影响，AOF不会被修改</li>
<li>过期键被删除后，程序会向AOF文件追加一条DEL命令</li>
</ul>
</li>
<li>AOF重写
<ul>
<li>重写时，程序会检查键，过期的键不会被保存到重写后的AOF文件</li>
</ul>
</li>
<li>复制
<ul>
<li>过期键的删除由主节点统一控制
<ul>
<li>如果是主节点，它删除一个过期键后，会显式地向所有附属节点发送一个<code>DEL</code>命令</li>
<li>如果是附属节点，碰到过期键，会返回已过期的回复，但是不会删除。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="5113-数据库空间的收缩和扩展" class="headerLink"><a href="#5113-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%a9%ba%e9%97%b4%e7%9a%84%e6%94%b6%e7%bc%a9%e5%92%8c%e6%89%a9%e5%b1%95" class="header-mark"></a>5.1.13 数据库空间的收缩和扩展</h5><ul>
<li>字典的 扩展/收缩规则</li>
<li><code>redis.c/tryResizeHashTables</code>函数检查数据库是否需要收缩</li>
<li>每次<code>redis.c/serverCron</code>函数运行时，被调用</li>
</ul>
<h5 id="5114-小结" class="headerLink"><a href="#5114-%e5%b0%8f%e7%bb%93" class="header-mark"></a>5.1.14 小结</h5><ul>
<li>数据库主要由<code>dict</code>和<code>expires</code>两个字典构成，<code>dict</code>保存键值对，<code>expires</code>保存键的过期时间</li>
<li>数据库的键总是一个字符串对象，值可以使任意一种Redis数据类型，包括字符串、哈希表、集合、列表、有序集</li>
<li><code>expires</code>的某个键和<code>dict</code>的某个键共同指向同一个字符串对象，而<code>expires</code>键的值则是该键以毫秒计算的UNIX过期时间戳</li>
<li>Redis使用惰性删除和定期删除两种策略来删除过期的键</li>
<li>更新后的RDB文件和重写后的AOF文件不会保留过期的键</li>
<li>当一个过期的键被删除之后，程序会追加一条新的<code>DEL</code>命令到AOF文件</li>
<li>当主节点删除一个过期键后，会显式的发送一条<code>DEL</code>命令到所有附属节点</li>
<li>附属节点发现过期键后，不会删除，而是等待主节点发来<code>DEL</code>命令，保证数据一致</li>
<li>数据库的<code>dict</code>和<code>expires</code>字典的扩展策略和普通字典一样。当填充百分比不足10%时，将可用节点数量减少至大于等于当前已用节点数量。</li>
</ul>
<h4 id="52-rdb" class="headerLink"><a href="#52-rdb" class="header-mark"></a>5.2 RDB</h4><ul>
<li>RDB核心是<code>rdbSave</code>和<code>rdbLoad</code>函数，前者用于生成RDB文件到磁盘，后者用于将RDB文件中的数据重新载入到内存</li>
</ul>
<h5 id="521-保存" class="headerLink"><a href="#521-%e4%bf%9d%e5%ad%98" class="header-mark"></a>5.2.1 保存</h5><ul>
<li>如果RDB文件已存在，新的RDB文件会替换已有的</li>
<li>RDB保存文件期间，主进程会被阻塞，知道保存完成为止</li>
<li><code>SAVE</code>直接调用<code>rdbSave</code>，阻塞Redis主进程，知道保存完成为止</li>
<li><code>BGSAVE</code>则<code>fork</code>出一个子进程，子进程负责调用<code>rdbSave</code>，并在保存完成后向主进程发送信号，通知保存已完成。</li>
</ul>
<h5 id="522-savebgsaveaof写入bgrewritefof" class="headerLink"><a href="#522-savebgsaveaof%e5%86%99%e5%85%a5bgrewritefof" class="header-mark"></a>5.2.2 SAVE、BGSAVE、AOF写入、BGREWRITEFOF</h5><ul>
<li>
<p>SAVE</p>
<ul>
<li><code>SAVE</code>执行时，新的<code>SAVE</code>、<code>BGSAVE</code>、<code>BGREWRITEAOF</code>调用不会产生任何多用</li>
<li>AOF写入是后台线程完成，<code>BGREWRITEAOF</code>由子进程完成，所以<code>SAVE</code>执行过程中，AOF写入、<code>BGREWRITEAOF</code>可以同时进行</li>
</ul>
</li>
<li>
<p>BGSAVE</p>
<ul>
<li>在指向<code>SAVE</code>之前，服务器会检查<code>BGSAVE</code>是否正在执行，如果是，不调用<code>rdbSave</code>，向客户端返回出错信息</li>
<li>当<code>BGSAVE</code>执行时，调用新的<code>BGSAVE</code>的客户端也会收到出错信息</li>
<li><code>BGSAVE</code>执行时，<code>BGREWRITEAOF</code>的重写请求会被延迟到<code>BGSAVE</code>执行完毕</li>
<li><code>BGREWRITEAOF</code>执行时，调用<code>BGSAVE</code>的客户端将收到出错信息</li>
<li><code>BGREWRITEAOF</code>和<code>BGSAVE</code>不同时执行时处于性能考虑
<ul>
<li>并发两个子进程，并且两个子进程都同时进行大量的磁盘写入，性能问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="523-载入" class="headerLink"><a href="#523-%e8%bd%bd%e5%85%a5" class="header-mark"></a>5.2.3 载入</h5><ul>
<li>Redis服务器启动时，<code>rdbLoad</code>函数就会被执行，它读取RDB文件，将文件中的数据库数据载入到内存中</li>
<li>在载入期间， 服务器每载入 1000 个键就处理一次所有已到达的请求， 不过只有 <code>PUBLISH</code> 、 <code>SUBSCRIBE</code> 、<code>PSUBSCRIBE</code> 、<code>UNSUBSCRIBE </code>、<code>PUNSUBSCRIBE</code> 五个命令的请求会被正确地处理， 其他命令一律返回错误。等到载入完成之后，服务器才会开始正常处理所有命令。
<ul>
<li>发布与订阅功能和其他数据库功能是完全隔离的，前者不写入也不读取数据库，所以 在服务器载入期间，订阅与发布功能仍然可以正常使用，而不必担心对载入数据的完整性产生 影响。</li>
</ul>
</li>
<li>AOF保存频率通常高于RDB。如果AOF功能打开会优先使用AOF文件还原数据</li>
</ul>
<h5 id="524-rdb文件结构" class="headerLink"><a href="#524-rdb%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84" class="header-mark"></a>5.2.4 RDB文件结构</h5><p>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210713154641.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210713154641.png"
         title="20210713154641.png"
    /></p>
<ul>
<li>REDIS
<ul>
<li>文件开头保存REDIS五个字符，表示RDB文件的开始</li>
</ul>
</li>
<li>RDB-VERSION
<ul>
<li>四字节长</li>
<li>记录RDB版本号（目前为0006）</li>
<li>因为不同版本的RDB文件不兼容，所以需要根据版本来选择不同的读入方式</li>
</ul>
</li>
<li>DB-DATA
<ul>
<li>重复多次出现</li>
<li>每一个<code>DB-DATA</code>部分保存着服务器上一个非空数据库的所有数据数据</li>
</ul>
</li>
<li>SELECT-DB
<ul>
<li>保存着跟在后面的键值对所属的数据库号码</li>
</ul>
</li>
<li>KEY-VALUE-PAIRS
<ul>
<li>因为空数据库不会被保存到RDB文件，所以这部分至少包含一个键值对的数据</li>
<li>键值对数据结构
<ul>
<li>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210713155253.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210713155253.png"
         title="20210713155253.png"
    /></li>
<li><code>OPTIONAL-EXPIRE-TIME</code>：记录着过期时间。可选，没有过期时间，该域不出现</li>
<li><code>KEY</code>：键。格式和<code>REDIS_ENCODING_RAW</code>编码的字符串对象一样。</li>
<li><code>TYPE-OF-VALUE</code>：记录<code>VALUE</code>域的值所使用的的编码</li>
<li><code>VALUE</code>：不同类型格式不同</li>
</ul>
</li>
</ul>
</li>
<li>EOF
<ul>
<li>标志着数据库内容的结尾，值为<code>rdb.h/EDIS_RDB_OPCODE_EOF</code></li>
</ul>
</li>
<li>CHECK-SUM
<ul>
<li>校验和。<code>uint_64t</code>类型值</li>
<li>如果为0，表示Redis关闭了校验和功能</li>
</ul>
</li>
</ul>
<h5 id="525-小结" class="headerLink"><a href="#525-%e5%b0%8f%e7%bb%93" class="header-mark"></a>5.2.5 小结</h5><ul>
<li><code>rdbSave</code> 会将数据库数据保存到 RDB 文件，并在保存完成之前阻塞调用者。</li>
<li><code>SAVE</code> 命令直接调用 <code>rdbSave</code> ，阻塞 Redis 主进程；<code>BGSAVE</code> 用子进程调用 <code>rdbSave </code>， 主进程仍可继续处理命令请求。</li>
<li><code>SAVE</code> 执行期间，AOF 写入可以在后台线程进行，<code>BGREWRITEAOF</code> 可以在子进程进行，所以这三种操作可以同时进行。</li>
<li>为了避免产生竞争条件，<code>BGSAVE</code>执行时，<code>SAVE</code> 命令不能执行。</li>
<li>为了避免性能问题，<code>BGSAVE</code> 和 <code>BGREWRITEAOF</code> 不能同时执行。</li>
<li>调用 <code>rdbLoad</code> 函数载入 RDB 文件时，不能进行任何和数据库相关的操作，不过订阅与 发布方面的命令可以正常执行，因为它们和数据库不相关联。</li>
<li>RDB 文件的组织方式</li>
<li>键值对在 RDB 文件中的组织方式
<ul>
<li>RDB 文件使用不同的格式来保存不同类型的值。</li>
</ul>
</li>
</ul>
<h4 id="53-aof" class="headerLink"><a href="#53-aof" class="header-mark"></a>5.3 AOF</h4><ul>
<li>RDB将数据库的快照以二进制方式保存到磁盘</li>
<li>AOF以协议文本方式，将所有对数据库进行过的写入命令（及参数）记录到AOF文件</li>
</ul>
<h5 id="531--aof命令同步" class="headerLink"><a href="#531--aof%e5%91%bd%e4%bb%a4%e5%90%8c%e6%ad%a5" class="header-mark"></a>5.3.1  AOF命令同步</h5><ul>
<li>同步命令到AOF文件的过程
<ol>
<li>命令传播：Redis将执行完的命令、参数、参数个数等信息发送到AOF程序中</li>
<li>缓存追加：AOF程序根据接收到的命令数据，将命令转换为网络通讯协议的格式，然后将协议内容追加到服务器的AOF缓存中</li>
<li>文件写入和保存：AOF缓存中的内容被写入AOF文件末尾，如果设定的AOF保存条件被满足的话，<code>fsync</code>函数或者<code>fdatasync</code>函数会被调用，将写入的内容真正地保存到磁盘中。</li>
</ol>
</li>
</ul>
<h5 id="532-命令传播" class="headerLink"><a href="#532-%e5%91%bd%e4%bb%a4%e4%bc%a0%e6%92%ad" class="header-mark"></a>5.3.2 命令传播</h5><h5 id="533-缓存追加" class="headerLink"><a href="#533-%e7%bc%93%e5%ad%98%e8%bf%bd%e5%8a%a0" class="header-mark"></a>5.3.3 缓存追加</h5><ul>
<li>协议文本生成之后，会被追加到<code>redis.h/redisServer</code>结构的<code>aof_buf</code>末尾</li>
<li><code>aof_buf</code>保存着所有等待写入AOF文件的协议文本</li>
<li>缓存追加步骤
<ol>
<li>接受命令、命令的参数、参数个数、所使用的数据库等信息</li>
<li>将命令还原成Redis网络通讯协议</li>
<li>将协议文本追加到<code>aof_buf</code>末尾</li>
</ol>
</li>
</ul>
<h5 id="534-文件写入和保存" class="headerLink"><a href="#534-%e6%96%87%e4%bb%b6%e5%86%99%e5%85%a5%e5%92%8c%e4%bf%9d%e5%ad%98" class="header-mark"></a>5.3.4 文件写入和保存</h5><ul>
<li>每当服务器常规任务函数被执行或者时间处理器被执行时，<code>aof.c/flushAppendOnlyFile</code>函数都会被调用，进行：
<ul>
<li><code>WRITE</code>：根据条件，将<code>aof_buf</code>中的缓存写入到AOF文件</li>
<li><code>SAVE</code>：根据条件，调用<code>fsync</code>、<code>fdatastnc</code>函数，将AOF文件保存到磁盘中</li>
</ul>
</li>
</ul>
<h5 id="535-aof保存模式" class="headerLink"><a href="#535-aof%e4%bf%9d%e5%ad%98%e6%a8%a1%e5%bc%8f" class="header-mark"></a>5.3.5 AOF保存模式</h5><ul>
<li>
<p>Redis目前支持三种AOF保存模式：</p>
<ul>
<li><code>AOF_FSYNC_NO</code>：不保存</li>
<li><code>AOF_FSYNC_EVERYSEC</code>：每秒保存</li>
<li><code>AOF_FSYNC_ALWAYS</code>：每次执行命令保存</li>
</ul>
</li>
<li>
<p>不保存</p>
<ul>
<li>每次调用<code>flushAppendOnlyFile</code>函数，<code>WRITE</code>都会被执行，<code>SAVE</code>会被略过</li>
<li><code>SAVE</code>只会在一下任意一种情况下被执行
<ul>
<li>Redis被关闭</li>
<li>AOF功能被关闭</li>
<li>系统的写缓存被刷新（缓存满，或者定期保存操作）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>每秒保存</p>
<ul>
<li>每次调用<code>flushAppendOnlyFile</code>，有四种情况：
<ul>
<li>子进程正在执行<code>SAVE</code>
<ol>
<li>这个<code>SAVE</code>的执行时间未超过2秒，程序直接返回，并不执行<code>WRITE</code>或新的<code>SAVE</code></li>
<li>这个<code>SAVE</code>已经执行超过2秒，那么程序执行<code>WRITE</code>但不执行<code>SAVE</code>，此时的<code>WRITE</code>必须等待子线程先完成<code>SAVE</code></li>
</ol>
</li>
<li>子进程没有执行<code>SAVE</code>
<ol>
<li>上次成功执行<code>SAVE</code>距今不超过1秒，那么程序执行<code>WRITE</code>不执行<code>SAVE</code></li>
<li>上次成功执行<code>SAVE</code>距今超过1秒，那么程序执行<code>WRITE</code>和<code>SAVE</code></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>每次执行命令保存</p>
<ul>
<li>每次执行一个命令后，<code>WRITE</code>和<code>SAVE</code>都会被执行</li>
<li><code>SAVE</code>是由Redis主进程执行，所以<code>SAVE</code>执行期间，主进程会被阻塞</li>
</ul>
</li>
</ul>
<h5 id="536-aof保存模式对性能和安全的影响" class="headerLink"><a href="#536-aof%e4%bf%9d%e5%ad%98%e6%a8%a1%e5%bc%8f%e5%af%b9%e6%80%a7%e8%83%bd%e5%92%8c%e5%ae%89%e5%85%a8%e7%9a%84%e5%bd%b1%e5%93%8d" class="header-mark"></a>5.3.6 AOF保存模式对性能和安全的影响</h5><ul>
<li>对主进程的阻塞
<ul>
<li><code>不保存</code>：写入和保存都是由主进程执行，阻塞主进程</li>
<li><code>每秒保存</code>：写入由主进程执行，阻塞主进程。保存由子线程执行，不阻塞，但保存操作完成的快嘛会影响写入操作的阻塞时长</li>
<li><code>每次执行命令保存</code>：类似<code>不保存</code></li>
</ul>
</li>
<li>安全性
<ul>
<li>模式1最差</li>
<li>模式2兼顾性能和安全性</li>
<li>模式3安全性最高，性能最差</li>
</ul>
</li>
</ul>
<p>



    
<img loading="lazy" decoding="async"
         class="render-image"
         src="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210713163333.png"
         alt="https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210713163333.png"
         title="20210713163333.png"
    /></p>
<h5 id="537-aof文件的读取和数据还原" class="headerLink"><a href="#537-aof%e6%96%87%e4%bb%b6%e7%9a%84%e8%af%bb%e5%8f%96%e5%92%8c%e6%95%b0%e6%8d%ae%e8%bf%98%e5%8e%9f" class="header-mark"></a>5.3.7 AOF文件的读取和数据还原</h5><ul>
<li>根据AOF文件里的协议，重新执行一遍里面指示的所有命令</li>
<li>读取AOF文件并还原步骤：
<ol>
<li>创建一个不带网络连接的伪客户端</li>
<li>读取AOF所保存文本，还原出命令、参数、参数个数</li>
<li>使用伪客户端完执行命令</li>
<li>执行2、3，直到AOF所有命令被执行完毕</li>
</ol>
</li>
<li>为了避免对数据的完整性产生影响，在服务器载入数据的过程中，只有和数据库无关 的订阅与发布功能可以正常使用，其他命令一律返回错误。</li>
</ul>
<h5 id="538-aof重写" class="headerLink"><a href="#538-aof%e9%87%8d%e5%86%99" class="header-mark"></a>5.3.8 AOF重写</h5><ul>
<li>为了解决AOF越来越大的问题</li>
<li>创建一个新的AOF文件来代替原有的AOF文件，新AOF文件和原有AOF文件保存的数据库状态完全一样，但新的AOF文件的体积小于等于原有AOF文件的体积</li>
</ul>
<h5 id="539-aof重写的实现" class="headerLink"><a href="#539-aof%e9%87%8d%e5%86%99%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>5.3.9 AOF重写的实现</h5><ul>
<li>AOF重写并不需要对原有的AOF文件进行任何写入和读取，它针对的是数据库中键的当前值</li>
<li>根据键的类型，使用适当的写入命令来重现键的当前值</li>
</ul>
<h5 id="5310-aof后台重写" class="headerLink"><a href="#5310-aof%e5%90%8e%e5%8f%b0%e9%87%8d%e5%86%99" class="header-mark"></a>5.3.10 AOF后台重写</h5><ul>
<li>
<p>好处</p>
<ul>
<li>不阻塞主进程</li>
<li>子进程带有主进程的数据副本，使用子进程而不是线程，可以在避免锁的情况下，保证数据的安全性</li>
</ul>
</li>
<li>
<p>子进程重写期间，主进程还需要继续处理，造成数据不一致</p>
<ul>
<li>Redis增加了AOF重写缓存，这个缓存在<code>fork</code>出子进程之后启用</li>
<li>Redis主进程在接到新的写命令后，除了将这个写命令追加到现有的AOF文件，还会追加到这个缓存中
<ul>
<li>保证AOF功能继续，即使停机也不会丢失数据</li>
<li>所有对数据库的修改都会被记录到AOF重写缓存中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>子进程完成AOF重写后，向父进程发送一个完成信号，父进程：</p>
<ul>
<li>将AOF重写缓存中的内容全部写入新的AOF文件</li>
<li>对新的AOF文件改名，覆盖原有的AOF文件</li>
</ul>
</li>
<li>
<p>以上是AOF后台重写，也即是<code>BGREWRITEAOF</code>命令的工作原理</p>
</li>
</ul>
<h5 id="5311-aof后台重写的出发条件" class="headerLink"><a href="#5311-aof%e5%90%8e%e5%8f%b0%e9%87%8d%e5%86%99%e7%9a%84%e5%87%ba%e5%8f%91%e6%9d%a1%e4%bb%b6" class="header-mark"></a>5.3.11 AOF后台重写的出发条件</h5><ul>
<li>通过调用<code>BGREWRITEAOF</code>手动触发</li>
<li>服务器在AOF开启后会维持三个变量
<ul>
<li>记录当前AOF文件大小的变量<code>aof_current_size</code></li>
<li>记录最后一次AOF重写后的AOF文件大小<code>aof_rewirte_base_size</code></li>
<li>增长百分比 <code>aof_rewirte_perc</code></li>
</ul>
</li>
<li>每次<code>serverCron</code>函数执行时，检查以下条件是否全部满足，是的话，会触发自动的AOF重写：
<ul>
<li>没有<code>BGSAVE</code>命令在执行</li>
<li>没有<code>BGREWRITEAOF</code>在执行</li>
<li>当前AOF文件大小大于<code>server.aof_rewrite_min_size</code> （默认1MB）</li>
<li>当前AOF文件大小和最后一次AOF重写后的大小之前比率大于等于指定的增长百分比（默认100%）</li>
</ul>
</li>
</ul>
<h5 id="5312-小结" class="headerLink"><a href="#5312-%e5%b0%8f%e7%bb%93" class="header-mark"></a>5.3.12 小结</h5><ul>
<li>AOF文件通过保存所有修改数据库的命令来记录数据库的状态</li>
<li>AOF文件的所有保存命令都以Redis通讯协议的格式保存</li>
<li>不同的AOF保存模式对数据的安全性、已经Redis的性能有很大的影响</li>
<li>AOF重写的目的是用更小的体积保存AOF文件，整个重写过程基本上不影响Redis主进程处理命令请求</li>
<li>AOF重写的实际重写工作是针对数据库的当前值来进行的，程序既不读写也不使用原有的AOF文件</li>
<li>AOF可以手动触发或自动触发</li>
</ul>
<h4 id="54-事件" class="headerLink"><a href="#54-%e4%ba%8b%e4%bb%b6" class="header-mark"></a>5.4 事件</h4><ul>
<li>事件是Redis的核心，处理两项重要的任务：
<ul>
<li>处理文件事件：在多个客户端中实现多路复用，接受它们发来的命令请求，并将命令的执行结果返回给客户端</li>
<li>时间事件：实现服务器常规操作（<code>server cron job</code>）</li>
</ul>
</li>
</ul>
<h5 id="541-文件事件" class="headerLink"><a href="#541-%e6%96%87%e4%bb%b6%e4%ba%8b%e4%bb%b6" class="header-mark"></a>5.4.1 文件事件</h5><ul>
<li>Redis通过在多个客户端之间进行多路复用，从而实现高效的命令请求处理
<ul>
<li>多个客户端通过套接字连接Redis服务器，但只有在套接字可以无阻塞地进行读或者写时，服务器才会和这些客户端进行交互</li>
<li>Redis将这些因为套接字进行多路复用而产生的事件称为文件事件（<code>file event</code>），文件事件可以分为读事件和写事件两类</li>
</ul>
</li>
<li>读事件
<ul>
<li>读事件标志着客户端命令请求的发送状态</li>
<li>当一个新客户端连接到服务器时，服务器会给该客户端绑定读事件，直到客户端断开连接之后，这个读事件才会被移除</li>
<li>读事件在整个网络连接的生命期内，都会在等待和就绪两种状态直接切换
<ul>
<li>当客户端连接到服务器，但并没有向服务器发送命令时，读事件处于等待状态</li>
<li>客户端发送命令，并且请求已到达（套接字可以无阻塞地执行读操作），读事件处于就绪状态</li>
</ul>
</li>
</ul>
</li>
<li>写事件
<ul>
<li>写事件标志着客户端对命令结果的接受状态</li>
<li>客户端自始至终都关联着读事件。服务端只会在有命令结果需要传回给客户端时，才会为客户端关联写事件</li>
<li>写事件会在两种状态之间切换：
<ul>
<li>当服务器有结果需要返回给客户端时，但客户端还未能执行无阻塞写，那么写事件处于等待状态</li>
<li>当服务器有结果需要返回给客户端时，并且客户端可以无阻塞写，那么写事件处于就绪状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="542-时间事件" class="headerLink"><a href="#542-%e6%97%b6%e9%97%b4%e4%ba%8b%e4%bb%b6" class="header-mark"></a>5.4.2 时间事件</h5><ul>
<li>事件事件记录着那些要在指定时间点运行的时间</li>
<li>多个时间事件以无序链表的形式保存在服务器状态中</li>
<li>每个时间事件主要由三个属性组成：
<ul>
<li><code>when</code>：以毫秒格式的UNIX时间戳为单位，记录执行的时间</li>
<li><code>timeProc</code>：时间处理函数</li>
<li><code>next</code>：指向下一个时间事件，形成链表</li>
</ul>
</li>
<li>根据<code>timeProc</code>函数的返回值，可以将时间事件划分为两类：
<ul>
<li>返回<code>ae.h/AE_NOMORE</code>，该事件为单词执行事件：处理一次后被删除，不再执行</li>
<li>如果返回非<code>AE_NOMORE</code>的整数，为循环执行事件：根据返回值更新<code>when</code>属性，一直更新运行下去</li>
</ul>
</li>
</ul>
<h5 id="543-时间事件应用实例服务器常规操作" class="headerLink"><a href="#543-%e6%97%b6%e9%97%b4%e4%ba%8b%e4%bb%b6%e5%ba%94%e7%94%a8%e5%ae%9e%e4%be%8b%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%b8%b8%e8%a7%84%e6%93%8d%e4%bd%9c" class="header-mark"></a>5.4.3 时间事件应用实例：服务器常规操作</h5><ul>
<li>服务器定期自检，这类操作成为常规操作（<code>cron job</code>）</li>
<li>由<code>redis.c/serverCron</code>实现，包括：
<ul>
<li>更新服务器各类统计时间，比如时间、内存占用、数据库占用情况等</li>
<li>清理数据库中的过期键值对</li>
<li>对不合理的数据库进行大小调整</li>
<li>关闭和清理链接失效的客户端</li>
<li>尝试进行AOF或RDB持久化操作</li>
<li>如果服务器时主节点的话，对附属节点进行定期同步</li>
<li>如果处于集群模式的话，对集群进行定期同步和链接测试</li>
</ul>
</li>
<li>Redis将<code>serverCron</code>作为时间事件来运行，循环执行</li>
</ul>
<h5 id="544-事件的执行与调度" class="headerLink"><a href="#544-%e4%ba%8b%e4%bb%b6%e7%9a%84%e6%89%a7%e8%a1%8c%e4%b8%8e%e8%b0%83%e5%ba%a6" class="header-mark"></a>5.4.4 事件的执行与调度</h5><ul>
<li>Redis中两种时间呈合作关系：
<ul>
<li>一种事件等待另一种事件执行完毕之后，才开始执行，事件之间不会出现抢占</li>
<li>时间处理器先处理文件事件（命令请求），在执行时间事件（调用<code>serverCron</code>）</li>
<li>文件时间的等待时间（类<code>poll</code>函数的最大阻塞时间），由距离到达时间最短的时间事件决定</li>
</ul>
</li>
</ul>
<h5 id="545-小结" class="headerLink"><a href="#545-%e5%b0%8f%e7%bb%93" class="header-mark"></a>5.4.5 小结</h5><ul>
<li>Redis事件分为时间事件和文件事件</li>
<li>文件时间分读事件和写事件：读事件实现命令请求的接收，写事件实现了命令结果的返回</li>
<li>时间时间分为单词执行事件和循环执行时间，服务器常规操作<code>serverCron</code>就是循环事件</li>
<li>文件事件和时间事件之间是合作关系：一种事件会等待另一种事件完成后在执行，不会出现抢占情况</li>
<li>时间事件的实际执行时间通常比预定时间晚一些</li>
</ul>
<h4 id="55-服务器与客户端" class="headerLink"><a href="#55-%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%b8%8e%e5%ae%a2%e6%88%b7%e7%ab%af" class="header-mark"></a>5.5 服务器与客户端</h4><h5 id="551-初始化服务器" class="headerLink"><a href="#551-%e5%88%9d%e5%a7%8b%e5%8c%96%e6%9c%8d%e5%8a%a1%e5%99%a8" class="header-mark"></a>5.5.1 初始化服务器</h5><ul>
<li>初始化过程：
<ol>
<li>初始化服务器全局状态</li>
<li>载入配置文件</li>
<li>创建<code>daemon</code>进程</li>
<li>初始化服务器功能模块</li>
<li>载入数据</li>
<li>开始时间循环</li>
</ol>
</li>
<li>初始化服务器全局状态
<ul>
<li><code>redis.h/redisServer</code>记录了和服务器相关的所有数据</li>
</ul>
</li>
<li>载入配置文件
<ul>
<li>Redis在初始完<code>server</code>变量之后，会读入配置文件和选项，根据这些配置来对<code>server</code> 变量的属性值做相应的修改</li>
</ul>
</li>
<li>创建<code>daemon</code>进程
<ul>
<li>Redis默认以<code>daemon</code>进程方式运行，并创建相应的<code>pid</code>文件</li>
</ul>
</li>
<li>初始化服务器功能模块
<ul>
<li>为<code>server</code>变量的数据结构子属性分配内存</li>
<li>初始化这些数据结构</li>
</ul>
</li>
<li>载入数据
<ul>
<li>将RDB或AOF数据载入到服务器进程。AOF优先被使用</li>
</ul>
</li>
<li>开始时间循环</li>
</ul>
<h5 id="552-客户端连接到服务器" class="headerLink"><a href="#552-%e5%ae%a2%e6%88%b7%e7%ab%af%e8%bf%9e%e6%8e%a5%e5%88%b0%e6%9c%8d%e5%8a%a1%e5%99%a8" class="header-mark"></a>5.5.2 客户端连接到服务器</h5><ul>
<li>
<p>当服务器完成初始化之后，就准备好接受客户端连接</p>
</li>
<li>
<p>客户端通过套接字函数<code>connect</code>到服务器，步骤：</p>
<ol>
<li>服务器通过文件事件无阻塞地<code>accept</code>客户端连接，并返回一个套接字描述符<code>fd</code></li>
<li>服务器为<code>fd</code>创建一个对应的<code>redis.h/redisClient</code>结构实例，并将该实例加入到服务器的已连接客户端链表中</li>
<li>服务器在事件处理器为该<code>fd</code>关联读文件请求</li>
</ol>
</li>
<li>
<p>Redis以多路复用的方式来处理多个客户端，为每个已连接客户端维持一个<code>redisClient</code>结构：</p>
<ul>
<li>套接字描述符</li>
<li>客户端正在使用的数据库指针和数据库号码</li>
<li>客户端的查询缓存和回复缓存</li>
<li>一个指向命令函数的指针，以及字符串形式的命令、命令参数、命令个数</li>
<li>客户端状态：<code>SLAVE</code>、<code>MONITOR</code>、事务状态</li>
<li>实现事务功能（<code>MULTI</code>、<code>WATCH</code>）所需的数据结构</li>
<li>实现阻塞功能（<code>BLPOP</code>、<code>BRPOPLPUSH</code>）所需的数据结构</li>
<li>实现订阅与发布功能（<code>PUBLISH</code>、<code>SUBSCRIBE</code>）所需的数据结构</li>
<li>统计数据和选项：客户端创建时间，和服务端最后交互时间，缓存大小等</li>
</ul>
</li>
</ul>
<h5 id="553-命令的请求处理和结果返回" class="headerLink"><a href="#553-%e5%91%bd%e4%bb%a4%e7%9a%84%e8%af%b7%e6%b1%82%e5%a4%84%e7%90%86%e5%92%8c%e7%bb%93%e6%9e%9c%e8%bf%94%e5%9b%9e" class="header-mark"></a>5.5.3 命令的请求、处理和结果返回</h5><ul>
<li>客户端连上服务器之后，客户端就可以向服务器发送命令请求了</li>
<li>服务器处理客户端请求过程：
<ol>
<li>客户端通过套接字向服务器传送命令协议数据</li>
<li>服务器通过读事件来传入数据，并将数据保存在客户端对应的<code>redisClient</code>结构的查询缓存</li>
<li>根据客户端查询缓存中的内容，程序从命令表中查找响应命令的实现函数</li>
<li>程序执行实现函数，修改服务器的全局状态<code>server</code>变量，并将命令的执行结果保存到客户端<code>redisClient</code>结构的回复缓存，然后为该客户端的<code>fd</code>关联写事件</li>
<li>当客户端<code>fd</code>的写事件就绪时，将回复缓存中的命令结果传回给客户端</li>
</ol>
</li>
</ul>
<h5 id="554-命令请求实例set的执行过程" class="headerLink"><a href="#554-%e5%91%bd%e4%bb%a4%e8%af%b7%e6%b1%82%e5%ae%9e%e4%be%8bset%e7%9a%84%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b" class="header-mark"></a>5.5.4 命令请求实例：SET的执行过程</h5><h5 id="555-小结" class="headerLink"><a href="#555-%e5%b0%8f%e7%bb%93" class="header-mark"></a>5.5.5 小结</h5><ul>
<li>服务器经过初始化之后，才能开始接受命令</li>
<li>服务器初始化可以分为6个步骤</li>
<li>服务器为每个已连接的客户端维持一个客户端结构，保存这个客户端的所有状态信息</li>
<li>服务器处理客户端请求流程</li>
</ul></div><footer>
                        <div class="post">


<div class="post-share"></div>






<div class="post-tags"><a href="/tags/redis/" class="tag">redis</a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="tag">读书笔记</a></div></div>
                </footer></div>

        <div id="toc-final"></div>
        </div>

    
    </article>
    <section class="page single comments content-block-position">
        <h1 class="display-hidden">Комментарии</h1><div id="comments"><div id="valine" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://valine.js.org/">Valine</a>.
            </noscript></div></section></div>

</main></div>

        <aside id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="svg-icon icon-arrow-up"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="svg-icon icon-comments-fixed"></i>
            </a>
        </aside><link rel="stylesheet" href="/lib/valine/valine.min.css"><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lunr@2.3.8/lunr.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script>window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":10},"comment":{"valine":{"appId":"qawpEGaIhzxE9qCJm9hisTxW-gzGzoHsz","appKey":"FkncojWQwaOzzkHjlvW0vH3b","avatar":"mp","el":"#valine","emojiCDN":"https://cdn.jsdelivr.net/npm/emoji-datasource-google@5.0.1/img/google/64/","emojiMaps":{"100":"1f4af.png","alien":"1f47d.png","anger":"1f4a2.png","angry":"1f620.png","anguished":"1f627.png","astonished":"1f632.png","black_heart":"1f5a4.png","blue_heart":"1f499.png","blush":"1f60a.png","bomb":"1f4a3.png","boom":"1f4a5.png","broken_heart":"1f494.png","brown_heart":"1f90e.png","clown_face":"1f921.png","cold_face":"1f976.png","cold_sweat":"1f630.png","confounded":"1f616.png","confused":"1f615.png","cry":"1f622.png","crying_cat_face":"1f63f.png","cupid":"1f498.png","dash":"1f4a8.png","disappointed":"1f61e.png","disappointed_relieved":"1f625.png","dizzy":"1f4ab.png","dizzy_face":"1f635.png","drooling_face":"1f924.png","exploding_head":"1f92f.png","expressionless":"1f611.png","face_vomiting":"1f92e.png","face_with_cowboy_hat":"1f920.png","face_with_hand_over_mouth":"1f92d.png","face_with_head_bandage":"1f915.png","face_with_monocle":"1f9d0.png","face_with_raised_eyebrow":"1f928.png","face_with_rolling_eyes":"1f644.png","face_with_symbols_on_mouth":"1f92c.png","face_with_thermometer":"1f912.png","fearful":"1f628.png","flushed":"1f633.png","frowning":"1f626.png","ghost":"1f47b.png","gift_heart":"1f49d.png","green_heart":"1f49a.png","grimacing":"1f62c.png","grin":"1f601.png","grinning":"1f600.png","hankey":"1f4a9.png","hear_no_evil":"1f649.png","heart":"2764-fe0f.png","heart_decoration":"1f49f.png","heart_eyes":"1f60d.png","heart_eyes_cat":"1f63b.png","heartbeat":"1f493.png","heartpulse":"1f497.png","heavy_heart_exclamation_mark_ornament":"2763-fe0f.png","hole":"1f573-fe0f.png","hot_face":"1f975.png","hugging_face":"1f917.png","hushed":"1f62f.png","imp":"1f47f.png","innocent":"1f607.png","japanese_goblin":"1f47a.png","japanese_ogre":"1f479.png","joy":"1f602.png","joy_cat":"1f639.png","kiss":"1f48b.png","kissing":"1f617.png","kissing_cat":"1f63d.png","kissing_closed_eyes":"1f61a.png","kissing_heart":"1f618.png","kissing_smiling_eyes":"1f619.png","laughing":"1f606.png","left_speech_bubble":"1f5e8-fe0f.png","love_letter":"1f48c.png","lying_face":"1f925.png","mask":"1f637.png","money_mouth_face":"1f911.png","nauseated_face":"1f922.png","nerd_face":"1f913.png","neutral_face":"1f610.png","no_mouth":"1f636.png","open_mouth":"1f62e.png","orange_heart":"1f9e1.png","partying_face":"1f973.png","pensive":"1f614.png","persevere":"1f623.png","pleading_face":"1f97a.png","pouting_cat":"1f63e.png","purple_heart":"1f49c.png","rage":"1f621.png","relaxed":"263a-fe0f.png","relieved":"1f60c.png","revolving_hearts":"1f49e.png","right_anger_bubble":"1f5ef-fe0f.png","robot_face":"1f916.png","rolling_on_the_floor_laughing":"1f923.png","scream":"1f631.png","scream_cat":"1f640.png","see_no_evil":"1f648.png","shushing_face":"1f92b.png","skull":"1f480.png","skull_and_crossbones":"2620-fe0f.png","sleeping":"1f634.png","sleepy":"1f62a.png","slightly_frowning_face":"1f641.png","slightly_smiling_face":"1f642.png","smile":"1f604.png","smile_cat":"1f638.png","smiley":"1f603.png","smiley_cat":"1f63a.png","smiling_face_with_3_hearts":"1f970.png","smiling_imp":"1f608.png","smirk":"1f60f.png","smirk_cat":"1f63c.png","sneezing_face":"1f927.png","sob":"1f62d.png","space_invader":"1f47e.png","sparkling_heart":"1f496.png","speak_no_evil":"1f64a.png","speech_balloon":"1f4ac.png","star-struck":"1f929.png","stuck_out_tongue":"1f61b.png","stuck_out_tongue_closed_eyes":"1f61d.png","stuck_out_tongue_winking_eye":"1f61c.png","sunglasses":"1f60e.png","sweat":"1f613.png","sweat_drops":"1f4a6.png","sweat_smile":"1f605.png","thinking_face":"1f914.png","thought_balloon":"1f4ad.png","tired_face":"1f62b.png","triumph":"1f624.png","two_hearts":"1f495.png","unamused":"1f612.png","upside_down_face":"1f643.png","weary":"1f629.png","white_frowning_face":"2639-fe0f.png","white_heart":"1f90d.png","wink":"1f609.png","woozy_face":"1f974.png","worried":"1f61f.png","yawning_face":"1f971.png","yellow_heart":"1f49b.png","yum":"1f60b.png","zany_face":"1f92a.png","zipper_mouth_face":"1f910.png","zzz":"1f4a4.png"},"enableQQ":false,"highlight":true,"lang":"en","pageSize":10,"placeholder":"Your comment ...","recordIP":true,"serverURLs":"https://qawpegai.lc-cn-n1-shared.com","visitor":true}},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","maxResultLength":10,"noResultsFound":"No results found","snippetLength":30,"type":"lunr"}};</script><script src="/js/theme.min.js"></script></body>
</html>
