<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis设计与实现 | Note Site</title><meta name=keywords content="redis,读书笔记"><meta name=description content="Redis设计与实现 - Note Site"><meta name=author content="Cuiks"><link rel=canonical href=https://www.cuiks.top/posts/redis_design_and_implement/><meta name=google-site-verification content="XYZabc"><link href=/assets/css/stylesheet.min.e7fdcebb37aa7bdecf8b9159a8b3cab1ba4a084f27d375288d3416558b340888.css integrity="sha256-5/3Ouzeqe97Pi5FZqLPKsbpKCE8n03UojTQWVYs0CIg=" rel="preload stylesheet" as=style><link rel=icon href=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/dingdang-cat-favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/favicon-32x32.png><link rel=apple-touch-icon href=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/dingdangcat-apple-touch-icon.png><link rel=mask-icon href=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/dingdangcat-android-chrome-192x192.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.76.5"><meta property="og:title" content="Redis设计与实现"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://www.cuiks.top/posts/redis_design_and_implement/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-14T17:40:56+08:00"><meta property="article:modified_time" content="2021-07-14T17:40:56+08:00"><meta property="og:site_name" content="Note Site"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis设计与实现"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.cuiks.top/posts/"},{"@type":"ListItem","position":3,"name":"Redis设计与实现","item":"https://www.cuiks.top/posts/redis_design_and_implement/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis设计与实现","name":"Redis设计与实现","description":"","keywords":["redis","读书笔记"],"articleBody":"1、内部数据结构 1.1 简单动态字符串 1.1.1 sds的用途  sds（Simple Dynamic String）简单动态字符串  Redis底层所使用的的字符串表示   用途  实现字符串对象 用作char*类型替代品    1.1.2 Redis中的字符串   sds的实现\n  typedef char *sds struct sdshdr { int len; // buf已占用长度  int free; // bug剩余可用长度  char buf[]; //实际保存字符串数据的地方  }     1.1.3 优化追加操作  如果free空间足够，无须再分配空间。如果不够计算新字符串的总长度。 如果追加字符串小于1M，分配多余所需空间一倍(新字符串长度1倍)的空间。否则，额外多分配1MB。  1.1.4 sds模块的API 1.1.5小结  Redis的字符串表示为sds，而不是C字符串（以\\0结尾的char*） 对比C字符串，sds有以下特性  可以高效计算长度 可以高效执行追加操作 二进制安全   sds为追加操作进行优化：加快追加操作速度，并降低内存分配的次数。代价是多占用内存，并且这些内存不会被主动释放  1.2 双端链表 1.2.1 双端链表的应用  实现Redis的列表类型  Redis列表使用两种数据结构作为底层实现  双端链表 压缩列表 创建新的列表键时，优先考虑使用压缩列表，在有需要的时候在转换为双端链表     Redis自身功能的构建  事务模块保存命令 服务器模块保存多个客户端 订阅/发送模块保存订阅模式的多个客户端 事件模块保存时间事件 。。。    1.2.2 双端链表的实现 双端链表的实现由listNode和list两个数据结构构成\n  listNode是双端链表的节点\n  typedef struct listNode{ struct listNode *prev; // 前驱结点  struct listNode *next; // 后继节点  void *value; // 值 } listNode;   value的属性是void *，说明对保存的值的类型不做限制\n     list是双端链表本身\n  typedef struct list{ listNode *head; //表头指针  listNode *tail; //表尾指针  unsigned long len; // 节点数量  void *(*dup)(void *ptr); // 复制函数  void (*free)(void *ptr); // 释放函数  int (*match)(void *ptr, void *key); // 比对函数 } list;     双端链表API\n     1.2.3 迭代器 Redis为双端链表实现了一个迭代器，可以从两个方向进行迭代\n 沿着next指针从表头向表尾 沿着prev指针从表尾向表头  结构定义：\ntypedef struct listIter { listNode *next; //下一节点  int direction; // 迭代方向 } listIter;  direction选项  adlist.h/AL_START_HEAD 从表头到表尾 adlist.h/AL_START_TAIL 从表尾到表头   迭代器API  ![image-20210708163935798](/Users/cks/Library/Application Support/typora-user-images/image-20210708163935798.png)    1.2.4 小结  Redis实现了自己的双端链表 双端链表的主要作用  列表类型的底层实现之一 作为通用数据结构，被其他功能模块使用   双端链表及其节点的性能特性  访问前驱结点和后继节点复杂度都是O(1)，并且对链表的迭代可以从表头和表尾两个方式开始 对表头和表尾处理的复杂度为O(1) 计算链表长度复杂度O(1)    1.3 字典 1.3.1 字典的应用 字典应用广泛\n 实现数据库键空间  数据库中键值对由字典保存，每个数据库都有一个与之相对的字典，成为键空间   用作Hash类型键的一种底层实现  Redis的Hash类型键使用两种数据结构作为底层实现  字典 压缩列表 创建新的Hash键时,默认使用压缩列表作为底层实现，有需要再转换字典      1.3.2 字典的实现 实现方法有多种：\n 最简单，使用链表或数组，但是只适用于元素个数不多的情况 兼顾高效和简单，使用哈希表 最求稳定性并且希望高效地实现排序，可以使用平衡树  Redis选择了高效且简繁的哈希表作为字典的底层实现。\n  typedef struct dict { dictType *type; // 特定于类型的处理函数  void *privdata; // 类型处理函数的私有数据  dictht ht[2]; // 哈希表(2个)  int rehashidx; // 记录rehash进度的标志，值为-1表示rehash未进行  int iterators; // 当前正在运作的安全迭代器数量 } dict;   dict的API\n     哈希表的实现\n  // dict.h/dicht typedef struct dictht { dictEntry **table; // 哈希表节点指针数组（俗称桶，bucket）  unsigned long size; // 指针数组的大小  unsigned long sizemask; // 指针数组的长度掩码，用于计算索引值  unsigned long used; // 哈希表现有的节点数量 } dictht;   table属性是一个数组，数组每个元素都是一个指向dictEntry结构的指针。\n  每个dictEntry都保存着一个键值对，以及一个指向另一个dictEntry结构的指针：\n  typedef struct dictEntry { void *key; // 键  union { void *val; uint64_t u64; int64_t s64; } v; // 值  struct dictEntry *next; // 链往后继节点 }   整个字典结构：\n   哈希算法\n  Redis使用两种不同的哈希算法\n MurmurHash2 32 bit 算法 https://github.com/aappleby/smhasher 基于djb算法实现的一个大小写无关散列算法 http://www.cse.yorku.ca/~oz/hash.html    使用哪种算法取决于具体应用所处理的数据：\n 命令表以及Lua脚本缓存使用算法2 数据库、集群、哈希键、阻塞操作等功能使用算法1    1.3.3 创建新字典 dict *d = dictCreate(\u0026hash_type, NULL)\n1.3.4 添加键值对到字典 添加流程：\n 如果字典未初始化(即字典的0号哈希表的table属性为空)，那么程序需要对0号哈希表进行初始化 如果在插入时发生了键碰撞，那么程序需要处理碰撞 如果插入新元素使得字典满足rehash条件，那么需要启动响应的rehash程序  1.3.5 添加新元素到空白字典 当第一次往空字典里添加键值对时，程序会根据dict.h/DICT_HT_INITIAL_SIZE里指定的大小为d-ht[0]-table分配空间（目前为值4）。\n1.3.6 添加新键值对时发生碰撞处理 使用链地址法，将新的键值对链接到存在的键值对上。\n1.3.7 添加新键值对时触发了rehash操作   对于使用链地址法来解决碰撞问题的哈希表，性能依赖于它的大小(size属性)和它所保存的节点的数量(used属性)之间的比率：\n 比率1:1，哈希表性能最好 如果节点数量比哈希表大小要大很多，哈希表就会退化成多个链表，性能优势不再存在    为了保证性能，字典需要对所使用的的哈希表(ht[0])进行rehash操作：在不修改任何键值对的情况下，对哈希表进行扩容，尽量将比率维持在1:1左右。\n  每次向字典添加新键值对都会进行检查，对于ht[0]的size和used属性，ratio = used/size满足一下任何一个条件，激活rehash:\n 自然rehash： ratio = 1， 且变量dict_can_resize为真  在BGSAVE、BGREWRITEAOF时，dict_can_resize会暂时设为假，为了最大化利用系统的copy on write机制，减少程序对内存的碰撞。   强制rehash：ratio大于变量dict_force_resize_ratio(目前默认为5)。    1.3.8 rehash执行过程 执行步骤：\n 创建一个比ht[0]-table更大的ht[1]-table  为ht[1]-table分配空间至少是ht[0]-used的两倍   将ht[0]-table中的键值对迁移到ht[1]-table 将原有的ht[0]的数据清空，并将ht[1]替换为新的ht[0]  释放ht[0]的空间 用ht[1]来代替ht[0] 创建新的哈希表，设置为ht[1] 将字典的rehashidx属性设置为-1，标识rehash已停止    1.3.9 渐进式rehash   rehash程序不是在激活只会就马上执行知道完成的，而是分多次、渐进式地完成\n 添加键值对触发rehash需要用户等很久不合理 服务器阻塞不可接受    渐进式rehash由_dictRehashStep和 dictRehashMilliseconds两个函数进行\n _dictRehashStep用于对数据库字典、以及哈希表的字典进行被动rehash dictRehashMilliseconds由Redis服务器常规任务程序(server cron jon)执行，用于数据库字典进行主动rehash    _dictRehashStep\n 每次执行_dictRehashStep，ht[0]-table哈希表第一个不为空的索引上的所有节点就会全部迁移到ht[1]-table 在rehash开始之后，每次执行一次添加、查找、删除操作，_dictRehashStep都会执行一次    dictRehashMilliseconds\n dictRehashMilliseconds可以在指定的毫秒数内，对字典进行rehash    其他措施\n rehash时，字典同时存在两个哈希表，所以查找、删除等操作除了在ht[0]上进行，还需要在ht[1]上进行。 在执行添加操作时，新的节点直接添加到ht[1]    1.3.10 字典的收缩   如果哈希表的可用节点比已用节点数大很多，也可以对哈希表进行rehash来收缩字典\n  收缩规则定义：\n  // redis.c/htNeedResize int htNeedsResize(dict *dict) { long long size, used; size = dictSlots(dict); // 哈希表已用节点数量  used = dictSize(dict); // 哈希表大小  // 当哈希表的大小大于 DICT_HT_INITIAL_SIZE 并且字典的填充率低于 REDIS_HT_MINFILL 时 返回 1  return (size \u0026\u0026 used \u0026\u0026 size  DICT_HT_INITIAL_SIZE \u0026\u0026 (used*100/size  REDIS_HT_MINFILL)); }   默认情况下，DICT_HT_INITIAL_SIZE的值为10。也就是当字典填充率低于10%时，程序就可以对这个字典进行收缩操作的。\n    收缩和扩展的区别\n 扩展操作时自动触发的。而收缩操作时由程序手动执行    使用字典的程序可以决定何时对字典进行收缩\n 字典用于实现哈希键：每次从字典删除一个键值对，会立即执行htNeedsResize函数，判断是否需要收缩 字典用于实现数据库键空间：由redis.c/tryResizeHashTables函数决定    1.3.11 字典其他操作 1.3.12 字典的迭代   字典带有自己的迭代器实现（对字典迭代实际上是对字典所使用的的哈希表迭代）\n 迭代器首先迭代第一个哈希表，如果正在rehash，就继续对第二个哈希表进行迭代 当迭代哈希表时，找到第一个不为空的索引，然后迭代这个索引上的所有节点 当这个索引迭代完了，继续查找下一个不为空的索引，如此循环，一直到整个哈希表都迭代完为止。    字典的迭代器有两种\n 安全迭代器：在迭代过程中，可以对字典进行修改 不安全迭代器：在迭代过程中，不对字典进行修改    迭代器的数据结构定义：\n  typedef struct dictIterator { dict *d; //正在迭代的字典  int table, // 正在迭代的哈希表的号码(0或者1)  index, // 正在迭代的哈希数组的索引  safe; // 是否安全？  dictEntry *entry, // 当前哈希节点  *nextEntry; // 当前哈希节点的后继节点 } dictIterator;     迭代器API\n     1.3.13 小结  字典由键值对构成的抽象数据结构 Redis中的数据库和哈希键都基于字典来实现 Redis字典的底层实现为哈希表，每个字典使用两个哈希表。一般情况下只是用0号哈希表，只有rehash时，才会同时使用0号和1号哈希表 哈希表使用链地址法解决键冲突 Rehash可以用于扩展和收缩哈希表 对哈希表的rehash是分多次、渐进式地进行的  1.4 跳跃表  一种随机化的数据 以有序的方式在层次化的链表中保存元素 效率可以和平衡树媲美，查找、删除、添加都可以在对数期望时间下完成   表头(head)：负责维护跳跃表的节点指针 跳跃表节点：保存元素值，以及多个层 层：保存着指向其他元素的指针。高层的指针越过的元素数量大于底层的指针，为了提高查找效率，从高层开始访问，随着元素值范围缩小，慢慢降低层次 表尾：全部由NULL组成，表示跳跃表的末尾  1.4.1 跳跃表的实现 为了适应功能需要，redis做了修改:\n 允许重复的score值：多个不同的member的score值可以相同 进行对比操作时，不仅要检查score值，还要检查member 每个节点都带有一个高度为1层的后退至真，用于从表尾方向向表头方向迭代  结构定义：\n// redis.h/zskiplist typedef struct zskiplist { struct zskiplistNode *header, *tail; // 头节点，尾节点  unsigned long length; // 节点数量  int level; // 目前表内节点的最大层数 } zskiplist; 跳跃表节点定义：\n// redis.h/zskiplistNode typedef struct zskiplistNode { robj *obj; // member对象  double score; // 分值  struct zskiplistNode *backward; // 后退指针  struct zskiplistLevel { // 层  struct zskiplistNode *forward; // 前进指针  unsigned int span; // 这个层跨越的节点数量  } level[]; } zskiplistNode; 操作这两个数据结构API：\n![image-20210709144926947](/Users/cks/Library/Application Support/typora-user-images/image-20210709144926947.png)\n1.4.2 跳跃表的应用  实现有序集数据类型  跳跃表将指向有序集的score值和member域的指针作为元素，并以score值作为索引，对有序集元素进行排序。    1.4.3 小结  跳跃表是一种随机化数据结构，查找、添加、删除都可以在对数期望时间下完成 跳跃表目前在Redis的唯一作用就是作为有序集类型的底层数据结构之一（另一个构成有序集的结构是字典） 为了适应功能，redis基于William Pugh论文中描述的跳跃表进行修改：  score值可重复 对比元素同时检查score和member 每个节点带有高度为1的后退指针，用于从表尾向表头迭代    2、内存映射数据结构  虽然内部数据结构非常强大，但是耗费内存。对于元素本身体积不大，代价昂贵。  Redis允许使用内存映射数据结构来代替内部数据结构   内存映射数据是一系列经过特殊编码的字节序列，节省大量内存 因为内存映射数据结构复杂得多，所以占用CPU时间要多  2.1 整数集合  整数集合（ineset）用于有序、无重复地保存多个整数值。会根据元素的值，自动选择(调整)该用什么长度的整数类型保存数据。  2.1.1 整数集合的应用 Intset是集合键的底层实现之一，如果一个集合满足：\n 只保存整数数据 元素数量不多  2.2.2 数据结构和主要操作  定义  // intset.h/intset typedef struct intset { uint32_t encoding; // 保存元素所使用的的类型的长度  uint32_t length; // 元素个数  int8_t contents[]; // 保存元素的数组 } intset;  encoding的值：  // intset.c # define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t))   content数组是实际保存数据的地方，特性：\n 没有重复元素 元素在数组中从小到大排列    content数组的int8_t类型声明做为占位符使用。程序根据encoding的值，对content进行类型转换和指针运算。\n  inset主要操作\n     2.1.3 intset 运行实例  创建新inset  intset *is = intsetNew(); // intset.c/intsetNew   添加新元素到intset。intset.c/intsetAdd  处理情况  元素已存在，不做动作 元素不存在，并且添加新元素不需要升级 元素不存在，需要升级后，才能添加元素   intsetAdd需要维持intset-contents的以下性质  没有重复元素 从小到大排序      2.1.4 升级   intsetAdd发现新元素不能用现有编码方式保存，就会使用intsetUpgradeAndAdd函数升级\n  intsetUpgradeAndAdd任务\n 检测新元素需要编码类型 设置encoding属性为新编码类型，根据新编码类型对整个contents数组进行内存重分配 调整contents数组原有元素在内存中排列方式，从旧编码调整为新编码 将新元素添加到集合    2.1.5 关于升级  从较短整数到较长整数的转换，并不会更改元素里面的值 集合编码元素的方式，由元素中长度最大的那个值来决定  2.1.6 关于元素移动  元素移动不仅出现在升级(intsetUpgradeAndAdd)操作中，还出现在对contents数组的增删(intsetAdd和intsetRemove)操作上。复杂度都不低于O(n)  2.1.7 其他操作  读取  _intsetGet：接受一个索引pos，根据intset-encoding的值进行指针运算，计算出给定索引的值。 intsetSearch 二分查找，判断元素的索引   写入  _intsetSet：接受一个索引pos以及一个new_value，将pos位置设置为new_value   删除  intsetRemove：删除单个元素。先intsetSearch获取需要删除元素索引，然后济宁内存移位操作，最后通过内存重新分配，调整数组长度   降级  Intset不支持降级操作    2.1.8 小结  Intset用于有序、无重复地保存多个整数值，它会根据元素的值，自动选择该用什么长度 的整数类型来保存元素。 当一个位长度更长的整数值添加到 intset 时，需要对 intset 进行升级，新 intset 中每个 元素的位长度都等于新添加值的位长度，但原有元素的值不变。 升级会引起整个 intset 进行内存重分配，并移动集合中的所有元素，这个操作的复杂度 为 O(N) 。 Intset只支持升级，不支持降级。 Intset 是有序的，程序使用二分查找算法来实现查找操作，复杂度为 O(lg N) 。  2.2 压缩列表  Ziplist是由一系列特殊编码的内存块构成的列表 一个ziplist可以包含多个节点entry 每个节点可以保存一个长度首先的字符数组或者整数  字符数组  长度小于等于 63 （2 6− 1）字节的字符数组 长度小于等于 16383 （2 14− 1）字节的字符数组 长度小于等于 4294967295 （2 32− 1）字节的字符数组   整数  4 位长，介于 0 至 12 之间的无符号整数 1 字节长，有符号整数 3 字节长，有符号整数 int16_t 类型整数 int32_t 类型整数 int64_t 类型整数     因为ziplist节省内存。被哈希键、列表建、有序集合键作为初始化的底层实现来使用  2.2.1 ziplist的构成 ziplist宏：\n操作ziplist的函数\n2.2.2 节点的构成  pre_entry_length  记录了前一个节点的长度。通过这个值可以进行指针运算，从而跳转到上一个节点   encoding  content部分数据类型   length  content部分数据长度   content  保存节点内容    2.2.3 创建新 ziplist  ziplistNew  2.2.4 将节点添加到末端  记录到达末端所需的偏移量 根据需要保存的值，计算所需的空间大小以及编码它前一个节点的长度所需的空间大小，然后进行内存重分配 设置新节点的各项属性 更新ziplist的各项属性  2.2.5 将节点添加到某个/某些节点的前面   为新节点扩大ziplist的空间\n  设置新节点的各项属性\n  更新新节点到ziplist。更新next节点的pre_entry_length\n pre_entry_length正好够新元素的长度 pre_entry_length只有1字节长，新元素需要5字节 pre_entry_length有5字节长，新元素需要1字节  1、3情况，直接更新pre_entry_length。2情况需要对ziplist进行内存重分配，从next开始往后逐个判断是否扩展长度。所以复杂度为O(n^2)\n  更新ziplist各项属性\n  2.2.6 删除节点  定位目标节点，计算节点的空间长度 进行内存移位覆盖原本数据，然后内存重新分配，收缩多余空间 检查next、next+1等后续节点是否满足新前驱节点的编码。类似添加操作，也会引起连锁更新。  2.2.7 遍历  可以对ziplist进行从前向后的遍历，或者从后向前的遍历。  2.2.8 查找元素，根据值定位节点  类似遍历原理  2.2.9 小结  ziplist 是由一系列特殊编码的内存块构成的列表，它可以保存字符数组或整数值，它还是 哈希键、列表键和有序集合键的底层实现之一。 ziplist 的结构 ziplist 的节点entry结构 添加和删除ziplist 节点有可能会引起连锁更新，因此最坏复杂度O(n^2)。不过连锁更新概率不高，所以可以视为O(n)  3、Redis数据类型 3.1 对象处理机制  问题  Redis必须让每个键都带有类型信息，使得程序可以检查键的类型，并为它选择合适的处理方式 需要根据数据类型的不同编码进行多态处理   为了解决上述问题，Redis构建了自己的类型系统，主要功能：  redisObject对象 基于redisObject对象的类型检查 基于redisObject对象的显式多态函数 对redisObject进行分配、共享和销毁的机制    3.1.1 redisObject数据结构，以及Redis的数据类型  定义  // redis.h typedef struct redisObject { unsigned type:4; // 类型  unsigned notused:2; // 对齐位  unsigned encoding:4; // 编码方式  unsigned lru:22; // LRU时间(相对于 server.lruclock)  unsigned refcount; // 引用计数  void *ptr; // 指向对象的值 } robj;  type记录了对象所保存的值的类型  #define REDIS_STRING 0 // 字符串 #define REDIS_LIST 1 // 列表 #define REDIS_SET 2 // 集合 #define REDIS_ZSET 3 // 有序集 #define REDIS_HASH 4 // 哈希表  encoding记录了对象所保存的值的编码  #define REDIS_ENCODING_RAW 0 // 编码为字符串 #define REDIS_ENCODING_INT 1 // 编码为整数 #define REDIS_ENCODING_HT 2 // 编码为哈希表 #define REDIS_ENCODING_ZIPMAP 3 // 编码为 zipmap #define REDIS_ENCODING_LINKEDLIST 4 // 编码为双端链表 #define REDIS_ENCODING_ZIPLIST 5 // 编码为压缩列表 #define REDIS_ENCODING_INTSET 6 // 编码为整数集合 #define REDIS_ENCODING_SKIPLIST 7 // 编码为跳跃表  ptr是一个指针，指向实际保存值的数据结构，这个数据结构由type属性和encoding属性决定  3.1.2 命令的类型检查和多态  当执行一个处理数据类型的命令时：  根据给定的key，在数据字典查找redisObject，如果没找到返回NULL 检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误 根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构 返回数据结构的操作结果作为命令的返回值    3.1.3 对象共享  Flyweight 模式  通过预分配一个常见的值对象，并在多个数据结构之间共存这些对象，避免重复分配，也节约CPU时间   Redis预分配的值对象  各种命令的返回值。OK、ERROR等 包括0在不，小于redis.h/REDIS_SHARED_INTEGERS的所有整数。（默认10000）   共享对象只能被带指针的数据结构使用。  3.1.4 引用计数以及对象的销毁  问题  redisObject用作数据库的键或者值，生命周期非常长，C语言本身没有自动释放内存的相关机制 对象的引用次数问题   解决方案。使用引用计数技术负责维持和销毁对象  每个redisObject都有一个refcount属性，记录被引用次数 新建对象，refcount值为1 对一个对象进行共享时， refcount加一 当用完一个对象之后，或者取消引用之后，程序对对象的refcount减一 当对象的refcount降至0时，这个redisObject以及它所引用的数据结构的内存，就会被释放    3.1.5 小结  Redis使用自己实现的对象机制来实现类型判断、命令多态和基于引用计数的垃圾回收。 一种 Redis 类型的键可以有多种底层实现 Redis 会预分配一些常用的数据对象，并通过共享这些对象来减少内存占用，和避免频繁 地为小对象分配内存。  3.2 字符串  REDIS_STRING是Redis使用最广泛的数据类型  3.2.1 字符串编码  字符串类型分别使用REDIS_ENCODING_INT和REDIS_ENCODING_RAW两种编码  REDIS_ENCODING_INT使用long类型来保存long类型值 REDIS_ENCODING_RAW使用sdshdr结构来保存sds(char *)、long long、double、long double类型    3.2.2 编码的选择  新创建的字符串默认使用REDIS_ENCODING_RAW编码 在字符串作为键或者值保存进数据库时，会尝试转为REDIS_ENCODING_INT  3.2.3 字符串命令的实现  通过包装sds数据结构的操作函数来实现  3.3 哈希表  REDIS_HASH是HSET、HLEN等命令的操作对象，它使用REDIS_ENCODING_ZIPLIST (压缩列表)和 REDIS_ENCODING_HT (字典)两种编码方式  3.3.1 字典编码的哈希表  当使用字典编码时，程序将哈希表的键保存为字典的键，哈希表的值保存为字典的值  3.3.2 压缩列表编码的哈希表  程序将键和值一同推入压缩列表，从而形成保存哈希表所需的键值对结构     新添加的键值对会被添加到压缩列表的表尾 当进行查找/删除或者更新操作时，程序先定位到键的位置，然后在通过对键的位置来定位值的位置  3.3.3 编码的选择  创建空白哈希表，默认使用REDIS_ENCODING_ZIPLIST。 满足以下任何一个条件，编码会切换为REDIS_ENCODING_HT：  哈希表中的某个键或者某个值的长度大于server.hash_max_ziplist_value(默认64) 压缩列表中的节点数量大于server.hash_max_ziplist_entries (默认512)    3.3.4 哈希命令的实现  对字典和压缩列表操作函数的封装，以及在两种编码之间进行转换的函数  3.4 列表  REDIS_LIST是LPUSH、LRANGE等命令的操作对象，它使用REDIS_ENCODING_ZIPLIST 和 REDIS_ENCODING_LINKEDLIST这两种方式编码  3.4.1 编码的选择  默认使用REDIS_ENCODING_ZIPLIST 满足以下任一条件，会转换为REDIS_ENCODING_LINKEDLIST  新增字符串长度超过server.list_max_ziplist_value (默认64) ziplist包含的节点超过 server.list_max_ziplist_entries (默认值512)    3.4.2 列表命令的实现  两种底层实现的抽象方式和列表的抽象方式非常接近，所以列表命令几乎就是通过一对一 地映射到底层数据结构的操作来实现的  3.4.3 阻塞的条件  BLPOP 、BRPOP 和 BRPOPLPUSH三个命令都可能造成客户端被阻塞，以下将这些命令统 称为列表的阻塞原语。 阻塞原语并不是一定会造成客户端阻塞：  只有当这些命令并用于空列表时，才会阻塞客户端 如果被处理的列表不为空，就执行物阻塞版本的LPOP 、RPOP或RPOPLPUSH命令    3.4.4 阻塞  当一个阻塞原语的处理目标为空键时，执行该阻塞原语的客户端就会被阻塞 阻塞一个客户端需要执行的步骤  将客户端设置为“正在阻塞”，并记录阻塞客户端的各个键以及阻塞的最长时限 将客户端的信息记录到server.db[1]-blocking_keys中（其中i为客户端所使用的的数据库号码） 继续维持客户端和服务端之间的网络连接，但不在向客户端传送任何信息，造成客户端阻塞   客户端脱离阻塞状态的方法：  被动脱离：其他客户端为造成阻塞的键推入了新元素 主动脱离：超过最大阻塞时间 强制脱离：客户端强制终止和服务器的链接，或者服务器停机    3.4.5 阻塞因LPUSH、RPUSH、LINSERT等添加命令而被取消  这三个添加新元素到列表命令底层都是由pushGenericCommand函数实现 当向一个空键推入新元素时，该函数执行两件事：  检查键是存在于server.db[i]-blocking_keys字典里，如果有，为这个键创建一个redis.h/readyList结构，并将它添加到server.ready_keys链表中。 将给定的值添加到列表键中    readyList结构定义：\ntypedef struct readyList { redisDb *db; // 指向该键所在的数据库  robj *key; // 指向造成阻塞的键 } readyList;  Redis主进程执行完pushGenericCommand函数后，继续调用handleClientsBlockedOnLists：  如果server.ready_keys不为空，弹出表头元素，并取出元素中的readyList值 根据readyList在server.blocking_keys中查找因为key被阻塞的客户端（以链表形式保存） 如果key不为空，弹出一个元素，并弹出客户端链表的第一个客户端，然后将被弹出的元素返回给被弹出客户端作为阻塞原语的返回值 根据readyList结构的属性，删除server.blocking_keys中响应的客户端数据，取消客户端的阻塞状态 继续执行步骤3和4直到key没有元素可弹出，或者没有阻塞的客户端 继续执行步骤1，直到server.ready_keys链表所有的readyList都被处理完    3.4.6 先阻塞先服务（FBFS）策略 3.4.7 阻塞因超过最大等待时间而被取消  每次Redis常规操作函数（server cron job）执行时，程序都会检查所有连接到服务器的客户端，查看哪些处于“正在阻塞”状态的客户端的最大阻塞时限是否已经过期 如果已经过期，给客户端返回空白回复，然后撤销对客户端阻塞  3.5 集合  REDIS_SET是SADD、SRANDMEMBER等命令的操作对象，它使用REDIS_ENCODING_INTSET和REDIS_ENCODING_HT两种方式编码  3.5.1 编码的选择  第一个添加到集合的元素，决定了创建集合所使用的编码  第一个元素可以表示成long long类型，集合初始编码为REDIS_ENCODING_INTSET 否则，初始编码为REDIS_ENCODING_HT    3.5.2 编码的切换  REDIS_ENCODING_INTSET切换到REDIS_ENCODING_HT。以下任一条件：  intset保存的整数值个数超过server.set_max_intset_entries （默认512） 试图往集合添加一个新元素，并且这个元素不能被表示为long long类型    3.5.3 字典编码的集合  当使用REDIS_ENCODING_HT编码时，集合将元素保存在字典的键里面，值统一为NULL  3.5.4 集合命令的实现  主要对intset和dict两个数据结构的操作函数的包装，以及一些两种编码之间进行转换的函数  3.5.5 求交集算法  SINTER SINTERSTORE O(n^2)  3.5.6 求并集算法  SUNION SUNIONSTORE O(n)  3.5.7 求差集算法  SDIFF SDIFFSTORE O(n^2)  3.6 有序集 REDIS_SET是ZADD、ZCOUNT等命令的操作对象，它使用REDIS_ENCODING_ZIPLIST和REDIS_ENCODING_SKIPLIST两种方式编码：\n3.6.1 编码的选择  通过ZADD添加第一个元素到空key时，决定  满足以下条件，使用REDIS_ENCODING_ZIPLIST  服务器属性server.zset_max_ziplist_entries的值大于0 （默认128） 元素的member长度小于服务器属性server.zset_max_ziplist_value的值（默认64）   否则，创建REDIS_ENCODING_SKIPLIST编码的有序集    3.6.2 编码的转换  REDIS_ENCODING_ZIPLIST转换为REDIS_ENCODING_SKIPLIST，满足以下任一条件：  ziplist所保存的元素超过server.zset_max_ziplist_entries （默认128） 新添加元素member的长度大于server.zset_max_ziplist_value （默认64）    3.6.3 ZIPLIST编码的有序集  每个有序集元素以两个相邻的ziplist节点表示，第一个节点保存元素的member域，第二个元素保存元素的score域 多个元素之间按score值从小到大排序，如果两个元素的score相同，那么按字典序对member进行对比，决定元素顺序   查找复杂度O(n) 添加/删除/更新复杂度都不低于O(n)  3.6.4 SKIPLIST编码的有序集   当使用REDIS_ENCODING_SKIPLIST编码时，有序集元素由redis.h/zset结构来保存：\n  typedef struct zset { dict *dict; // 字典  zskiplist *zsl; // 跳跃表 } zset;     zset同时使用字典和跳跃表两个数据结构来保存有序集元素\n  元素的成员由一个redisObject结构表示，元素的score则是一个double类型的浮点数，字典和跳跃表两个结构通过将指针共同指向这两个值来节约空间\n  字典结构：member作为键，score作为值，有序集可以在O(1)负责度内：\n 检查member是否存在 取出member对应的score值 （ZSCORE）    跳跃表：可以让有序集支持一下操作：\n O(logN)期望时间、O(n)最坏时间内根据score对member进行定位 范围行查找和处理操作 ZRANGE ZRANK ZINTERSTORE等    4、功能的实现 4.1 事务  Redis通过MULTI、DISCARD、EXEC、WATCH四个命令来实现事务功能  4.1.1 事务   事务提供一种“将多个命令打包，然后一次性、按顺序地执行”的机制，并且事务在执行期间不会主动终端—服务器在执行完事务中所有的命令后，才会继续处理其他客户端的其他命令\n  事务执行阶段\n 开始事务 命令入队 执行事务    4.1.2 开始事务  WATCH命令的执行标记着事务的开始 这个命令唯一做的，将客户端REDIS_MULTI选项打开，让客户端从非事务状态切换到事务状态  4.1.3 命令入队  当客户端处于非事务状态时，所有发送给服务端的命令都会立即被执行 当客户端处于事务状态时，服务器在收到客户端命令时，不会立即执行，而是将这些命令全部让如一个事务队列，然后返回QUEUED，表示命令已入队 事务队列是一个数组，每个元素包含三个属性  要执行的命令（cmd） 命令的参数（argv） 参数的个数（argc）    4.1.4 执行事务  不是所有命令都会被放入事务队列：EXEC、DISCARD、MULTI、WATCH这四个命令会被立即执行 当EXEC命令执行时  服务器根据客户端所保存的事务队列，以先进先出（FIFO）方式执行    4.1.5 在事务和非事务状态下执行命令  无论事务状态还是非事务状态，Redis命令都是由同一个函数执行，所以他们共享服务器一般配置，比如AOF配置、RDB配置以及内存限制等 事务中的命令和普通命令区别：  非事务状态下的命令以单个命令为单位执行，前一个命令和后一个的客户端不一定是同一个；事务状态则是以事务为单位：除非当前事务执行完毕，否则服务器不会中断事务，也不会执行其他客户端的其他命令。 非事务状态下，执行命令结果立即返回给客户端；事务状态下所有命令的结果集合到回复队列，在做EXEC命令的结果返回客户端。    4.1.6 事务状态下的DISCARD、MULTI、WATCH  DISCARD用于取消一个事务，清空客户端的整个事务队列，然后将客户端从事务状态调整回非事务状态，最后返回OK Redis的事务不可嵌套。事务状态下发送MULTI，服务器只是简繁返回错误，然后继续等待其他命令入队。不会造成事务失败或修改 WATCH只能在客户端进入事务之前执行，否则会引发错误。但它不会造成事务失败，也不会修改事务队列已有数据。  4.1.7 带WATCH的事务  WATCH命令用于在事务开始之前监视任意数量的键：当调用EXEC命令执行事务时，如果任意一个被监视的键已经被其他客户端修改了，那么整个事务不在执行，直接返回失败。  4.1.8 WATCH命令的实现  在每个数据库redis.h/redisDb的数据类型中，保存了一个watched_keys字典，字典的键时整个数据库被监视的键，字典的值则是一个链表，链表中保存了所有监视这个键的客户端。 WATCH命令的作用就是：将当前客户端和要监视的键在watched_keys中进行关联  4.1.9 WATCH的触发  在任何对数据库键空间进行修改的命令成功执行之后，multi.c/touchWatchKey函数都会被调用，它检查数据库的watched_keys字典，看是否有客户端在监视已经被命令修改的键，如果有，程序将所有监视这个键的客户端的REDIS_DIRTY_CAS选项打开 当客户端发送EXEC命令、出发事务执行时，会对客户端状态进行检查  如果REDIS_DIRTY_CAS被打开，直接返回空回复，表示事物执行失败 如果REDIS_DIRTY_CAS没有打开，说明安全，正式执行事务   最后，当一个客户端结束他的事务时，无论事务成功失败，watched_keys字典中和这个客户端有关的资料都会别清除  4.1.10 事务的ACID性质  原子性（Atomicity）  单个Redis命令的执行事原子性的，但Redis没有在事务上增加任何维持原子性的机制，所以Redis事务不是原子性的 如果一个事务队列所有命令都被成功执行，那么称这个事务执行成功 如果Redis服务器进程在执行事务过程中被停止，那么事务执行失败 事务失败时，Redis也不会进行任何的重试或者回滚操作   一致性（Consistency）  Redis的一致性：入队错误、执行错误、Redis进程被终结 入队错误  在命令入队时，如果客户端发送错误的命令，服务端会向客户端返回一个出错信息，并且将客户端的事务状态设置为REDIS_DIRTY_EXEC 当客户端执行EXEC时，Redis拒绝执行状态为REDIS_DIRTY_EXEC的事务，并返回失败信息 因此，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性   执行错误  如果命令在事务执行过程中发生错误，Redis只会将错误包含在事务的结果中，不会引起事务的中断或整个失败 不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令 所以它对事务的一致性没有影响   Redis进程被终结  根据Redis持久化模式：  内存模式：没有任何持久化机制，重启后数据库总是空白，所以数据总是一致 RDB模式：事务进行中，不会中断Redis执行保存RDB保存工作，所以数据库是一致的 AOF模式：因为AOF后台进行：  事务语句未被写入AOF文件，还原后是一致的 事务语句被写入AOF文件。重启Redis，程序会检测AOF文件并不完整，Redis会退出，并报告错误。需要使用redis-check-aof工具将部分成功事务命令移除之后，才能再次启动服务器。还原后是一致的       隔离性（Isolation）  Redis是单进程程序，并且保证执行事务时不会对事务进行中断，所以具有隔离性   持久性（Durability）  因为事务只是用队列包裹了一组Redis命令，没有提供任何额外的持久性功能，所以事务的持久性由Redis所使用的的持久化模式决定  内存模式：不持久 RDB模式：不持久 AOF模式：异步保存有时间间隔，也不持久        4.1.11 小结  事务提供一种将多个命令打包，然后一次性、有序地执行的机制 事务执行过程中不会被中断，所有事务命令执行完之后，事务才能结束 多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。 带WATCH命令的事务会将客户端和被监视的键在数据库的 watched_keys 字典中进行关 联，当键被修改时，程序会将所有监视被修改键的客户端的 REDIS_DIRTY_CAS 选项打开。 只有在客户端的 REDIS_DIRTY_CAS 选项未被打开时，才能执行事务，否则事务直接返回 失败。 Redis 的事务保证了 ACID 中的一致性（C）和隔离性（I），但并不保证原子性（A）和 持久性（D）。  4.2 订阅与发布  Redis通过PUBLISH、SUBSCRIBE等命令实现了订阅与发布模式  4.2.1 频道的订阅与信息发送  SUBSCRIBE命令可以让客户端订阅任意数量的频道 当有消息通过PUBLISH命令发送给频道时，这个消息就会被发送给订阅他的所有客户端  4.2.2 订阅频道   每个Redis服务器进程都维持这个一个表示服务器状态的redis.h/redisServer结构，结构的pubsub_channels属性是一个字典，用于保存订阅频道的信息\n  struct redisSercer { dict *pubsub_channels; }   字典的键为正在被订阅的频道，值为一个链表，保存了所有订阅这个频道的客户端\n  当客户端调用SUBSCRIBE时，程序就将客户端和要订阅的频道在pubsub_channels字典中关联起来\n    4.2.3 发送信息到频道  首先根据channel定位到字典的键 将信息发送给字典链表中的所有客户端  4.2.4 退订频道  UNSUBSCRIBE，从pubsub_channels字典的给定频道（键）中，删除关于当前客户端的信息  4.2.5 模式的订阅与信息发送 4.2.6 订阅模式   redisServer.pubsub_patterns属性是一个链表，保存着所有和模式先关的信息\n  struct redisServer { list *pubsub_patterns; }     链表的每个节点都包含一个redis.h/pubsubPattern结构\n  typedef struct pubsubPattern { redisClient *client; // 订阅模式的客户端  robj *pattern; // 被订阅的模式 } pubsubPattern;     调用PSUBSCRIBE时，程序就创建一个包含客户端和被订阅模式的pubsubPattern结构，并将该结构添加到redisServer.pubsub_patterns链表中\n  4.2.7 发送信息到模式  PUBLISH  4.2.8 退订模式  PUNSUBSCRIBE  4.2.9 小结  订阅信息由服务器进程维持的redisServer.pubsub_channels字典保存，字典的键为被订阅的频道，字典的值为订阅频道的所有客户端 当有新消息发送到频道时，程序遍历频道所对应的所有客户端，然后将消息发送到订阅频道的客户端上 订阅模式的信息由服务器进程维持的redisServer.pubsub_patterns链表来保存，链表的每个节点都保存一个pubsubPattern结构。 当有新消息发送到频道时，除了订阅频道的客户端回收到消息之外，所有订阅了匹配频道的模式的客户端，也同样会收到消息 退订频道和退订模式分别的订阅频道和订阅模式的反操作  4.3 Lua脚本 4.3.1 初始化Lua环境  在初始化Redis服务器时 Redis对Lua环境进行了一系列修改，包括添加数据库、更换随机函数、保护全局变量等 初始化步骤  调用lua_open函数，创建一个新的Lua环境 载入指定的Lua函数库，包括：  基础库（base lib） 表格库（table lib） 字符串库（string lib） 数学库（math lib） 调试库（debug lib） 用于处理JSON的cjson库 在Lua值和C结构（struct）之间进行转换的struct库 处理MessagePack数据的cmsgpack库   屏蔽一些可能对Lua环境产生安全问题的函数，比如loadfile 创建一个Redis字典，保存Lua脚本，并在复制（replication）脚本时使用。字典的键为SHA1校验和，字典的值为Lua脚本 创建一个redis全局表格到Lua环境，表格中包含了各种对Redis进行操作的函数 用Redis自己定义的随机生成函数，替换math表原有的math.random函数和math.randommseed函数 创建一个对Redis多批量回复（multi bulk reply）进行排序的辅助函数 对Lua环境中的全局变量进行保护，以免被传入的脚本修改 因为Redis命令必须客户端执行，所以需要在服务器状态中创建一个无网络链接的伪客户端（fake client），专门用于执行Lua脚本中包含的Redis命令。 将Lua环境的指针记录到Redis服务器的全局状态中，等候Redis的调用。    4.3.2 脚本的安全性  问题  如果一段Lua脚本带有随机性质或作用，那么当这段脚本在附属节点运行时，或者从AOF文件载入重新运行时，带到的结果可能和之前运行的结果完全不同   解决  Redis对Lua环境所能执行的脚本做了一个严格的限制：所有的脚本都必须是无副作用的纯函数（pure function）   策略  不提供访问系统状态的库（比如系统时间库） 进制使用loadfile函数 阻止带有随机性质命令的脚本执行 如果脚本执行带有随机命令的读，会先被执行一个自动的字典序排序，保证输出结果有序 用Redis自己定义的随机生成函数，替换Lua环境中math表原有的随机函数。新函数性质：每次执行Lua脚本，除非显式地调用math.randomseed，否则math.random 生成的伪随机数序列总是相同的。   保证：  无副作用 没有有害的随机性 对于同样的输入参数和数据集，总是产生相同的写入命令    4.3.3 脚本的执行  EVAL、EVALSHA 执行Lua脚本 EVALSHA基于EVAL  4.3.4 EVAL命令的实现   EVAL的执行分为以下步骤：\n 为输入脚本定义一个Lua函数 执行这个Lua函数    定义Lua函数\n  函数名以f_为前缀，后跟脚本的SHA1校验和\n  // EVAL \"return 'hello world'\" 0  function f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91() return 'hello world' end     好处：\n 执行步骤简单，只要调用和脚本相对应的函数 Lua环境保持清洁，已有的脚本和新加入的脚本不会互相干扰，可以将重置Lua环境和调用Lua GC的次数降到最低 如果某个脚本对应的函数的Lua被定义过，只需要记得这个脚本的SHA1校验和      执行Lua函数\n 将EVAL命令输入的KEYS参数和ARGV参数以全局数组的方式传入到Lua环境中 设置伪客户端的目标数据为调用者客户端的目标数据库 为Lua环境装载超时钩子，保证脚本执行超时可以杀死脚本，或者停止Redis服务器 执行脚本对应的Lua函数 如果脚本有SELECT命令，那么需要对调用者客户端的目标数据库进行更新 执行清理操作：清除钩子；清除指向调用者客户端的指针等 将Lua函数指定所得结果转换成Redis回复，传给客户端 对Lua环境进行一次单步的渐进式GC    4.3.5 EVALSHA命令的实现  只要脚本对应的函数在Lua里定义过，即使用户不知道脚本的内容本身，也可以直接通过脚本的SHA1校验和来掉调用  4.3.6 小结  初始化Lua脚本环境需要一系列步骤 Redis通过一系列措施保证Lua脚本无副作用，也没有有害的写随机性 EVAL命令为输入脚本定义一个Lua函数，然后通过函数执行脚本 EVALSHA通过构建函数名，直接调用Lua中定义的函数，从而执行脚本  4.4 慢查询日志  慢查询日志是Redis提供的一个用于观察系统性能的功能  4.4.1 相关数据结构  慢日志结构定义：  // slowlog.h/slowlogEntry  typedef struct slowlogEntry { robj **argv; // 命令参数  int argc; // 命令参数数量  long long id; // 唯一标识符  long long duration; // 执行消耗的时间，以纳秒为单位  time_t time; // 命令执行时间 } slowlogEntry;   记录服务器状态的redis.h/redisServer结构\n  struct redisServer { list *slowlog; // 保存慢查询日志的链表  long long slowlog_entry_id; // 慢查询日志当前id值  long long slowlog_log_slower_than; // 慢查询时间限制  unsigned long slowlog_max_len; // 慢查询日志最大条目数量 }   slowlog从新到旧排序链表\n  slowlog_entry_id在创建慢日志后加一，用于产生慢查询日志ID（SLOW LOG之后被重置）\n  slowlog_log_slower_than：命令执行时间上限\n  slowlog_max_len：日志数量等于这个值，添加新日志，最旧的日志会被删除\n    4.4.2 慢查询日志的记录  Redis记录命令执行前的时间，执行完成后计算耗费时间duration，并传给slowlogPushEntryIfNeed函数 如果duration超过server.slowlog_log_slower_than，slowlogPushEntryIfNeed就会创建一条心的慢查询日志，加入慢查询日志链表  4.4.3 慢查询日志的操作  查看日志 O(n) 清空日志 O(n) 获取日志数量 O(1)  4.4.4 小结  Redis用一个链表以FIFO的顺序保存所有的慢查询日志 每条慢查询日志记录执行超时的命令、命令的参数、命令执行时间、命令所消耗的时间等信息  5、内部运作机制 5.1 数据库 5.1.1 数据库的结构   Redis中的每个数据库，都是由一个redis.h/redisDb结构表示：\n  typedef struct redisDb { int id; // 保存着数据库以整数表示的号码  dict *dict; // 保存着数据库中的所有键值对数据。也被称为键空间  dict *expires; // 保存着键的过期信息  dict *blocking_keys; // 实现列表阻塞原语  dict *ready_keys; dict *watched_keys; // 用于MATCH命令。事务 } redisDb;     5.1.2 数据库的切换   redisDb结构的id保存着数据库的号码 Redis初始化时，会创建redis.h/REDIS_DEFAULT_DBNUM个数据库，并将所有数据库保存到redis.h/redisServer.db数组中，每个数据库id从0到REDIS_DEFAULT_DBNUM - 1 当执行SELECT number时，程序使用redisServer.db[number]来切换数据库  5.1.3 数据库键空间  Redis是键值对数据库，所以它的数据库本身也是一个字典(key space)  字典的键是一个字符串对象 字典的值则可以使包括字符串、列表、哈希表、集合、有序集在内的任意一种Redsi类型对象   redisDb结构的dict属性，保存着数据库所有的键值对数据  5.1.4 键空间的操作   因为数据库本身是一个字典，所以对数据库的操作基本上都是对字典的操作，加上一些维护操作\n  添加新键\n  删除键\n  更新键\n  取值\n  其他操作\n FLUSHDB RANDOMKEY DBSIZE EXISTS RENAME    5.1.5 键的过期时间  EXPIRE、PEXPIRE、EXPIREAT、PEXPIREAT  5.1.6 过期时间的保存  redisDb结构的expires字典里  expires字典的键是一个执行dict字典里某个键的指针，字典的值是过期时间long long类型    5.1.7 设置生存时间  Redis有四个命令设置键的生存时间和过期时间 但是，expires字典的值只保存“以毫秒为单位的过期UNIX时间戳”  5.1.8 过期键的判定  通过expires字典，通过以下步骤检查  检查键是否在expires字典；如果存在，那么取出键的过期时间 通过与当前UNIX时间戳对比没判断是否过期    5.1.9 过期键的清除  三种删除方式  定时删除：在设置键的过期时间时，创建一个定时事件，当过期时间到达时，由事件处理器自动执行键的删除操作 惰性删除：放任键过期不管，但是在每次从dict字典取出键时，检查是否过期，过期则删除并返回空 定期删除：每隔一段时间，对expires字典进行检查，删除过期键   定时删除  对内存最友好：因为能保证过期键第一时间被删除 缺点：  对CPU时间最不友好：因为删除操作可能会占用大量的CPU时间 目前Redis事件处理器对时间事件的实现方式–无序链表，查找复杂度O(n)，不适合用来处理大量时间事件     惰性删除  对CPU最友好：只会在取出键时进行检查 缺点  对内存最不友好：内存已知占用不被释放     定期删除  上述两种的折中策略 每隔一段时间执行一次删除操作，并通过限制删除操作执行的时长和频率，来减少删除操作对CPU时间的影响 通过定期删除过期键，有效的减少内存浪费   Redis使用的策略  惰性删除 + 定期删除    5.1.10 过期键的惰性删除策略  db.c/expireIfNeeded函数。 所有命令在读取或写入数据库之前都会调用expireIfNeeded函数对键进行检查 expireIfNeeded的作用是，如果输入键过期的话，将键、值、键保存在expires字典中的过期时间都删除掉  5.1.11 过期键的定期删除策略  redis.c/activeExpireCycle函数。 每当Redis的例行处理程序serverCron执行时，activeExpireCycle都会被调用 这个函数在规定时间限制内，尽可能地遍历各个数据库的expires字典，随机的检查一部分键的过期时间，并删除其中的过期键  5.1.12 过期键对AOF、RDB和复制的影响  更新后的RDB文件  在创建RDB文件时，程序会对键进行检查，过期的键不会被写入到更新后的RDB文件中   AOF文件  过期键在被惰性删除或定期删除之前，不会有任何影响，AOF不会被修改 过期键被删除后，程序会向AOF文件追加一条DEL命令   AOF重写  重写时，程序会检查键，过期的键不会被保存到重写后的AOF文件   复制  过期键的删除由主节点统一控制  如果是主节点，它删除一个过期键后，会显式地向所有附属节点发送一个DEL命令 如果是附属节点，碰到过期键，会返回已过期的回复，但是不会删除。      5.1.13 数据库空间的收缩和扩展  字典的 扩展/收缩规则 redis.c/tryResizeHashTables函数检查数据库是否需要收缩 每次redis.c/serverCron函数运行时，被调用  5.1.14 小结  数据库主要由dict和expires两个字典构成，dict保存键值对，expires保存键的过期时间 数据库的键总是一个字符串对象，值可以使任意一种Redis数据类型，包括字符串、哈希表、集合、列表、有序集 expires的某个键和dict的某个键共同指向同一个字符串对象，而expires键的值则是该键以毫秒计算的UNIX过期时间戳 Redis使用惰性删除和定期删除两种策略来删除过期的键 更新后的RDB文件和重写后的AOF文件不会保留过期的键 当一个过期的键被删除之后，程序会追加一条新的DEL命令到AOF文件 当主节点删除一个过期键后，会显式的发送一条DEL命令到所有附属节点 附属节点发现过期键后，不会删除，而是等待主节点发来DEL命令，保证数据一致 数据库的dict和expires字典的扩展策略和普通字典一样。当填充百分比不足10%时，将可用节点数量减少至大于等于当前已用节点数量。  5.2 RDB  RDB核心是rdbSave和rdbLoad函数，前者用于生成RDB文件到磁盘，后者用于将RDB文件中的数据重新载入到内存  5.2.1 保存  如果RDB文件已存在，新的RDB文件会替换已有的 RDB保存文件期间，主进程会被阻塞，知道保存完成为止 SAVE直接调用rdbSave，阻塞Redis主进程，知道保存完成为止 BGSAVE则fork出一个子进程，子进程负责调用rdbSave，并在保存完成后向主进程发送信号，通知保存已完成。  5.2.2 SAVE、BGSAVE、AOF写入、BGREWRITEFOF   SAVE\n SAVE执行时，新的SAVE、BGSAVE、BGREWRITEAOF调用不会产生任何多用 AOF写入是后台线程完成，BGREWRITEAOF由子进程完成，所以SAVE执行过程中，AOF写入、BGREWRITEAOF可以同时进行    BGSAVE\n 在指向SAVE之前，服务器会检查BGSAVE是否正在执行，如果是，不调用rdbSave，向客户端返回出错信息 当BGSAVE执行时，调用新的BGSAVE的客户端也会收到出错信息 BGSAVE执行时，BGREWRITEAOF的重写请求会被延迟到BGSAVE执行完毕 BGREWRITEAOF执行时，调用BGSAVE的客户端将收到出错信息 BGREWRITEAOF和BGSAVE不同时执行时处于性能考虑  并发两个子进程，并且两个子进程都同时进行大量的磁盘写入，性能问题      5.2.3 载入  Redis服务器启动时，rdbLoad函数就会被执行，它读取RDB文件，将文件中的数据库数据载入到内存中 在载入期间， 服务器每载入 1000 个键就处理一次所有已到达的请求， 不过只有 PUBLISH 、 SUBSCRIBE 、PSUBSCRIBE 、UNSUBSCRIBE 、PUNSUBSCRIBE 五个命令的请求会被正确地处理， 其他命令一律返回错误。等到载入完成之后，服务器才会开始正常处理所有命令。  发布与订阅功能和其他数据库功能是完全隔离的，前者不写入也不读取数据库，所以 在服务器载入期间，订阅与发布功能仍然可以正常使用，而不必担心对载入数据的完整性产生 影响。   AOF保存频率通常高于RDB。如果AOF功能打开会优先使用AOF文件还原数据  5.2.4 RDB文件结构  REDIS  文件开头保存REDIS五个字符，表示RDB文件的开始   RDB-VERSION  四字节长 记录RDB版本号（目前为0006） 因为不同版本的RDB文件不兼容，所以需要根据版本来选择不同的读入方式   DB-DATA  重复多次出现 每一个DB-DATA部分保存着服务器上一个非空数据库的所有数据数据   SELECT-DB  保存着跟在后面的键值对所属的数据库号码   KEY-VALUE-PAIRS  因为空数据库不会被保存到RDB文件，所以这部分至少包含一个键值对的数据 键值对数据结构   OPTIONAL-EXPIRE-TIME：记录着过期时间。可选，没有过期时间，该域不出现 KEY：键。格式和REDIS_ENCODING_RAW编码的字符串对象一样。 TYPE-OF-VALUE：记录VALUE域的值所使用的的编码 VALUE：不同类型格式不同     EOF  标志着数据库内容的结尾，值为rdb.h/EDIS_RDB_OPCODE_EOF   CHECK-SUM  校验和。uint_64t类型值 如果为0，表示Redis关闭了校验和功能    5.2.5 小结  rdbSave 会将数据库数据保存到 RDB 文件，并在保存完成之前阻塞调用者。 SAVE 命令直接调用 rdbSave ，阻塞 Redis 主进程；BGSAVE 用子进程调用 rdbSave ， 主进程仍可继续处理命令请求。 SAVE 执行期间，AOF 写入可以在后台线程进行，BGREWRITEAOF 可以在子进程进行，所以这三种操作可以同时进行。 为了避免产生竞争条件，BGSAVE执行时，SAVE 命令不能执行。 为了避免性能问题，BGSAVE 和 BGREWRITEAOF 不能同时执行。 调用 rdbLoad 函数载入 RDB 文件时，不能进行任何和数据库相关的操作，不过订阅与 发布方面的命令可以正常执行，因为它们和数据库不相关联。 RDB 文件的组织方式 键值对在 RDB 文件中的组织方式  RDB 文件使用不同的格式来保存不同类型的值。    5.3 AOF  RDB将数据库的快照以二进制方式保存到磁盘 AOF以协议文本方式，将所有对数据库进行过的写入命令（及参数）记录到AOF文件  5.3.1 AOF命令同步  同步命令到AOF文件的过程  命令传播：Redis将执行完的命令、参数、参数个数等信息发送到AOF程序中 缓存追加：AOF程序根据接收到的命令数据，将命令转换为网络通讯协议的格式，然后将协议内容追加到服务器的AOF缓存中 文件写入和保存：AOF缓存中的内容被写入AOF文件末尾，如果设定的AOF保存条件被满足的话，fsync函数或者fdatasync函数会被调用，将写入的内容真正地保存到磁盘中。    5.3.2 命令传播 5.3.3 缓存追加  协议文本生成之后，会被追加到redis.h/redisServer结构的aof_buf末尾 aof_buf保存着所有等待写入AOF文件的协议文本 缓存追加步骤  接受命令、命令的参数、参数个数、所使用的数据库等信息 将命令还原成Redis网络通讯协议 将协议文本追加到aof_buf末尾    5.3.4 文件写入和保存  每当服务器常规任务函数被执行或者时间处理器被执行时，aof.c/flushAppendOnlyFile函数都会被调用，进行：  WRITE：根据条件，将aof_buf中的缓存写入到AOF文件 SAVE：根据条件，调用fsync、fdatastnc函数，将AOF文件保存到磁盘中    5.3.5 AOF保存模式   Redis目前支持三种AOF保存模式：\n AOF_FSYNC_NO：不保存 AOF_FSYNC_EVERYSEC：每秒保存 AOF_FSYNC_ALWAYS：每次执行命令保存    不保存\n 每次调用flushAppendOnlyFile函数，WRITE都会被执行，SAVE会被略过 SAVE只会在一下任意一种情况下被执行  Redis被关闭 AOF功能被关闭 系统的写缓存被刷新（缓存满，或者定期保存操作）      每秒保存\n 每次调用flushAppendOnlyFile，有四种情况：  子进程正在执行SAVE  这个SAVE的执行时间未超过2秒，程序直接返回，并不执行WRITE或新的SAVE 这个SAVE已经执行超过2秒，那么程序执行WRITE但不执行SAVE，此时的WRITE必须等待子线程先完成SAVE   子进程没有执行SAVE  上次成功执行SAVE距今不超过1秒，那么程序执行WRITE不执行SAVE 上次成功执行SAVE距今超过1秒，那么程序执行WRITE和SAVE        每次执行命令保存\n 每次执行一个命令后，WRITE和SAVE都会被执行 SAVE是由Redis主进程执行，所以SAVE执行期间，主进程会被阻塞    5.3.6 AOF保存模式对性能和安全的影响  对主进程的阻塞  不保存：写入和保存都是由主进程执行，阻塞主进程 每秒保存：写入由主进程执行，阻塞主进程。保存由子线程执行，不阻塞，但保存操作完成的快嘛会影响写入操作的阻塞时长 每次执行命令保存：类似不保存   安全性  模式1最差 模式2兼顾性能和安全性 模式3安全性最高，性能最差    5.3.7 AOF文件的读取和数据还原  根据AOF文件里的协议，重新执行一遍里面指示的所有命令 读取AOF文件并还原步骤：  创建一个不带网络连接的伪客户端 读取AOF所保存文本，还原出命令、参数、参数个数 使用伪客户端完执行命令 执行2、3，直到AOF所有命令被执行完毕   为了避免对数据的完整性产生影响，在服务器载入数据的过程中，只有和数据库无关 的订阅与发布功能可以正常使用，其他命令一律返回错误。  5.3.8 AOF重写  为了解决AOF越来越大的问题 创建一个新的AOF文件来代替原有的AOF文件，新AOF文件和原有AOF文件保存的数据库状态完全一样，但新的AOF文件的体积小于等于原有AOF文件的体积  5.3.9 AOF重写的实现  AOF重写并不需要对原有的AOF文件进行任何写入和读取，它针对的是数据库中键的当前值 根据键的类型，使用适当的写入命令来重现键的当前值  5.3.10 AOF后台重写   好处\n 不阻塞主进程 子进程带有主进程的数据副本，使用子进程而不是线程，可以在避免锁的情况下，保证数据的安全性    子进程重写期间，主进程还需要继续处理，造成数据不一致\n Redis增加了AOF重写缓存，这个缓存在fork出子进程之后启用 Redis主进程在接到新的写命令后，除了将这个写命令追加到现有的AOF文件，还会追加到这个缓存中  保证AOF功能继续，即使停机也不会丢失数据 所有对数据库的修改都会被记录到AOF重写缓存中      子进程完成AOF重写后，向父进程发送一个完成信号，父进程：\n 将AOF重写缓存中的内容全部写入新的AOF文件 对新的AOF文件改名，覆盖原有的AOF文件    以上是AOF后台重写，也即是BGREWRITEAOF命令的工作原理\n  5.3.11 AOF后台重写的出发条件  通过调用BGREWRITEAOF手动触发 服务器在AOF开启后会维持三个变量  记录当前AOF文件大小的变量aof_current_size 记录最后一次AOF重写后的AOF文件大小aof_rewirte_base_size 增长百分比 aof_rewirte_perc   每次serverCron函数执行时，检查以下条件是否全部满足，是的话，会触发自动的AOF重写：  没有BGSAVE命令在执行 没有BGREWRITEAOF在执行 当前AOF文件大小大于server.aof_rewrite_min_size （默认1MB） 当前AOF文件大小和最后一次AOF重写后的大小之前比率大于等于指定的增长百分比（默认100%）    5.3.12 小结  AOF文件通过保存所有修改数据库的命令来记录数据库的状态 AOF文件的所有保存命令都以Redis通讯协议的格式保存 不同的AOF保存模式对数据的安全性、已经Redis的性能有很大的影响 AOF重写的目的是用更小的体积保存AOF文件，整个重写过程基本上不影响Redis主进程处理命令请求 AOF重写的实际重写工作是针对数据库的当前值来进行的，程序既不读写也不使用原有的AOF文件 AOF可以手动触发或自动触发  5.4 事件  事件是Redis的核心，处理两项重要的任务：  处理文件事件：在多个客户端中实现多路复用，接受它们发来的命令请求，并将命令的执行结果返回给客户端 时间事件：实现服务器常规操作（server cron job）    5.4.1 文件事件  Redis通过在多个客户端之间进行多路复用，从而实现高效的命令请求处理  多个客户端通过套接字连接Redis服务器，但只有在套接字可以无阻塞地进行读或者写时，服务器才会和这些客户端进行交互 Redis将这些因为套接字进行多路复用而产生的事件称为文件事件（file event），文件事件可以分为读事件和写事件两类   读事件  读事件标志着客户端命令请求的发送状态 当一个新客户端连接到服务器时，服务器会给该客户端绑定读事件，直到客户端断开连接之后，这个读事件才会被移除 读事件在整个网络连接的生命期内，都会在等待和就绪两种状态直接切换  当客户端连接到服务器，但并没有向服务器发送命令时，读事件处于等待状态 客户端发送命令，并且请求已到达（套接字可以无阻塞地执行读操作），读事件处于就绪状态     写事件  写事件标志着客户端对命令结果的接受状态 客户端自始至终都关联着读事件。服务端只会在有命令结果需要传回给客户端时，才会为客户端关联写事件 写事件会在两种状态之间切换：  当服务器有结果需要返回给客户端时，但客户端还未能执行无阻塞写，那么写事件处于等待状态 当服务器有结果需要返回给客户端时，并且客户端可以无阻塞写，那么写事件处于就绪状态      5.4.2 时间事件  事件事件记录着那些要在指定时间点运行的时间 多个时间事件以无序链表的形式保存在服务器状态中 每个时间事件主要由三个属性组成：  when：以毫秒格式的UNIX时间戳为单位，记录执行的时间 timeProc：时间处理函数 next：指向下一个时间事件，形成链表   根据timeProc函数的返回值，可以将时间事件划分为两类：  返回ae.h/AE_NOMORE，该事件为单词执行事件：处理一次后被删除，不再执行 如果返回非AE_NOMORE的整数，为循环执行事件：根据返回值更新when属性，一直更新运行下去    5.4.3 时间事件应用实例：服务器常规操作  服务器定期自检，这类操作成为常规操作（cron job） 由redis.c/serverCron实现，包括：  更新服务器各类统计时间，比如时间、内存占用、数据库占用情况等 清理数据库中的过期键值对 对不合理的数据库进行大小调整 关闭和清理链接失效的客户端 尝试进行AOF或RDB持久化操作 如果服务器时主节点的话，对附属节点进行定期同步 如果处于集群模式的话，对集群进行定期同步和链接测试   Redis将serverCron作为时间事件来运行，循环执行  5.4.4 事件的执行与调度  Redis中两种时间呈合作关系：  一种事件等待另一种事件执行完毕之后，才开始执行，事件之间不会出现抢占 时间处理器先处理文件事件（命令请求），在执行时间事件（调用serverCron） 文件时间的等待时间（类poll函数的最大阻塞时间），由距离到达时间最短的时间事件决定    5.4.5 小结  Redis事件分为时间事件和文件事件 文件时间分读事件和写事件：读事件实现命令请求的接收，写事件实现了命令结果的返回 时间时间分为单词执行事件和循环执行时间，服务器常规操作serverCron就是循环事件 文件事件和时间事件之间是合作关系：一种事件会等待另一种事件完成后在执行，不会出现抢占情况 时间事件的实际执行时间通常比预定时间晚一些  5.5 服务器与客户端 5.5.1 初始化服务器  初始化过程：  初始化服务器全局状态 载入配置文件 创建daemon进程 初始化服务器功能模块 载入数据 开始时间循环   初始化服务器全局状态  redis.h/redisServer记录了和服务器相关的所有数据   载入配置文件  Redis在初始完server变量之后，会读入配置文件和选项，根据这些配置来对server 变量的属性值做相应的修改   创建daemon进程  Redis默认以daemon进程方式运行，并创建相应的pid文件   初始化服务器功能模块  为server变量的数据结构子属性分配内存 初始化这些数据结构   载入数据  将RDB或AOF数据载入到服务器进程。AOF优先被使用   开始时间循环  5.5.2 客户端连接到服务器   当服务器完成初始化之后，就准备好接受客户端连接\n  客户端通过套接字函数connect到服务器，步骤：\n 服务器通过文件事件无阻塞地accept客户端连接，并返回一个套接字描述符fd 服务器为fd创建一个对应的redis.h/redisClient结构实例，并将该实例加入到服务器的已连接客户端链表中 服务器在事件处理器为该fd关联读文件请求    Redis以多路复用的方式来处理多个客户端，为每个已连接客户端维持一个redisClient结构：\n 套接字描述符 客户端正在使用的数据库指针和数据库号码 客户端的查询缓存和回复缓存 一个指向命令函数的指针，以及字符串形式的命令、命令参数、命令个数 客户端状态：SLAVE、MONITOR、事务状态 实现事务功能（MULTI、WATCH）所需的数据结构 实现阻塞功能（BLPOP、BRPOPLPUSH）所需的数据结构 实现订阅与发布功能（PUBLISH、SUBSCRIBE）所需的数据结构 统计数据和选项：客户端创建时间，和服务端最后交互时间，缓存大小等    5.5.3 命令的请求、处理和结果返回  客户端连上服务器之后，客户端就可以向服务器发送命令请求了 服务器处理客户端请求过程：  客户端通过套接字向服务器传送命令协议数据 服务器通过读事件来传入数据，并将数据保存在客户端对应的redisClient结构的查询缓存 根据客户端查询缓存中的内容，程序从命令表中查找响应命令的实现函数 程序执行实现函数，修改服务器的全局状态server变量，并将命令的执行结果保存到客户端redisClient结构的回复缓存，然后为该客户端的fd关联写事件 当客户端fd的写事件就绪时，将回复缓存中的命令结果传回给客户端    5.5.4 命令请求实例：SET的执行过程 5.5.5 小结  服务器经过初始化之后，才能开始接受命令 服务器初始化可以分为6个步骤 服务器为每个已连接的客户端维持一个客户端结构，保存这个客户端的所有状态信息 服务器处理客户端请求流程 ","wordCount":"1938","inLanguage":"en","datePublished":"2021-07-14T17:40:56+08:00","dateModified":"2021-07-14T17:40:56+08:00","author":{"@type":"Person","name":"Cuiks"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.cuiks.top/posts/redis_design_and_implement/"},"publisher":{"@type":"Organization","name":"Note Site","logo":{"@type":"ImageObject","url":"https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: #1d1e20;--entry: #2e2e33;--primary: rgba(255, 255, 255, 0.84);--secondary: rgba(255, 255, 255, 0.56);--tertiary: rgba(255, 255, 255, 0.16);--content: rgba(255, 255, 255, 0.74);--hljs-bg: #2e2e33;--code-bg: #37383e;--border: #333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://www.cuiks.top accesskey=h title="Note Site (Alt + H)"><img src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/dingdangcat-apple-touch-icon.png alt=logo aria-label=logo height=35>Note Site</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://www.cuiks.top/posts/ title=posts><span>posts</span></a></li><li><a href=https://www.cuiks.top/about/about title=about><span>about</span></a></li><li><a href=https://www.cuiks.top/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Redis设计与实现</h1><div class=post-meta>July 14, 2021&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Cuiks</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#1%e5%86%85%e9%83%a8%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=1、内部数据结构>1、内部数据结构</a><ul><li><a href=#11-%e7%ae%80%e5%8d%95%e5%8a%a8%e6%80%81%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label="1.1 简单动态字符串">1.1 简单动态字符串</a><ul><li><a href=#111-sds%e7%9a%84%e7%94%a8%e9%80%94 aria-label="1.1.1 sds的用途">1.1.1 sds的用途</a></li><li><a href=#112-redis%e4%b8%ad%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label="1.1.2 Redis中的字符串">1.1.2 Redis中的字符串</a></li><li><a href=#113-%e4%bc%98%e5%8c%96%e8%bf%bd%e5%8a%a0%e6%93%8d%e4%bd%9c aria-label="1.1.3 优化追加操作">1.1.3 优化追加操作</a></li><li><a href=#114-sds%e6%a8%a1%e5%9d%97%e7%9a%84api aria-label="1.1.4 sds模块的API">1.1.4 sds模块的API</a></li><li><a href=#115%e5%b0%8f%e7%bb%93 aria-label=1.1.5小结>1.1.5小结</a></li></ul></li><li><a href=#12-%e5%8f%8c%e7%ab%af%e9%93%be%e8%a1%a8 aria-label="1.2 双端链表">1.2 双端链表</a><ul><li><a href=#121-%e5%8f%8c%e7%ab%af%e9%93%be%e8%a1%a8%e7%9a%84%e5%ba%94%e7%94%a8 aria-label="1.2.1 双端链表的应用">1.2.1 双端链表的应用</a></li><li><a href=#122-%e5%8f%8c%e7%ab%af%e9%93%be%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="1.2.2 双端链表的实现">1.2.2 双端链表的实现</a></li><li><a href=#123-%e8%bf%ad%e4%bb%a3%e5%99%a8 aria-label="1.2.3 迭代器">1.2.3 迭代器</a></li><li><a href=#124-%e5%b0%8f%e7%bb%93 aria-label="1.2.4 小结">1.2.4 小结</a></li></ul></li><li><a href=#13-%e5%ad%97%e5%85%b8 aria-label="1.3 字典">1.3 字典</a><ul><li><a href=#131-%e5%ad%97%e5%85%b8%e7%9a%84%e5%ba%94%e7%94%a8 aria-label="1.3.1 字典的应用">1.3.1 字典的应用</a></li><li><a href=#132-%e5%ad%97%e5%85%b8%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="1.3.2 字典的实现">1.3.2 字典的实现</a></li><li><a href=#133-%e5%88%9b%e5%bb%ba%e6%96%b0%e5%ad%97%e5%85%b8 aria-label="1.3.3 创建新字典">1.3.3 创建新字典</a></li><li><a href=#134-%e6%b7%bb%e5%8a%a0%e9%94%ae%e5%80%bc%e5%af%b9%e5%88%b0%e5%ad%97%e5%85%b8 aria-label="1.3.4 添加键值对到字典">1.3.4 添加键值对到字典</a></li><li><a href=#135-%e6%b7%bb%e5%8a%a0%e6%96%b0%e5%85%83%e7%b4%a0%e5%88%b0%e7%a9%ba%e7%99%bd%e5%ad%97%e5%85%b8 aria-label="1.3.5 添加新元素到空白字典">1.3.5 添加新元素到空白字典</a></li><li><a href=#136-%e6%b7%bb%e5%8a%a0%e6%96%b0%e9%94%ae%e5%80%bc%e5%af%b9%e6%97%b6%e5%8f%91%e7%94%9f%e7%a2%b0%e6%92%9e%e5%a4%84%e7%90%86 aria-label="1.3.6 添加新键值对时发生碰撞处理">1.3.6 添加新键值对时发生碰撞处理</a></li><li><a href=#137-%e6%b7%bb%e5%8a%a0%e6%96%b0%e9%94%ae%e5%80%bc%e5%af%b9%e6%97%b6%e8%a7%a6%e5%8f%91%e4%ba%86rehash%e6%93%8d%e4%bd%9c aria-label="1.3.7 添加新键值对时触发了rehash操作">1.3.7 添加新键值对时触发了rehash操作</a></li><li><a href=#138-rehash%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b aria-label="1.3.8 rehash执行过程">1.3.8 rehash执行过程</a></li><li><a href=#139-%e6%b8%90%e8%bf%9b%e5%bc%8frehash aria-label="1.3.9 渐进式rehash">1.3.9 渐进式rehash</a></li><li><a href=#1310-%e5%ad%97%e5%85%b8%e7%9a%84%e6%94%b6%e7%bc%a9 aria-label="1.3.10 字典的收缩">1.3.10 字典的收缩</a></li><li><a href=#1311-%e5%ad%97%e5%85%b8%e5%85%b6%e4%bb%96%e6%93%8d%e4%bd%9c aria-label="1.3.11 字典其他操作">1.3.11 字典其他操作</a></li><li><a href=#1312-%e5%ad%97%e5%85%b8%e7%9a%84%e8%bf%ad%e4%bb%a3 aria-label="1.3.12 字典的迭代">1.3.12 字典的迭代</a></li><li><a href=#1313-%e5%b0%8f%e7%bb%93 aria-label="1.3.13 小结">1.3.13 小结</a></li></ul></li><li><a href=#14-%e8%b7%b3%e8%b7%83%e8%a1%a8 aria-label="1.4 跳跃表">1.4 跳跃表</a><ul><li><a href=#141-%e8%b7%b3%e8%b7%83%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="1.4.1 跳跃表的实现">1.4.1 跳跃表的实现</a></li><li><a href=#142-%e8%b7%b3%e8%b7%83%e8%a1%a8%e7%9a%84%e5%ba%94%e7%94%a8 aria-label="1.4.2 跳跃表的应用">1.4.2 跳跃表的应用</a></li><li><a href=#143-%e5%b0%8f%e7%bb%93 aria-label="1.4.3 小结">1.4.3 小结</a></li></ul></li></ul></li><li><a href=#2%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=2、内存映射数据结构>2、内存映射数据结构</a><ul><li><a href=#21-%e6%95%b4%e6%95%b0%e9%9b%86%e5%90%88 aria-label="2.1 整数集合">2.1 整数集合</a><ul><li><a href=#211-%e6%95%b4%e6%95%b0%e9%9b%86%e5%90%88%e7%9a%84%e5%ba%94%e7%94%a8 aria-label="2.1.1 整数集合的应用">2.1.1 整数集合的应用</a></li><li><a href=#222-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%92%8c%e4%b8%bb%e8%a6%81%e6%93%8d%e4%bd%9c aria-label="2.2.2 数据结构和主要操作">2.2.2 数据结构和主要操作</a></li><li><a href=#213-intset-%e8%bf%90%e8%a1%8c%e5%ae%9e%e4%be%8b aria-label="2.1.3 intset 运行实例">2.1.3 intset 运行实例</a></li><li><a href=#214-%e5%8d%87%e7%ba%a7 aria-label="2.1.4 升级">2.1.4 升级</a></li><li><a href=#215-%e5%85%b3%e4%ba%8e%e5%8d%87%e7%ba%a7 aria-label="2.1.5 关于升级">2.1.5 关于升级</a></li><li><a href=#216-%e5%85%b3%e4%ba%8e%e5%85%83%e7%b4%a0%e7%a7%bb%e5%8a%a8 aria-label="2.1.6 关于元素移动">2.1.6 关于元素移动</a></li><li><a href=#217-%e5%85%b6%e4%bb%96%e6%93%8d%e4%bd%9c aria-label="2.1.7 其他操作">2.1.7 其他操作</a></li><li><a href=#218-%e5%b0%8f%e7%bb%93 aria-label="2.1.8 小结">2.1.8 小结</a></li></ul></li><li><a href=#22-%e5%8e%8b%e7%bc%a9%e5%88%97%e8%a1%a8 aria-label="2.2 压缩列表">2.2 压缩列表</a><ul><li><a href=#221-ziplist%e7%9a%84%e6%9e%84%e6%88%90 aria-label="2.2.1 ziplist的构成">2.2.1 ziplist的构成</a></li><li><a href=#222-%e8%8a%82%e7%82%b9%e7%9a%84%e6%9e%84%e6%88%90 aria-label="2.2.2 节点的构成">2.2.2 节点的构成</a></li><li><a href=#223-%e5%88%9b%e5%bb%ba%e6%96%b0-ziplist aria-label="2.2.3 创建新 ziplist">2.2.3 创建新 ziplist</a></li><li><a href=#224-%e5%b0%86%e8%8a%82%e7%82%b9%e6%b7%bb%e5%8a%a0%e5%88%b0%e6%9c%ab%e7%ab%af aria-label="2.2.4 将节点添加到末端">2.2.4 将节点添加到末端</a></li><li><a href=#225-%e5%b0%86%e8%8a%82%e7%82%b9%e6%b7%bb%e5%8a%a0%e5%88%b0%e6%9f%90%e4%b8%aa%e6%9f%90%e4%ba%9b%e8%8a%82%e7%82%b9%e7%9a%84%e5%89%8d%e9%9d%a2 aria-label="2.2.5 将节点添加到某个/某些节点的前面">2.2.5 将节点添加到某个/某些节点的前面</a></li><li><a href=#226-%e5%88%a0%e9%99%a4%e8%8a%82%e7%82%b9 aria-label="2.2.6 删除节点">2.2.6 删除节点</a></li><li><a href=#227-%e9%81%8d%e5%8e%86 aria-label="2.2.7 遍历">2.2.7 遍历</a></li><li><a href=#228-%e6%9f%a5%e6%89%be%e5%85%83%e7%b4%a0%e6%a0%b9%e6%8d%ae%e5%80%bc%e5%ae%9a%e4%bd%8d%e8%8a%82%e7%82%b9 aria-label="2.2.8 查找元素，根据值定位节点">2.2.8 查找元素，根据值定位节点</a></li><li><a href=#229-%e5%b0%8f%e7%bb%93 aria-label="2.2.9 小结">2.2.9 小结</a></li></ul></li></ul></li><li><a href=#3redis%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label=3、Redis数据类型>3、Redis数据类型</a><ul><li><a href=#31-%e5%af%b9%e8%b1%a1%e5%a4%84%e7%90%86%e6%9c%ba%e5%88%b6 aria-label="3.1 对象处理机制">3.1 对象处理机制</a><ul><li><a href=#311-redisobject%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%bb%a5%e5%8f%8aredis%e7%9a%84%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label="3.1.1 redisObject数据结构，以及Redis的数据类型">3.1.1 redisObject数据结构，以及Redis的数据类型</a></li><li><a href=#312-%e5%91%bd%e4%bb%a4%e7%9a%84%e7%b1%bb%e5%9e%8b%e6%a3%80%e6%9f%a5%e5%92%8c%e5%a4%9a%e6%80%81 aria-label="3.1.2 命令的类型检查和多态">3.1.2 命令的类型检查和多态</a></li><li><a href=#313-%e5%af%b9%e8%b1%a1%e5%85%b1%e4%ba%ab aria-label="3.1.3 对象共享">3.1.3 对象共享</a></li><li><a href=#314-%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%e4%bb%a5%e5%8f%8a%e5%af%b9%e8%b1%a1%e7%9a%84%e9%94%80%e6%af%81 aria-label="3.1.4 引用计数以及对象的销毁">3.1.4 引用计数以及对象的销毁</a></li><li><a href=#315-%e5%b0%8f%e7%bb%93 aria-label="3.1.5 小结">3.1.5 小结</a></li></ul></li><li><a href=#32-%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label="3.2 字符串">3.2 字符串</a><ul><li><a href=#321-%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%bc%96%e7%a0%81 aria-label="3.2.1 字符串编码">3.2.1 字符串编码</a></li><li><a href=#322-%e7%bc%96%e7%a0%81%e7%9a%84%e9%80%89%e6%8b%a9 aria-label="3.2.2 编码的选择">3.2.2 编码的选择</a></li><li><a href=#323-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="3.2.3 字符串命令的实现">3.2.3 字符串命令的实现</a></li></ul></li><li><a href=#33-%e5%93%88%e5%b8%8c%e8%a1%a8 aria-label="3.3 哈希表">3.3 哈希表</a><ul><li><a href=#331-%e5%ad%97%e5%85%b8%e7%bc%96%e7%a0%81%e7%9a%84%e5%93%88%e5%b8%8c%e8%a1%a8 aria-label="3.3.1 字典编码的哈希表">3.3.1 字典编码的哈希表</a></li><li><a href=#332-%e5%8e%8b%e7%bc%a9%e5%88%97%e8%a1%a8%e7%bc%96%e7%a0%81%e7%9a%84%e5%93%88%e5%b8%8c%e8%a1%a8 aria-label="3.3.2 压缩列表编码的哈希表">3.3.2 压缩列表编码的哈希表</a></li><li><a href=#333-%e7%bc%96%e7%a0%81%e7%9a%84%e9%80%89%e6%8b%a9 aria-label="3.3.3 编码的选择">3.3.3 编码的选择</a></li><li><a href=#334-%e5%93%88%e5%b8%8c%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="3.3.4 哈希命令的实现">3.3.4 哈希命令的实现</a></li></ul></li><li><a href=#34-%e5%88%97%e8%a1%a8 aria-label="3.4 列表">3.4 列表</a><ul><li><a href=#341-%e7%bc%96%e7%a0%81%e7%9a%84%e9%80%89%e6%8b%a9 aria-label="3.4.1 编码的选择">3.4.1 编码的选择</a></li><li><a href=#342-%e5%88%97%e8%a1%a8%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="3.4.2 列表命令的实现">3.4.2 列表命令的实现</a></li><li><a href=#343-%e9%98%bb%e5%a1%9e%e7%9a%84%e6%9d%a1%e4%bb%b6 aria-label="3.4.3 阻塞的条件">3.4.3 阻塞的条件</a></li><li><a href=#344-%e9%98%bb%e5%a1%9e aria-label="3.4.4 阻塞">3.4.4 阻塞</a></li><li><a href=#345-%e9%98%bb%e5%a1%9e%e5%9b%a0lpushrpushlinsert%e7%ad%89%e6%b7%bb%e5%8a%a0%e5%91%bd%e4%bb%a4%e8%80%8c%e8%a2%ab%e5%8f%96%e6%b6%88 aria-label="3.4.5 阻塞因LPUSH、RPUSH、LINSERT等添加命令而被取消">3.4.5 阻塞因LPUSH、RPUSH、LINSERT等添加命令而被取消</a></li><li><a href=#346-%e5%85%88%e9%98%bb%e5%a1%9e%e5%85%88%e6%9c%8d%e5%8a%a1fbfs%e7%ad%96%e7%95%a5 aria-label="3.4.6 先阻塞先服务（FBFS）策略">3.4.6 先阻塞先服务（FBFS）策略</a></li><li><a href=#347-%e9%98%bb%e5%a1%9e%e5%9b%a0%e8%b6%85%e8%bf%87%e6%9c%80%e5%a4%a7%e7%ad%89%e5%be%85%e6%97%b6%e9%97%b4%e8%80%8c%e8%a2%ab%e5%8f%96%e6%b6%88 aria-label="3.4.7 阻塞因超过最大等待时间而被取消">3.4.7 阻塞因超过最大等待时间而被取消</a></li></ul></li><li><a href=#35-%e9%9b%86%e5%90%88 aria-label="3.5 集合">3.5 集合</a><ul><li><a href=#351-%e7%bc%96%e7%a0%81%e7%9a%84%e9%80%89%e6%8b%a9 aria-label="3.5.1 编码的选择">3.5.1 编码的选择</a></li><li><a href=#352-%e7%bc%96%e7%a0%81%e7%9a%84%e5%88%87%e6%8d%a2 aria-label="3.5.2 编码的切换">3.5.2 编码的切换</a></li><li><a href=#353-%e5%ad%97%e5%85%b8%e7%bc%96%e7%a0%81%e7%9a%84%e9%9b%86%e5%90%88 aria-label="3.5.3 字典编码的集合">3.5.3 字典编码的集合</a></li><li><a href=#354-%e9%9b%86%e5%90%88%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="3.5.4 集合命令的实现">3.5.4 集合命令的实现</a></li><li><a href=#355-%e6%b1%82%e4%ba%a4%e9%9b%86%e7%ae%97%e6%b3%95 aria-label="3.5.5 求交集算法">3.5.5 求交集算法</a></li><li><a href=#356-%e6%b1%82%e5%b9%b6%e9%9b%86%e7%ae%97%e6%b3%95 aria-label="3.5.6 求并集算法">3.5.6 求并集算法</a></li><li><a href=#357-%e6%b1%82%e5%b7%ae%e9%9b%86%e7%ae%97%e6%b3%95 aria-label="3.5.7 求差集算法">3.5.7 求差集算法</a></li></ul></li><li><a href=#36-%e6%9c%89%e5%ba%8f%e9%9b%86 aria-label="3.6 有序集">3.6 有序集</a><ul><li><a href=#361-%e7%bc%96%e7%a0%81%e7%9a%84%e9%80%89%e6%8b%a9 aria-label="3.6.1 编码的选择">3.6.1 编码的选择</a></li><li><a href=#362-%e7%bc%96%e7%a0%81%e7%9a%84%e8%bd%ac%e6%8d%a2 aria-label="3.6.2 编码的转换">3.6.2 编码的转换</a></li><li><a href=#363-ziplist%e7%bc%96%e7%a0%81%e7%9a%84%e6%9c%89%e5%ba%8f%e9%9b%86 aria-label="3.6.3 ZIPLIST编码的有序集">3.6.3 ZIPLIST编码的有序集</a></li><li><a href=#364-skiplist%e7%bc%96%e7%a0%81%e7%9a%84%e6%9c%89%e5%ba%8f%e9%9b%86 aria-label="3.6.4 SKIPLIST编码的有序集">3.6.4 SKIPLIST编码的有序集</a></li></ul></li></ul></li><li><a href=#4%e5%8a%9f%e8%83%bd%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=4、功能的实现>4、功能的实现</a><ul><li><a href=#41-%e4%ba%8b%e5%8a%a1 aria-label="4.1 事务">4.1 事务</a><ul><li><a href=#411-%e4%ba%8b%e5%8a%a1 aria-label="4.1.1 事务">4.1.1 事务</a></li><li><a href=#412-%e5%bc%80%e5%a7%8b%e4%ba%8b%e5%8a%a1 aria-label="4.1.2 开始事务">4.1.2 开始事务</a></li><li><a href=#413-%e5%91%bd%e4%bb%a4%e5%85%a5%e9%98%9f aria-label="4.1.3 命令入队">4.1.3 命令入队</a></li><li><a href=#414-%e6%89%a7%e8%a1%8c%e4%ba%8b%e5%8a%a1 aria-label="4.1.4 执行事务">4.1.4 执行事务</a></li><li><a href=#415-%e5%9c%a8%e4%ba%8b%e5%8a%a1%e5%92%8c%e9%9d%9e%e4%ba%8b%e5%8a%a1%e7%8a%b6%e6%80%81%e4%b8%8b%e6%89%a7%e8%a1%8c%e5%91%bd%e4%bb%a4 aria-label="4.1.5 在事务和非事务状态下执行命令">4.1.5 在事务和非事务状态下执行命令</a></li><li><a href=#416-%e4%ba%8b%e5%8a%a1%e7%8a%b6%e6%80%81%e4%b8%8b%e7%9a%84discardmultiwatch aria-label="4.1.6 事务状态下的DISCARD、MULTI、WATCH">4.1.6 事务状态下的DISCARD、MULTI、WATCH</a></li><li><a href=#417-%e5%b8%a6watch%e7%9a%84%e4%ba%8b%e5%8a%a1 aria-label="4.1.7 带WATCH的事务">4.1.7 带WATCH的事务</a></li><li><a href=#418-watch%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="4.1.8 WATCH命令的实现">4.1.8 WATCH命令的实现</a></li><li><a href=#419-watch%e7%9a%84%e8%a7%a6%e5%8f%91 aria-label="4.1.9 WATCH的触发">4.1.9 WATCH的触发</a></li><li><a href=#4110-%e4%ba%8b%e5%8a%a1%e7%9a%84acid%e6%80%a7%e8%b4%a8 aria-label="4.1.10 事务的ACID性质">4.1.10 事务的ACID性质</a></li><li><a href=#4111-%e5%b0%8f%e7%bb%93 aria-label="4.1.11 小结">4.1.11 小结</a></li></ul></li><li><a href=#42-%e8%ae%a2%e9%98%85%e4%b8%8e%e5%8f%91%e5%b8%83 aria-label="4.2 订阅与发布">4.2 订阅与发布</a><ul><li><a href=#421-%e9%a2%91%e9%81%93%e7%9a%84%e8%ae%a2%e9%98%85%e4%b8%8e%e4%bf%a1%e6%81%af%e5%8f%91%e9%80%81 aria-label="4.2.1 频道的订阅与信息发送">4.2.1 频道的订阅与信息发送</a></li><li><a href=#422-%e8%ae%a2%e9%98%85%e9%a2%91%e9%81%93 aria-label="4.2.2 订阅频道">4.2.2 订阅频道</a></li><li><a href=#423-%e5%8f%91%e9%80%81%e4%bf%a1%e6%81%af%e5%88%b0%e9%a2%91%e9%81%93 aria-label="4.2.3 发送信息到频道">4.2.3 发送信息到频道</a></li><li><a href=#424-%e9%80%80%e8%ae%a2%e9%a2%91%e9%81%93 aria-label="4.2.4 退订频道">4.2.4 退订频道</a></li><li><a href=#425-%e6%a8%a1%e5%bc%8f%e7%9a%84%e8%ae%a2%e9%98%85%e4%b8%8e%e4%bf%a1%e6%81%af%e5%8f%91%e9%80%81 aria-label="4.2.5 模式的订阅与信息发送">4.2.5 模式的订阅与信息发送</a></li><li><a href=#426-%e8%ae%a2%e9%98%85%e6%a8%a1%e5%bc%8f aria-label="4.2.6 订阅模式">4.2.6 订阅模式</a></li><li><a href=#427-%e5%8f%91%e9%80%81%e4%bf%a1%e6%81%af%e5%88%b0%e6%a8%a1%e5%bc%8f aria-label="4.2.7 发送信息到模式">4.2.7 发送信息到模式</a></li><li><a href=#428-%e9%80%80%e8%ae%a2%e6%a8%a1%e5%bc%8f aria-label="4.2.8 退订模式">4.2.8 退订模式</a></li><li><a href=#429-%e5%b0%8f%e7%bb%93 aria-label="4.2.9 小结">4.2.9 小结</a></li></ul></li><li><a href=#43-lua%e8%84%9a%e6%9c%ac aria-label="4.3 Lua脚本">4.3 Lua脚本</a><ul><li><a href=#431-%e5%88%9d%e5%a7%8b%e5%8c%96lua%e7%8e%af%e5%a2%83 aria-label="4.3.1 初始化Lua环境">4.3.1 初始化Lua环境</a></li><li><a href=#432-%e8%84%9a%e6%9c%ac%e7%9a%84%e5%ae%89%e5%85%a8%e6%80%a7 aria-label="4.3.2 脚本的安全性">4.3.2 脚本的安全性</a></li><li><a href=#433-%e8%84%9a%e6%9c%ac%e7%9a%84%e6%89%a7%e8%a1%8c aria-label="4.3.3 脚本的执行">4.3.3 脚本的执行</a></li><li><a href=#434-eval%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="4.3.4 EVAL命令的实现">4.3.4 EVAL命令的实现</a></li><li><a href=#435-evalsha%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="4.3.5 EVALSHA命令的实现">4.3.5 EVALSHA命令的实现</a></li><li><a href=#436-%e5%b0%8f%e7%bb%93 aria-label="4.3.6 小结">4.3.6 小结</a></li></ul></li><li><a href=#44-%e6%85%a2%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97 aria-label="4.4 慢查询日志">4.4 慢查询日志</a><ul><li><a href=#441-%e7%9b%b8%e5%85%b3%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label="4.4.1 相关数据结构">4.4.1 相关数据结构</a></li><li><a href=#442-%e6%85%a2%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97%e7%9a%84%e8%ae%b0%e5%bd%95 aria-label="4.4.2 慢查询日志的记录">4.4.2 慢查询日志的记录</a></li><li><a href=#443-%e6%85%a2%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97%e7%9a%84%e6%93%8d%e4%bd%9c aria-label="4.4.3 慢查询日志的操作">4.4.3 慢查询日志的操作</a></li><li><a href=#444-%e5%b0%8f%e7%bb%93 aria-label="4.4.4 小结">4.4.4 小结</a></li></ul></li></ul></li><li><a href=#5%e5%86%85%e9%83%a8%e8%bf%90%e4%bd%9c%e6%9c%ba%e5%88%b6 aria-label=5、内部运作机制>5、内部运作机制</a><ul><li><a href=#51-%e6%95%b0%e6%8d%ae%e5%ba%93 aria-label="5.1 数据库">5.1 数据库</a><ul><li><a href=#511-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e7%bb%93%e6%9e%84 aria-label="5.1.1 数据库的结构">5.1.1 数据库的结构</a></li><li><a href=#512-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e5%88%87%e6%8d%a2 aria-label="5.1.2 数据库的切换">5.1.2 数据库的切换</a></li><li><a href=#513-%e6%95%b0%e6%8d%ae%e5%ba%93%e9%94%ae%e7%a9%ba%e9%97%b4 aria-label="5.1.3 数据库键空间">5.1.3 数据库键空间</a></li><li><a href=#514-%e9%94%ae%e7%a9%ba%e9%97%b4%e7%9a%84%e6%93%8d%e4%bd%9c aria-label="5.1.4 键空间的操作">5.1.4 键空间的操作</a></li><li><a href=#515-%e9%94%ae%e7%9a%84%e8%bf%87%e6%9c%9f%e6%97%b6%e9%97%b4 aria-label="5.1.5 键的过期时间">5.1.5 键的过期时间</a></li><li><a href=#516-%e8%bf%87%e6%9c%9f%e6%97%b6%e9%97%b4%e7%9a%84%e4%bf%9d%e5%ad%98 aria-label="5.1.6 过期时间的保存">5.1.6 过期时间的保存</a></li><li><a href=#517-%e8%ae%be%e7%bd%ae%e7%94%9f%e5%ad%98%e6%97%b6%e9%97%b4 aria-label="5.1.7 设置生存时间">5.1.7 设置生存时间</a></li><li><a href=#518-%e8%bf%87%e6%9c%9f%e9%94%ae%e7%9a%84%e5%88%a4%e5%ae%9a aria-label="5.1.8 过期键的判定">5.1.8 过期键的判定</a></li><li><a href=#519-%e8%bf%87%e6%9c%9f%e9%94%ae%e7%9a%84%e6%b8%85%e9%99%a4 aria-label="5.1.9 过期键的清除">5.1.9 过期键的清除</a></li><li><a href=#5110-%e8%bf%87%e6%9c%9f%e9%94%ae%e7%9a%84%e6%83%b0%e6%80%a7%e5%88%a0%e9%99%a4%e7%ad%96%e7%95%a5 aria-label="5.1.10 过期键的惰性删除策略">5.1.10 过期键的惰性删除策略</a></li><li><a href=#5111-%e8%bf%87%e6%9c%9f%e9%94%ae%e7%9a%84%e5%ae%9a%e6%9c%9f%e5%88%a0%e9%99%a4%e7%ad%96%e7%95%a5 aria-label="5.1.11 过期键的定期删除策略">5.1.11 过期键的定期删除策略</a></li><li><a href=#5112-%e8%bf%87%e6%9c%9f%e9%94%ae%e5%af%b9aofrdb%e5%92%8c%e5%a4%8d%e5%88%b6%e7%9a%84%e5%bd%b1%e5%93%8d aria-label="5.1.12 过期键对AOF、RDB和复制的影响">5.1.12 过期键对AOF、RDB和复制的影响</a></li><li><a href=#5113-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%a9%ba%e9%97%b4%e7%9a%84%e6%94%b6%e7%bc%a9%e5%92%8c%e6%89%a9%e5%b1%95 aria-label="5.1.13 数据库空间的收缩和扩展">5.1.13 数据库空间的收缩和扩展</a></li><li><a href=#5114-%e5%b0%8f%e7%bb%93 aria-label="5.1.14 小结">5.1.14 小结</a></li></ul></li><li><a href=#52-rdb aria-label="5.2 RDB">5.2 RDB</a><ul><li><a href=#521-%e4%bf%9d%e5%ad%98 aria-label="5.2.1 保存">5.2.1 保存</a></li><li><a href=#522-savebgsaveaof%e5%86%99%e5%85%a5bgrewritefof aria-label="5.2.2 SAVE、BGSAVE、AOF写入、BGREWRITEFOF">5.2.2 SAVE、BGSAVE、AOF写入、BGREWRITEFOF</a></li><li><a href=#523-%e8%bd%bd%e5%85%a5 aria-label="5.2.3 载入">5.2.3 载入</a></li><li><a href=#524-rdb%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84 aria-label="5.2.4 RDB文件结构">5.2.4 RDB文件结构</a></li><li><a href=#525-%e5%b0%8f%e7%bb%93 aria-label="5.2.5 小结">5.2.5 小结</a></li></ul></li><li><a href=#53-aof aria-label="5.3 AOF">5.3 AOF</a><ul><li><a href=#531--aof%e5%91%bd%e4%bb%a4%e5%90%8c%e6%ad%a5 aria-label="5.3.1  AOF命令同步">5.3.1 AOF命令同步</a></li><li><a href=#532-%e5%91%bd%e4%bb%a4%e4%bc%a0%e6%92%ad aria-label="5.3.2 命令传播">5.3.2 命令传播</a></li><li><a href=#533-%e7%bc%93%e5%ad%98%e8%bf%bd%e5%8a%a0 aria-label="5.3.3 缓存追加">5.3.3 缓存追加</a></li><li><a href=#534-%e6%96%87%e4%bb%b6%e5%86%99%e5%85%a5%e5%92%8c%e4%bf%9d%e5%ad%98 aria-label="5.3.4 文件写入和保存">5.3.4 文件写入和保存</a></li><li><a href=#535-aof%e4%bf%9d%e5%ad%98%e6%a8%a1%e5%bc%8f aria-label="5.3.5 AOF保存模式">5.3.5 AOF保存模式</a></li><li><a href=#536-aof%e4%bf%9d%e5%ad%98%e6%a8%a1%e5%bc%8f%e5%af%b9%e6%80%a7%e8%83%bd%e5%92%8c%e5%ae%89%e5%85%a8%e7%9a%84%e5%bd%b1%e5%93%8d aria-label="5.3.6 AOF保存模式对性能和安全的影响">5.3.6 AOF保存模式对性能和安全的影响</a></li><li><a href=#537-aof%e6%96%87%e4%bb%b6%e7%9a%84%e8%af%bb%e5%8f%96%e5%92%8c%e6%95%b0%e6%8d%ae%e8%bf%98%e5%8e%9f aria-label="5.3.7 AOF文件的读取和数据还原">5.3.7 AOF文件的读取和数据还原</a></li><li><a href=#538-aof%e9%87%8d%e5%86%99 aria-label="5.3.8 AOF重写">5.3.8 AOF重写</a></li><li><a href=#539-aof%e9%87%8d%e5%86%99%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="5.3.9 AOF重写的实现">5.3.9 AOF重写的实现</a></li><li><a href=#5310-aof%e5%90%8e%e5%8f%b0%e9%87%8d%e5%86%99 aria-label="5.3.10 AOF后台重写">5.3.10 AOF后台重写</a></li><li><a href=#5311-aof%e5%90%8e%e5%8f%b0%e9%87%8d%e5%86%99%e7%9a%84%e5%87%ba%e5%8f%91%e6%9d%a1%e4%bb%b6 aria-label="5.3.11 AOF后台重写的出发条件">5.3.11 AOF后台重写的出发条件</a></li><li><a href=#5312-%e5%b0%8f%e7%bb%93 aria-label="5.3.12 小结">5.3.12 小结</a></li></ul></li><li><a href=#54-%e4%ba%8b%e4%bb%b6 aria-label="5.4 事件">5.4 事件</a><ul><li><a href=#541-%e6%96%87%e4%bb%b6%e4%ba%8b%e4%bb%b6 aria-label="5.4.1 文件事件">5.4.1 文件事件</a></li><li><a href=#542-%e6%97%b6%e9%97%b4%e4%ba%8b%e4%bb%b6 aria-label="5.4.2 时间事件">5.4.2 时间事件</a></li><li><a href=#543-%e6%97%b6%e9%97%b4%e4%ba%8b%e4%bb%b6%e5%ba%94%e7%94%a8%e5%ae%9e%e4%be%8b%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%b8%b8%e8%a7%84%e6%93%8d%e4%bd%9c aria-label="5.4.3 时间事件应用实例：服务器常规操作">5.4.3 时间事件应用实例：服务器常规操作</a></li><li><a href=#544-%e4%ba%8b%e4%bb%b6%e7%9a%84%e6%89%a7%e8%a1%8c%e4%b8%8e%e8%b0%83%e5%ba%a6 aria-label="5.4.4 事件的执行与调度">5.4.4 事件的执行与调度</a></li><li><a href=#545-%e5%b0%8f%e7%bb%93 aria-label="5.4.5 小结">5.4.5 小结</a></li></ul></li><li><a href=#55-%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%b8%8e%e5%ae%a2%e6%88%b7%e7%ab%af aria-label="5.5 服务器与客户端">5.5 服务器与客户端</a><ul><li><a href=#551-%e5%88%9d%e5%a7%8b%e5%8c%96%e6%9c%8d%e5%8a%a1%e5%99%a8 aria-label="5.5.1 初始化服务器">5.5.1 初始化服务器</a></li><li><a href=#552-%e5%ae%a2%e6%88%b7%e7%ab%af%e8%bf%9e%e6%8e%a5%e5%88%b0%e6%9c%8d%e5%8a%a1%e5%99%a8 aria-label="5.5.2 客户端连接到服务器">5.5.2 客户端连接到服务器</a></li><li><a href=#553-%e5%91%bd%e4%bb%a4%e7%9a%84%e8%af%b7%e6%b1%82%e5%a4%84%e7%90%86%e5%92%8c%e7%bb%93%e6%9e%9c%e8%bf%94%e5%9b%9e aria-label="5.5.3 命令的请求、处理和结果返回">5.5.3 命令的请求、处理和结果返回</a></li><li><a href=#554-%e5%91%bd%e4%bb%a4%e8%af%b7%e6%b1%82%e5%ae%9e%e4%be%8bset%e7%9a%84%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b aria-label="5.5.4 命令请求实例：SET的执行过程">5.5.4 命令请求实例：SET的执行过程</a></li><li><a href=#555-%e5%b0%8f%e7%bb%93 aria-label="5.5.5 小结">5.5.5 小结</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h3 id=1内部数据结构>1、内部数据结构<a hidden class=anchor aria-hidden=true href=#1内部数据结构>#</a></h3><h4 id=11-简单动态字符串>1.1 简单动态字符串<a hidden class=anchor aria-hidden=true href=#11-简单动态字符串>#</a></h4><h5 id=111-sds的用途>1.1.1 sds的用途<a hidden class=anchor aria-hidden=true href=#111-sds的用途>#</a></h5><ul><li><code>sds</code>（<code>Simple Dynamic String</code>）简单动态字符串<ul><li>Redis底层所使用的的字符串表示</li></ul></li><li>用途<ul><li>实现字符串对象</li><li>用作<code>char*</code>类型替代品</li></ul></li></ul><h5 id=112-redis中的字符串>1.1.2 Redis中的字符串<a hidden class=anchor aria-hidden=true href=#112-redis中的字符串>#</a></h5><ul><li><p><code>sds</code>的实现</p><ul><li><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>sds
      
 <span style=color:#66d9ef>struct</span> sdshdr {
   <span style=color:#66d9ef>int</span> len; <span style=color:#75715e>// buf已占用长度
</span><span style=color:#75715e></span>   <span style=color:#66d9ef>int</span> free; <span style=color:#75715e>// bug剩余可用长度
</span><span style=color:#75715e></span>   <span style=color:#66d9ef>char</span> buf[]; <span style=color:#75715e>//实际保存字符串数据的地方
</span><span style=color:#75715e></span> }
</code></pre></div></li></ul></li></ul><h5 id=113-优化追加操作>1.1.3 优化追加操作<a hidden class=anchor aria-hidden=true href=#113-优化追加操作>#</a></h5><ul><li>如果free空间足够，无须再分配空间。如果不够计算新字符串的总长度。</li><li>如果追加字符串小于<code>1M</code>，分配多余所需空间一倍(新字符串长度1倍)的空间。否则，额外多分配<code>1MB</code>。</li></ul><h5 id=114-sds模块的api>1.1.4 sds模块的API<a hidden class=anchor aria-hidden=true href=#114-sds模块的api>#</a></h5><p><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708163819.png alt></p><h5 id=115小结>1.1.5小结<a hidden class=anchor aria-hidden=true href=#115小结>#</a></h5><ul><li>Redis的字符串表示为<code>sds</code>，而不是C字符串（以\0结尾的char*）</li><li>对比C字符串，<code>sds</code>有以下特性<ul><li>可以高效计算长度</li><li>可以高效执行追加操作</li><li>二进制安全</li></ul></li><li><code>sds</code>为追加操作进行优化：加快追加操作速度，并降低内存分配的次数。代价是多占用内存，并且这些内存不会被主动释放</li></ul><h4 id=12-双端链表>1.2 双端链表<a hidden class=anchor aria-hidden=true href=#12-双端链表>#</a></h4><h5 id=121-双端链表的应用>1.2.1 双端链表的应用<a hidden class=anchor aria-hidden=true href=#121-双端链表的应用>#</a></h5><ul><li>实现Redis的列表类型<ul><li>Redis列表使用两种数据结构作为底层实现<ul><li>双端链表</li><li>压缩列表</li><li>创建新的列表键时，优先考虑使用压缩列表，在有需要的时候在转换为双端链表</li></ul></li></ul></li><li>Redis自身功能的构建<ul><li>事务模块保存命令</li><li>服务器模块保存多个客户端</li><li>订阅/发送模块保存订阅模式的多个客户端</li><li>事件模块保存时间事件</li><li>。。。</li></ul></li></ul><h5 id=122-双端链表的实现>1.2.2 双端链表的实现<a hidden class=anchor aria-hidden=true href=#122-双端链表的实现>#</a></h5><p>双端链表的实现由<code>listNode</code>和<code>list</code>两个数据结构构成</p><p><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708160613.png alt></p><ul><li><p>listNode是双端链表的节点</p><ul><li><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> listNode{
  <span style=color:#66d9ef>struct</span> listNode <span style=color:#f92672>*</span>prev; <span style=color:#75715e>// 前驱结点
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>struct</span> listNode <span style=color:#f92672>*</span>next; <span style=color:#75715e>// 后继节点
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>value; <span style=color:#75715e>// 值
</span><span style=color:#75715e></span>} listNode;
</code></pre></div></li><li><p><code>value</code>的属性是<code>void *</code>，说明对保存的值的类型不做限制</p></li><li></li></ul></li><li><p>list是双端链表本身</p><ul><li><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> list{
  listNode <span style=color:#f92672>*</span>head; <span style=color:#75715e>//表头指针
</span><span style=color:#75715e></span>  listNode <span style=color:#f92672>*</span>tail; <span style=color:#75715e>//表尾指针
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> len; <span style=color:#75715e>// 节点数量
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span>dup)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr); <span style=color:#75715e>// 复制函数
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>free)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr); <span style=color:#75715e>// 释放函数
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>match)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>key); <span style=color:#75715e>// 比对函数
</span><span style=color:#75715e></span>} list;
</code></pre></div></li></ul></li><li><p>双端链表API</p><ul><li><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708163837.png alt></li></ul></li></ul><h5 id=123-迭代器>1.2.3 迭代器<a hidden class=anchor aria-hidden=true href=#123-迭代器>#</a></h5><p>Redis为双端链表实现了一个迭代器，可以从两个方向进行迭代</p><ul><li>沿着next指针从表头向表尾</li><li>沿着prev指针从表尾向表头</li></ul><p>结构定义：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> listIter {
  listNode <span style=color:#f92672>*</span>next; <span style=color:#75715e>//下一节点
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> direction; <span style=color:#75715e>// 迭代方向
</span><span style=color:#75715e></span>} listIter;
</code></pre></div><ul><li>direction选项<ul><li><code>adlist.h/AL_START_HEAD</code> 从表头到表尾</li><li><code>adlist.h/AL_START_TAIL</code> 从表尾到表头</li></ul></li><li>迭代器API<ul><li>![image-20210708163935798](/Users/cks/Library/Application Support/typora-user-images/image-20210708163935798.png)</li></ul></li></ul><h5 id=124-小结>1.2.4 小结<a hidden class=anchor aria-hidden=true href=#124-小结>#</a></h5><ul><li>Redis实现了自己的双端链表</li><li>双端链表的主要作用<ul><li>列表类型的底层实现之一</li><li>作为通用数据结构，被其他功能模块使用</li></ul></li><li>双端链表及其节点的性能特性<ul><li>访问前驱结点和后继节点复杂度都是O(1)，并且对链表的迭代可以从表头和表尾两个方式开始</li><li>对表头和表尾处理的复杂度为O(1)</li><li>计算链表长度复杂度O(1)</li></ul></li></ul><h4 id=13-字典>1.3 字典<a hidden class=anchor aria-hidden=true href=#13-字典>#</a></h4><h5 id=131-字典的应用>1.3.1 字典的应用<a hidden class=anchor aria-hidden=true href=#131-字典的应用>#</a></h5><p>字典应用广泛</p><ul><li>实现数据库键空间<ul><li>数据库中键值对由字典保存，每个数据库都有一个与之相对的字典，成为键空间</li></ul></li><li>用作Hash类型键的一种底层实现<ul><li>Redis的Hash类型键使用两种数据结构作为底层实现<ul><li>字典</li><li>压缩列表</li><li>创建新的<code>Hash</code>键时,默认使用压缩列表作为底层实现，有需要再转换字典</li></ul></li></ul></li></ul><h5 id=132-字典的实现>1.3.2 字典的实现<a hidden class=anchor aria-hidden=true href=#132-字典的实现>#</a></h5><p>实现方法有多种：</p><ul><li>最简单，使用链表或数组，但是只适用于元素个数不多的情况</li><li>兼顾高效和简单，使用哈希表</li><li>最求稳定性并且希望高效地实现排序，可以使用平衡树</li></ul><p>Redis选择了高效且简繁的哈希表作为字典的底层实现。</p><ul><li><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> dict {
  dictType <span style=color:#f92672>*</span>type; <span style=color:#75715e>// 特定于类型的处理函数
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>privdata; <span style=color:#75715e>// 类型处理函数的私有数据
</span><span style=color:#75715e></span>  dictht ht[<span style=color:#ae81ff>2</span>]; <span style=color:#75715e>// 哈希表(2个)
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> rehashidx; <span style=color:#75715e>// 记录rehash进度的标志，值为-1表示rehash未进行
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> iterators; <span style=color:#75715e>// 当前正在运作的安全迭代器数量
</span><span style=color:#75715e></span>} dict;
</code></pre></div></li><li><p>dict的API</p><ul><li><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708164006.png alt></li></ul></li></ul><p>哈希表的实现</p><ul><li><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// dict.h/dicht
</span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> dictht {
  dictEntry <span style=color:#f92672>**</span>table; <span style=color:#75715e>// 哈希表节点指针数组（俗称桶，bucket）
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> size; <span style=color:#75715e>// 指针数组的大小
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> sizemask; <span style=color:#75715e>// 指针数组的长度掩码，用于计算索引值
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> used; <span style=color:#75715e>// 哈希表现有的节点数量
</span><span style=color:#75715e></span>} dictht;
</code></pre></div></li><li><p><code>table</code>属性是一个数组，数组每个元素都是一个指向<code>dictEntry</code>结构的指针。</p></li><li><p>每个<code>dictEntry</code>都保存着一个键值对，以及一个指向另一个<code>dictEntry</code>结构的指针：</p></li><li><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> dictEntry {
  <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>key; <span style=color:#75715e>// 键
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>union</span> {
    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>val;
    uint64_t u64;
    int64_t s64;
  } v; <span style=color:#75715e>// 值
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>struct</span> dictEntry <span style=color:#f92672>*</span>next; <span style=color:#75715e>// 链往后继节点
</span><span style=color:#75715e></span>}
</code></pre></div></li></ul><p>整个字典结构：</p><ul><li><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708164900.png alt></li></ul><p>哈希算法</p><ul><li><p>Redis使用两种不同的哈希算法</p><ul><li><code>MurmurHash2 32 bit 算法</code> <a href=https://github.com/aappleby/smhasher>https://github.com/aappleby/smhasher</a></li><li>基于djb算法实现的一个大小写无关散列算法 <a href=http://www.cse.yorku.ca/~oz/hash.html>http://www.cse.yorku.ca/~oz/hash.html</a></li></ul></li><li><p>使用哪种算法取决于具体应用所处理的数据：</p><ul><li>命令表以及Lua脚本缓存使用算法2</li><li>数据库、集群、哈希键、阻塞操作等功能使用算法1</li></ul></li></ul><h5 id=133-创建新字典>1.3.3 创建新字典<a hidden class=anchor aria-hidden=true href=#133-创建新字典>#</a></h5><p><code>dict *d = dictCreate(&hash_type, NULL)</code></p><h5 id=134-添加键值对到字典>1.3.4 添加键值对到字典<a hidden class=anchor aria-hidden=true href=#134-添加键值对到字典>#</a></h5><p>添加流程：</p><ul><li>如果字典未初始化(即字典的0号哈希表的table属性为空)，那么程序需要对0号哈希表进行初始化</li><li>如果在插入时发生了键碰撞，那么程序需要处理碰撞</li><li>如果插入新元素使得字典满足<code>rehash</code>条件，那么需要启动响应的<code>rehash</code>程序</li></ul><h5 id=135-添加新元素到空白字典>1.3.5 添加新元素到空白字典<a hidden class=anchor aria-hidden=true href=#135-添加新元素到空白字典>#</a></h5><p>当第一次往空字典里添加键值对时，程序会根据<code>dict.h/DICT_HT_INITIAL_SIZE</code>里指定的大小为<code>d->ht[0]->table</code>分配空间（目前为值4）。</p><h5 id=136-添加新键值对时发生碰撞处理>1.3.6 添加新键值对时发生碰撞处理<a hidden class=anchor aria-hidden=true href=#136-添加新键值对时发生碰撞处理>#</a></h5><p>使用<code>链地址法</code>，将新的键值对链接到存在的键值对上。</p><h5 id=137-添加新键值对时触发了rehash操作>1.3.7 添加新键值对时触发了rehash操作<a hidden class=anchor aria-hidden=true href=#137-添加新键值对时触发了rehash操作>#</a></h5><ul><li><p>对于使用<code>链地址法</code>来解决碰撞问题的哈希表，性能依赖于它的大小(size属性)和它所保存的节点的数量(used属性)之间的比率：</p><ul><li>比率1:1，哈希表性能最好</li><li>如果节点数量比哈希表大小要大很多，哈希表就会退化成多个链表，性能优势不再存在</li></ul></li><li><p>为了保证性能，字典需要对所使用的的哈希表(ht[0])进行<code>rehash</code>操作：在不修改任何键值对的情况下，对哈希表进行扩容，尽量将比率维持在1:1左右。</p></li><li><p>每次向字典添加新键值对都会进行检查，对于ht[0]的<code>size</code>和<code>used</code>属性，<code>ratio = used/size</code>满足一下任何一个条件，激活<code>rehash</code>:</p><ul><li>自然<code>rehash</code>： <code>ratio >= 1</code>， 且变量<code>dict_can_resize</code>为真<ul><li>在<code>BGSAVE</code>、<code>BGREWRITEAOF</code>时，<code>dict_can_resize</code>会暂时设为假，为了最大化利用系统的<code>copy on write</code>机制，减少程序对内存的碰撞。</li></ul></li><li>强制<code>rehash</code>：<code>ratio</code>大于变量<code>dict_force_resize_ratio</code>(目前默认为5)。</li></ul></li></ul><h5 id=138-rehash执行过程>1.3.8 rehash执行过程<a hidden class=anchor aria-hidden=true href=#138-rehash执行过程>#</a></h5><p>执行步骤：</p><ol><li>创建一个比<code>ht[0]->table</code>更大的<code>ht[1]->table</code><ol><li>为<code>ht[1]->table</code>分配空间至少是<code>ht[0]->used</code>的两倍</li></ol></li><li>将<code>ht[0]->table</code>中的键值对迁移到<code>ht[1]->table</code></li><li>将原有的<code>ht[0]</code>的数据清空，并将<code>ht[1]</code>替换为新的<code>ht[0]</code><ol><li>释放<code>ht[0]</code>的空间</li><li>用<code>ht[1]</code>来代替<code>ht[0]</code></li><li>创建新的哈希表，设置为<code>ht[1]</code></li><li>将字典的<code>rehashidx</code>属性设置为-1，标识<code>rehash</code>已停止</li></ol></li></ol><h5 id=139-渐进式rehash>1.3.9 渐进式rehash<a hidden class=anchor aria-hidden=true href=#139-渐进式rehash>#</a></h5><ul><li><p><code>rehash</code>程序不是在激活只会就马上执行知道完成的，而是分多次、渐进式地完成</p><ul><li>添加键值对触发<code>rehash</code>需要用户等很久不合理</li><li>服务器阻塞不可接受</li></ul></li><li><p>渐进式<code>rehash</code>由<code>_dictRehashStep</code>和 <code>dictRehashMilliseconds</code>两个函数进行</p><ul><li><code>_dictRehashStep</code>用于对数据库字典、以及哈希表的字典进行被动<code>rehash</code></li><li><code>dictRehashMilliseconds</code>由Redis服务器常规任务程序(server cron jon)执行，用于数据库字典进行主动<code>rehash</code></li></ul></li><li><p>_dictRehashStep</p><ul><li>每次执行<code>_dictRehashStep</code>，<code>ht[0]->table</code>哈希表第一个不为空的索引上的所有节点就会全部迁移到<code>ht[1]->table</code></li><li>在<code>rehash</code>开始之后，每次执行一次添加、查找、删除操作，<code>_dictRehashStep</code>都会执行一次</li></ul></li><li><p>dictRehashMilliseconds</p><ul><li><code>dictRehashMilliseconds</code>可以在指定的毫秒数内，对字典进行<code>rehash</code></li></ul></li><li><p>其他措施</p><ul><li><code>rehash</code>时，字典同时存在两个哈希表，所以查找、删除等操作除了在<code>ht[0]</code>上进行，还需要在ht[1]上进行。</li><li>在执行添加操作时，新的节点直接添加到<code>ht[1]</code></li></ul></li></ul><h5 id=1310-字典的收缩>1.3.10 字典的收缩<a hidden class=anchor aria-hidden=true href=#1310-字典的收缩>#</a></h5><ul><li><p>如果哈希表的可用节点比已用节点数大很多，也可以对哈希表进行<code>rehash</code>来收缩字典</p></li><li><p>收缩规则定义：</p><ul><li><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// redis.c/htNeedResize
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>htNeedsResize</span>(dict <span style=color:#f92672>*</span>dict) { 
  <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> size, used;
  size <span style=color:#f92672>=</span> dictSlots(dict); <span style=color:#75715e>// 哈希表已用节点数量 
</span><span style=color:#75715e></span>  used <span style=color:#f92672>=</span> dictSize(dict); <span style=color:#75715e>// 哈希表大小
</span><span style=color:#75715e></span>  <span style=color:#75715e>// 当哈希表的大小大于 DICT_HT_INITIAL_SIZE 并且字典的填充率低于 REDIS_HT_MINFILL 时 返回 1
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> (size <span style=color:#f92672>&amp;&amp;</span> used <span style=color:#f92672>&amp;&amp;</span> size <span style=color:#f92672>&gt;</span> DICT_HT_INITIAL_SIZE <span style=color:#f92672>&amp;&amp;</span> (used<span style=color:#f92672>*</span><span style=color:#ae81ff>100</span><span style=color:#f92672>/</span>size <span style=color:#f92672>&lt;</span> REDIS_HT_MINFILL));
    
}
</code></pre></div></li><li><p>默认情况下，<code>DICT_HT_INITIAL_SIZE</code>的值为10。也就是当字典填充率低于10%时，程序就可以对这个字典进行收缩操作的。</p></li></ul></li><li><p>收缩和扩展的区别</p><ul><li>扩展操作时自动触发的。而收缩操作时由程序手动执行</li></ul></li><li><p>使用字典的程序可以决定何时对字典进行收缩</p><ul><li>字典用于实现哈希键：每次从字典删除一个键值对，会立即执行<code>htNeedsResize</code>函数，判断是否需要收缩</li><li>字典用于实现数据库键空间：由<code>redis.c/tryResizeHashTables</code>函数决定</li></ul></li></ul><h5 id=1311-字典其他操作>1.3.11 字典其他操作<a hidden class=anchor aria-hidden=true href=#1311-字典其他操作>#</a></h5><h5 id=1312-字典的迭代>1.3.12 字典的迭代<a hidden class=anchor aria-hidden=true href=#1312-字典的迭代>#</a></h5><ul><li><p>字典带有自己的迭代器实现（对字典迭代实际上是对字典所使用的的哈希表迭代）</p><ul><li>迭代器首先迭代第一个哈希表，如果正在<code>rehash</code>，就继续对第二个哈希表进行迭代</li><li>当迭代哈希表时，找到第一个不为空的索引，然后迭代这个索引上的所有节点</li><li>当这个索引迭代完了，继续查找下一个不为空的索引，如此循环，一直到整个哈希表都迭代完为止。</li></ul></li><li><p>字典的迭代器有两种</p><ul><li>安全迭代器：在迭代过程中，可以对字典进行修改</li><li>不安全迭代器：在迭代过程中，不对字典进行修改</li></ul></li><li><p>迭代器的数据结构定义：</p><ul><li><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> dictIterator {
  dict <span style=color:#f92672>*</span>d; <span style=color:#75715e>//正在迭代的字典
</span><span style=color:#75715e></span>      
  <span style=color:#66d9ef>int</span> table, <span style=color:#75715e>// 正在迭代的哈希表的号码(0或者1)
</span><span style=color:#75715e></span>        index, <span style=color:#75715e>// 正在迭代的哈希数组的索引
</span><span style=color:#75715e></span>        safe; <span style=color:#75715e>// 是否安全？
</span><span style=color:#75715e></span>  dictEntry <span style=color:#f92672>*</span>entry, <span style=color:#75715e>// 当前哈希节点
</span><span style=color:#75715e></span>                    <span style=color:#f92672>*</span>nextEntry; <span style=color:#75715e>// 当前哈希节点的后继节点
</span><span style=color:#75715e></span>} dictIterator;
</code></pre></div></li></ul></li><li><p>迭代器API</p><ul><li><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210708174305.png alt></li></ul></li></ul><h5 id=1313-小结>1.3.13 小结<a hidden class=anchor aria-hidden=true href=#1313-小结>#</a></h5><ul><li>字典由键值对构成的抽象数据结构</li><li>Redis中的数据库和哈希键都基于字典来实现</li><li>Redis字典的底层实现为哈希表，每个字典使用两个哈希表。一般情况下只是用0号哈希表，只有<code>rehash</code>时，才会同时使用0号和1号哈希表</li><li>哈希表使用<code>链地址法</code>解决键冲突</li><li><code>Rehash</code>可以用于扩展和收缩哈希表</li><li>对哈希表的<code>rehash</code>是分多次、渐进式地进行的</li></ul><h4 id=14-跳跃表>1.4 跳跃表<a hidden class=anchor aria-hidden=true href=#14-跳跃表>#</a></h4><ul><li>一种随机化的数据</li><li>以有序的方式在层次化的链表中保存元素</li><li>效率可以和平衡树媲美，查找、删除、添加都可以在对数期望时间下完成</li></ul><p><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709140155.png alt></p><ul><li>表头(head)：负责维护跳跃表的节点指针</li><li>跳跃表节点：保存元素值，以及多个层</li><li>层：保存着指向其他元素的指针。高层的指针越过的元素数量大于底层的指针，为了提高查找效率，从高层开始访问，随着元素值范围缩小，慢慢降低层次</li><li>表尾：全部由NULL组成，表示跳跃表的末尾</li></ul><h5 id=141-跳跃表的实现>1.4.1 跳跃表的实现<a hidden class=anchor aria-hidden=true href=#141-跳跃表的实现>#</a></h5><p>为了适应功能需要，redis做了修改:</p><ul><li>允许重复的<code>score</code>值：多个不同的<code>member</code>的<code>score</code>值可以相同</li><li>进行对比操作时，不仅要检查<code>score</code>值，还要检查<code>member</code></li><li>每个节点都带有一个高度为1层的后退至真，用于从表尾方向向表头方向迭代</li></ul><p>结构定义：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// redis.h/zskiplist
</span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> zskiplist {
  <span style=color:#66d9ef>struct</span> zskiplistNode <span style=color:#f92672>*</span>header, <span style=color:#f92672>*</span>tail; <span style=color:#75715e>// 头节点，尾节点
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> length; <span style=color:#75715e>// 节点数量
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> level; <span style=color:#75715e>// 目前表内节点的最大层数
</span><span style=color:#75715e></span>} zskiplist;
</code></pre></div><p>跳跃表节点定义：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// redis.h/zskiplistNode
</span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> zskiplistNode {
  robj <span style=color:#f92672>*</span>obj; <span style=color:#75715e>// member对象
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>double</span> score; <span style=color:#75715e>// 分值
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>struct</span> zskiplistNode <span style=color:#f92672>*</span>backward; <span style=color:#75715e>// 后退指针
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>struct</span> zskiplistLevel { <span style=color:#75715e>// 层
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> zskiplistNode <span style=color:#f92672>*</span>forward; <span style=color:#75715e>// 前进指针
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> span; <span style=color:#75715e>// 这个层跨越的节点数量
</span><span style=color:#75715e></span>  } level[];
} zskiplistNode;
</code></pre></div><p>操作这两个数据结构API：</p><p>![image-20210709144926947](/Users/cks/Library/Application Support/typora-user-images/image-20210709144926947.png)</p><h5 id=142-跳跃表的应用>1.4.2 跳跃表的应用<a hidden class=anchor aria-hidden=true href=#142-跳跃表的应用>#</a></h5><ul><li>实现有序集数据类型<ul><li>跳跃表将指向有序集的<code>score</code>值和<code>member</code>域的指针作为元素，并以<code>score</code>值作为索引，对有序集元素进行排序。</li></ul></li></ul><h5 id=143-小结>1.4.3 小结<a hidden class=anchor aria-hidden=true href=#143-小结>#</a></h5><ul><li>跳跃表是一种随机化数据结构，查找、添加、删除都可以在对数期望时间下完成</li><li>跳跃表目前在Redis的唯一作用就是作为有序集类型的底层数据结构之一（另一个构成有序集的结构是字典）</li><li>为了适应功能，redis基于<code>William Pugh</code>论文中描述的跳跃表进行修改：<ul><li><code>score</code>值可重复</li><li>对比元素同时检查<code>score</code>和<code>member</code></li><li>每个节点带有高度为1的后退指针，用于从表尾向表头迭代</li></ul></li></ul><h3 id=2内存映射数据结构>2、内存映射数据结构<a hidden class=anchor aria-hidden=true href=#2内存映射数据结构>#</a></h3><ul><li>虽然<code>内部数据结构</code>非常强大，但是耗费内存。对于元素本身体积不大，代价昂贵。<ul><li>Redis允许使用<code>内存映射数据结构</code>来代替<code>内部数据结构</code></li></ul></li><li><code>内存映射数据</code>是一系列经过特殊编码的字节序列，节省大量内存</li><li>因为<code>内存映射数据结构</code>复杂得多，所以占用CPU时间要多</li></ul><h4 id=21-整数集合>2.1 整数集合<a hidden class=anchor aria-hidden=true href=#21-整数集合>#</a></h4><ul><li>整数集合（<code>ineset</code>）用于有序、无重复地保存多个整数值。会根据元素的值，自动选择(调整)该用什么长度的整数类型保存数据。</li></ul><h5 id=211-整数集合的应用>2.1.1 整数集合的应用<a hidden class=anchor aria-hidden=true href=#211-整数集合的应用>#</a></h5><p><code>Intset</code>是集合键的底层实现之一，如果一个集合满足：</p><ul><li>只保存整数数据</li><li>元素数量不多</li></ul><h5 id=222-数据结构和主要操作>2.2.2 数据结构和主要操作<a hidden class=anchor aria-hidden=true href=#222-数据结构和主要操作>#</a></h5><ul><li>定义</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// intset.h/intset
</span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> intset {
  uint32_t encoding; <span style=color:#75715e>// 保存元素所使用的的类型的长度
</span><span style=color:#75715e></span>  uint32_t length; <span style=color:#75715e>// 元素个数
</span><span style=color:#75715e></span>  int8_t contents[]; <span style=color:#75715e>// 保存元素的数组
</span><span style=color:#75715e></span>} intset;
</code></pre></div><ul><li><code>encoding</code>的值：</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// intset.c
</span><span style=color:#75715e></span><span style=color:#75715e># define INTSET_ENC_INT16 (sizeof(int16_t))
</span><span style=color:#75715e>#define INTSET_ENC_INT32 (sizeof(int32_t)) 
</span><span style=color:#75715e>#define INTSET_ENC_INT64 (sizeof(int64_t))
</span></code></pre></div><ul><li><p><code>content</code>数组是实际保存数据的地方，特性：</p><ul><li>没有重复元素</li><li>元素在数组中从小到大排列</li></ul></li><li><p><code>content</code>数组的<code>int8_t</code>类型声明做为占位符使用。程序根据<code>encoding</code>的值，对<code>content</code>进行类型转换和指针运算。</p></li><li><p>inset主要操作</p><ul><li><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709154323.png alt></li></ul></li></ul><h5 id=213-intset-运行实例>2.1.3 intset 运行实例<a hidden class=anchor aria-hidden=true href=#213-intset-运行实例>#</a></h5><ul><li>创建新<code>inset</code><ul><li><code>intset *is = intsetNew();</code> // <code>intset.c/intsetNew</code></li></ul></li><li>添加新元素到<code>intset</code>。<code>intset.c/intsetAdd</code><ul><li>处理情况<ul><li>元素已存在，不做动作</li><li>元素不存在，并且添加新元素不需要升级</li><li>元素不存在，需要升级后，才能添加元素</li></ul></li><li><code>intsetAdd</code>需要维持<code>intset->contents</code>的以下性质<ul><li>没有重复元素</li><li>从小到大排序</li></ul></li></ul></li></ul><h5 id=214-升级>2.1.4 升级<a hidden class=anchor aria-hidden=true href=#214-升级>#</a></h5><ul><li><p><code>intsetAdd</code>发现新元素不能用现有编码方式保存，就会使用<code>intsetUpgradeAndAdd</code>函数升级</p></li><li><p><code>intsetUpgradeAndAdd</code>任务</p><ol><li>检测新元素需要编码类型</li><li>设置<code>encoding</code>属性为新编码类型，根据新编码类型对整个<code>contents</code>数组进行内存重分配</li><li>调整<code>contents</code>数组原有元素在内存中排列方式，从旧编码调整为新编码</li><li>将新元素添加到集合</li></ol></li></ul><h5 id=215-关于升级>2.1.5 关于升级<a hidden class=anchor aria-hidden=true href=#215-关于升级>#</a></h5><ul><li>从较短整数到较长整数的转换，并不会更改元素里面的值</li><li>集合编码元素的方式，由元素中长度最大的那个值来决定</li></ul><h5 id=216-关于元素移动>2.1.6 关于元素移动<a hidden class=anchor aria-hidden=true href=#216-关于元素移动>#</a></h5><ul><li>元素移动不仅出现在升级(<code>intsetUpgradeAndAdd</code>)操作中，还出现在对<code>contents</code>数组的增删(<code>intsetAdd</code>和<code>intsetRemove</code>)操作上。复杂度都不低于O(n)</li></ul><h5 id=217-其他操作>2.1.7 其他操作<a hidden class=anchor aria-hidden=true href=#217-其他操作>#</a></h5><ul><li>读取<ul><li><code>_intsetGet</code>：接受一个索引<code>pos</code>，根据<code>intset->encoding</code>的值进行指针运算，计算出给定索引的值。</li><li><code>intsetSearch</code> 二分查找，判断元素的索引</li></ul></li><li>写入<ul><li><code>_intsetSet</code>：接受一个索引<code>pos</code>以及一个<code>new_value</code>，将<code>pos</code>位置设置为<code>new_value</code></li></ul></li><li>删除<ul><li><code>intsetRemove</code>：删除单个元素。先<code>intsetSearch</code>获取需要删除元素索引，然后济宁内存移位操作，最后通过内存重新分配，调整数组长度</li></ul></li><li>降级<ul><li><code>Intset</code>不支持降级操作</li></ul></li></ul><h5 id=218-小结>2.1.8 小结<a hidden class=anchor aria-hidden=true href=#218-小结>#</a></h5><ul><li><code>Intset</code>用于有序、无重复地保存多个整数值，它会根据元素的值，自动选择该用什么长度 的整数类型来保存元素。</li><li>当一个位长度更长的整数值添加到 <code>intset</code> 时，需要对 <code>intset</code> 进行升级，新 <code>intset</code> 中每个 元素的位长度都等于新添加值的位长度，但原有元素的值不变。</li><li>升级会引起整个 <code>intset</code> 进行内存重分配，并移动集合中的所有元素，这个操作的复杂度 为 O(N) 。</li><li><code>Intset</code>只支持升级，不支持降级。</li><li><code>Intset</code> 是有序的，程序使用二分查找算法来实现查找操作，复杂度为 O(lg N) 。</li></ul><h4 id=22-压缩列表>2.2 压缩列表<a hidden class=anchor aria-hidden=true href=#22-压缩列表>#</a></h4><ul><li><code>Ziplist</code>是由一系列特殊编码的内存块构成的列表</li><li>一个<code>ziplist</code>可以包含多个节点<code>entry</code></li><li>每个节点可以保存一个长度首先的字符数组或者整数<ul><li>字符数组<ul><li>长度小于等于 63 （2 6− 1）字节的字符数组</li><li>长度小于等于 16383 （2 14− 1）字节的字符数组</li><li>长度小于等于 4294967295 （2 32− 1）字节的字符数组</li></ul></li><li>整数<ul><li>4 位长，介于 0 至 12 之间的无符号整数</li><li>1 字节长，有符号整数</li><li>3 字节长，有符号整数</li><li>int16_t 类型整数</li><li>int32_t 类型整数</li><li>int64_t 类型整数</li></ul></li></ul></li><li>因为<code>ziplist</code>节省内存。被哈希键、列表建、有序集合键作为初始化的底层实现来使用</li></ul><h5 id=221-ziplist的构成>2.2.1 ziplist的构成<a hidden class=anchor aria-hidden=true href=#221-ziplist的构成>#</a></h5><p><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709161202.png alt></p><p><code>ziplist</code>宏：</p><p><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709161324.png alt></p><p>操作<code>ziplist</code>的函数</p><p><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709161400.png alt></p><h5 id=222-节点的构成>2.2.2 节点的构成<a hidden class=anchor aria-hidden=true href=#222-节点的构成>#</a></h5><p><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709161450.png alt></p><ul><li>pre_entry_length<ul><li>记录了前一个节点的长度。通过这个值可以进行指针运算，从而跳转到上一个节点</li></ul></li><li>encoding<ul><li><code>content</code>部分数据类型</li></ul></li><li>length<ul><li><code>content</code>部分数据长度</li></ul></li><li>content<ul><li>保存节点内容</li></ul></li></ul><h5 id=223-创建新-ziplist>2.2.3 创建新 ziplist<a hidden class=anchor aria-hidden=true href=#223-创建新-ziplist>#</a></h5><ul><li><code>ziplistNew</code></li></ul><h5 id=224-将节点添加到末端>2.2.4 将节点添加到末端<a hidden class=anchor aria-hidden=true href=#224-将节点添加到末端>#</a></h5><ol><li>记录到达末端所需的偏移量</li><li>根据需要保存的值，计算所需的空间大小以及编码它前一个节点的长度所需的空间大小，然后进行内存重分配</li><li>设置新节点的各项属性</li><li>更新<code>ziplist</code>的各项属性</li></ol><h5 id=225-将节点添加到某个某些节点的前面>2.2.5 将节点添加到某个/某些节点的前面<a hidden class=anchor aria-hidden=true href=#225-将节点添加到某个某些节点的前面>#</a></h5><ol><li><p>为新节点扩大<code>ziplist</code>的空间</p></li><li><p>设置新节点的各项属性</p></li><li><p>更新新节点到<code>ziplist</code>。更新<code>next</code>节点的<code>pre_entry_length</code></p><ol><li><code>pre_entry_length</code>正好够新元素的长度</li><li><code>pre_entry_length</code>只有1字节长，新元素需要5字节</li><li><code>pre_entry_length</code>有5字节长，新元素需要1字节</li></ol><p>1、3情况，直接更新<code>pre_entry_length</code>。2情况需要对<code>ziplist</code>进行内存重分配，从<code>next</code>开始往后逐个判断是否扩展长度。所以复杂度为O(n^2)</p></li><li><p>更新<code>ziplist</code>各项属性</p></li></ol><h5 id=226-删除节点>2.2.6 删除节点<a hidden class=anchor aria-hidden=true href=#226-删除节点>#</a></h5><ol><li>定位目标节点，计算节点的空间长度</li><li>进行内存移位覆盖原本数据，然后内存重新分配，收缩多余空间</li><li>检查<code>next</code>、<code>next+1</code>等后续节点是否满足新前驱节点的编码。类似添加操作，也会引起连锁更新。</li></ol><h5 id=227-遍历>2.2.7 遍历<a hidden class=anchor aria-hidden=true href=#227-遍历>#</a></h5><ul><li>可以对<code>ziplist</code>进行从前向后的遍历，或者从后向前的遍历。</li></ul><h5 id=228-查找元素根据值定位节点>2.2.8 查找元素，根据值定位节点<a hidden class=anchor aria-hidden=true href=#228-查找元素根据值定位节点>#</a></h5><ul><li>类似遍历原理</li></ul><h5 id=229-小结>2.2.9 小结<a hidden class=anchor aria-hidden=true href=#229-小结>#</a></h5><ul><li><code>ziplist</code> 是由一系列特殊编码的内存块构成的列表，它可以保存字符数组或整数值，它还是 哈希键、列表键和有序集合键的底层实现之一。</li><li><code>ziplist</code> 的结构</li><li><code>ziplist</code> 的节点<code>entry</code>结构</li><li>添加和删除<code>ziplist</code> 节点有可能会引起连锁更新，因此最坏复杂度O(n^2)。不过连锁更新概率不高，所以可以视为O(n)</li></ul><h3 id=3redis数据类型>3、Redis数据类型<a hidden class=anchor aria-hidden=true href=#3redis数据类型>#</a></h3><h4 id=31-对象处理机制>3.1 对象处理机制<a hidden class=anchor aria-hidden=true href=#31-对象处理机制>#</a></h4><ul><li>问题<ul><li>Redis必须让每个键都带有类型信息，使得程序可以检查键的类型，并为它选择合适的处理方式</li><li>需要根据数据类型的不同编码进行多态处理</li></ul></li><li>为了解决上述问题，Redis构建了自己的类型系统，主要功能：<ul><li><code>redisObject</code>对象</li><li>基于<code>redisObject</code>对象的类型检查</li><li>基于<code>redisObject</code>对象的显式多态函数</li><li>对<code>redisObject</code>进行分配、共享和销毁的机制</li></ul></li></ul><h5 id=311-redisobject数据结构以及redis的数据类型>3.1.1 redisObject数据结构，以及Redis的数据类型<a hidden class=anchor aria-hidden=true href=#311-redisobject数据结构以及redis的数据类型>#</a></h5><ul><li>定义</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// redis.h
</span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> redisObject {
  <span style=color:#66d9ef>unsigned</span> type:<span style=color:#ae81ff>4</span>; <span style=color:#75715e>// 类型
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> notused:<span style=color:#ae81ff>2</span>; <span style=color:#75715e>// 对齐位
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> encoding:<span style=color:#ae81ff>4</span>; <span style=color:#75715e>// 编码方式
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> lru:<span style=color:#ae81ff>22</span>; <span style=color:#75715e>// LRU时间(相对于 server.lruclock)
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> refcount; <span style=color:#75715e>// 引用计数
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr; <span style=color:#75715e>// 指向对象的值
</span><span style=color:#75715e></span>} robj;
</code></pre></div><ul><li><code>type</code>记录了对象所保存的值的类型</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define REDIS_STRING 0 </span><span style=color:#75715e>// 字符串
</span><span style=color:#75715e></span><span style=color:#75715e>#define REDIS_LIST 1 </span><span style=color:#75715e>// 列表
</span><span style=color:#75715e></span><span style=color:#75715e>#define REDIS_SET 2 </span><span style=color:#75715e>// 集合
</span><span style=color:#75715e></span><span style=color:#75715e>#define REDIS_ZSET 3 </span><span style=color:#75715e>// 有序集
</span><span style=color:#75715e></span><span style=color:#75715e>#define REDIS_HASH 4 </span><span style=color:#75715e>// 哈希表
</span></code></pre></div><ul><li><code>encoding</code>记录了对象所保存的值的编码</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define REDIS_ENCODING_RAW 0 </span><span style=color:#75715e>// 编码为字符串
</span><span style=color:#75715e></span><span style=color:#75715e>#define REDIS_ENCODING_INT 1 </span><span style=color:#75715e>// 编码为整数
</span><span style=color:#75715e></span><span style=color:#75715e>#define REDIS_ENCODING_HT 2 </span><span style=color:#75715e>// 编码为哈希表
</span><span style=color:#75715e></span><span style=color:#75715e>#define REDIS_ENCODING_ZIPMAP 3 </span><span style=color:#75715e>// 编码为 zipmap
</span><span style=color:#75715e></span><span style=color:#75715e>#define REDIS_ENCODING_LINKEDLIST 4 </span><span style=color:#75715e>// 编码为双端链表
</span><span style=color:#75715e></span><span style=color:#75715e>#define REDIS_ENCODING_ZIPLIST 5 </span><span style=color:#75715e>// 编码为压缩列表
</span><span style=color:#75715e></span><span style=color:#75715e>#define REDIS_ENCODING_INTSET 6 </span><span style=color:#75715e>// 编码为整数集合
</span><span style=color:#75715e></span><span style=color:#75715e>#define REDIS_ENCODING_SKIPLIST 7 </span><span style=color:#75715e>// 编码为跳跃表
</span></code></pre></div><ul><li>ptr是一个指针，指向实际保存值的数据结构，这个数据结构由<code>type</code>属性和<code>encoding</code>属性决定</li></ul><h5 id=312-命令的类型检查和多态>3.1.2 命令的类型检查和多态<a hidden class=anchor aria-hidden=true href=#312-命令的类型检查和多态>#</a></h5><ul><li>当执行一个处理数据类型的命令时：<ol><li>根据给定的<code>key</code>，在数据字典查找<code>redisObject</code>，如果没找到返回NULL</li><li>检查<code>redisObject</code>的<code>type</code>属性和执行命令所需的类型是否相符，如果不相符，返回类型错误</li><li>根据<code>redisObject</code>的<code>encoding</code>属性所指定的编码，选择合适的操作函数来处理底层的数据结构</li><li>返回数据结构的操作结果作为命令的返回值</li></ol></li></ul><h5 id=313-对象共享>3.1.3 对象共享<a hidden class=anchor aria-hidden=true href=#313-对象共享>#</a></h5><ul><li>Flyweight 模式<ul><li>通过预分配一个常见的值对象，并在多个数据结构之间共存这些对象，避免重复分配，也节约CPU时间</li></ul></li><li>Redis预分配的值对象<ul><li>各种命令的返回值。<code>OK</code>、<code>ERROR</code>等</li><li>包括0在不，小于<code>redis.h/REDIS_SHARED_INTEGERS</code>的所有整数。（默认10000）</li></ul></li><li>共享对象只能被带指针的数据结构使用。</li></ul><h5 id=314-引用计数以及对象的销毁>3.1.4 引用计数以及对象的销毁<a hidden class=anchor aria-hidden=true href=#314-引用计数以及对象的销毁>#</a></h5><ul><li>问题<ul><li><code>redisObject</code>用作数据库的键或者值，生命周期非常长，C语言本身没有自动释放内存的相关机制</li><li>对象的引用次数问题</li></ul></li><li>解决方案。使用引用计数技术负责维持和销毁对象<ul><li>每个<code>redisObject</code>都有一个<code>refcount</code>属性，记录被引用次数</li><li>新建对象，<code>refcount</code>值为1</li><li>对一个对象进行共享时， <code>refcount</code>加一</li><li>当用完一个对象之后，或者取消引用之后，程序对对象的<code>refcount</code>减一</li><li>当对象的<code>refcount</code>降至0时，这个<code>redisObject</code>以及它所引用的数据结构的内存，就会被释放</li></ul></li></ul><h5 id=315-小结>3.1.5 小结<a hidden class=anchor aria-hidden=true href=#315-小结>#</a></h5><ul><li>Redis使用自己实现的对象机制来实现类型判断、命令多态和基于引用计数的垃圾回收。</li><li>一种 Redis 类型的键可以有多种底层实现</li><li>Redis 会预分配一些常用的数据对象，并通过共享这些对象来减少内存占用，和避免频繁 地为小对象分配内存。</li></ul><h4 id=32-字符串>3.2 字符串<a hidden class=anchor aria-hidden=true href=#32-字符串>#</a></h4><ul><li><code>REDIS_STRING</code>是Redis使用最广泛的数据类型</li></ul><h5 id=321-字符串编码>3.2.1 字符串编码<a hidden class=anchor aria-hidden=true href=#321-字符串编码>#</a></h5><ul><li>字符串类型分别使用<code>REDIS_ENCODING_INT</code>和<code>REDIS_ENCODING_RAW</code>两种编码<ul><li><code>REDIS_ENCODING_INT</code>使用<code>long</code>类型来保存<code>long</code>类型值</li><li><code>REDIS_ENCODING_RAW</code>使用<code>sdshdr</code>结构来保存<code>sds(char *)</code>、<code>long long</code>、<code>double</code>、<code>long double</code>类型</li></ul></li></ul><h5 id=322-编码的选择>3.2.2 编码的选择<a hidden class=anchor aria-hidden=true href=#322-编码的选择>#</a></h5><ul><li>新创建的字符串默认使用<code>REDIS_ENCODING_RAW</code>编码</li><li>在字符串作为键或者值保存进数据库时，会尝试转为<code>REDIS_ENCODING_INT</code></li></ul><h5 id=323-字符串命令的实现>3.2.3 字符串命令的实现<a hidden class=anchor aria-hidden=true href=#323-字符串命令的实现>#</a></h5><ul><li>通过包装<code>sds</code>数据结构的操作函数来实现</li></ul><h4 id=33-哈希表>3.3 哈希表<a hidden class=anchor aria-hidden=true href=#33-哈希表>#</a></h4><ul><li><code>REDIS_HASH</code>是<code>HSET</code>、<code>HLEN</code>等命令的操作对象，它使用<code>REDIS_ENCODING_ZIPLIST</code> (压缩列表)和 <code>REDIS_ENCODING_HT </code>(字典)两种编码方式</li></ul><h5 id=331-字典编码的哈希表>3.3.1 字典编码的哈希表<a hidden class=anchor aria-hidden=true href=#331-字典编码的哈希表>#</a></h5><ul><li>当使用字典编码时，程序将哈希表的键保存为字典的键，哈希表的值保存为字典的值</li></ul><h5 id=332-压缩列表编码的哈希表>3.3.2 压缩列表编码的哈希表<a hidden class=anchor aria-hidden=true href=#332-压缩列表编码的哈希表>#</a></h5><ul><li>程序将键和值一同推入压缩列表，从而形成保存哈希表所需的键值对结构<ul><li><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210709173251.png alt></li></ul></li><li>新添加的键值对会被添加到压缩列表的表尾</li><li>当进行查找/删除或者更新操作时，程序先定位到键的位置，然后在通过对键的位置来定位值的位置</li></ul><h5 id=333-编码的选择>3.3.3 编码的选择<a hidden class=anchor aria-hidden=true href=#333-编码的选择>#</a></h5><ul><li>创建空白哈希表，默认使用<code>REDIS_ENCODING_ZIPLIST</code>。</li><li>满足以下任何一个条件，编码会切换为<code>REDIS_ENCODING_HT</code>：<ul><li>哈希表中的某个键或者某个值的长度大于<code>server.hash_max_ziplist_value</code>(默认64)</li><li>压缩列表中的节点数量大于<code>server.hash_max_ziplist_entries</code> (默认512)</li></ul></li></ul><h5 id=334-哈希命令的实现>3.3.4 哈希命令的实现<a hidden class=anchor aria-hidden=true href=#334-哈希命令的实现>#</a></h5><ul><li>对字典和压缩列表操作函数的封装，以及在两种编码之间进行转换的函数</li></ul><h4 id=34-列表>3.4 列表<a hidden class=anchor aria-hidden=true href=#34-列表>#</a></h4><ul><li><code>REDIS_LIST</code>是<code>LPUSH</code>、<code>LRANGE</code>等命令的操作对象，它使用<code>REDIS_ENCODING_ZIPLIST</code> 和 <code>REDIS_ENCODING_LINKEDLIST</code>这两种方式编码</li></ul><h5 id=341-编码的选择>3.4.1 编码的选择<a hidden class=anchor aria-hidden=true href=#341-编码的选择>#</a></h5><ul><li>默认使用<code>REDIS_ENCODING_ZIPLIST</code></li><li>满足以下任一条件，会转换为<code>REDIS_ENCODING_LINKEDLIST</code><ul><li>新增字符串长度超过<code>server.list_max_ziplist_value</code> (默认64)</li><li><code>ziplist</code>包含的节点超过 <code>server.list_max_ziplist_entries </code>(默认值512)</li></ul></li></ul><h5 id=342-列表命令的实现>3.4.2 列表命令的实现<a hidden class=anchor aria-hidden=true href=#342-列表命令的实现>#</a></h5><ul><li>两种底层实现的抽象方式和列表的抽象方式非常接近，所以列表命令几乎就是通过一对一 地映射到底层数据结构的操作来实现的</li></ul><h5 id=343-阻塞的条件>3.4.3 阻塞的条件<a hidden class=anchor aria-hidden=true href=#343-阻塞的条件>#</a></h5><ul><li><code>BLPOP</code> 、<code>BRPOP</code> 和 <code>BRPOPLPUSH</code>三个命令都可能造成客户端被阻塞，以下将这些命令统 称为列表的阻塞原语。</li><li>阻塞原语并不是一定会造成客户端阻塞：<ul><li>只有当这些命令并用于空列表时，才会阻塞客户端</li><li>如果被处理的列表不为空，就执行物阻塞版本的<code>LPOP</code> 、<code>RPOP</code>或<code>RPOPLPUSH</code>命令</li></ul></li></ul><h5 id=344-阻塞>3.4.4 阻塞<a hidden class=anchor aria-hidden=true href=#344-阻塞>#</a></h5><ul><li>当一个阻塞原语的处理目标为空键时，执行该阻塞原语的客户端就会被阻塞</li><li>阻塞一个客户端需要执行的步骤<ol><li>将客户端设置为“正在阻塞”，并记录阻塞客户端的各个键以及阻塞的最长时限</li><li>将客户端的信息记录到<code>server.db[1]->blocking_keys</code>中（其中<code>i</code>为客户端所使用的的数据库号码）</li><li>继续维持客户端和服务端之间的网络连接，但不在向客户端传送任何信息，造成客户端阻塞</li></ol></li><li>客户端脱离阻塞状态的方法：<ol><li>被动脱离：其他客户端为造成阻塞的键推入了新元素</li><li>主动脱离：超过最大阻塞时间</li><li>强制脱离：客户端强制终止和服务器的链接，或者服务器停机</li></ol></li></ul><h5 id=345-阻塞因lpushrpushlinsert等添加命令而被取消>3.4.5 阻塞因LPUSH、RPUSH、LINSERT等添加命令而被取消<a hidden class=anchor aria-hidden=true href=#345-阻塞因lpushrpushlinsert等添加命令而被取消>#</a></h5><ul><li>这三个添加新元素到列表命令底层都是由<code>pushGenericCommand</code>函数实现</li><li>当向一个空键推入新元素时，该函数执行两件事：<ol><li>检查键是存在于<code>server.db[i]->blocking_keys</code>字典里，如果有，为这个键创建一个<code>redis.h/readyList</code>结构，并将它添加到<code>server.ready_keys</code>链表中。</li><li>将给定的值添加到列表键中</li></ol></li></ul><p><code>readyList</code>结构定义：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> readyList {
  redisDb <span style=color:#f92672>*</span>db; <span style=color:#75715e>// 指向该键所在的数据库
</span><span style=color:#75715e></span>  robj <span style=color:#f92672>*</span>key; <span style=color:#75715e>// 指向造成阻塞的键
</span><span style=color:#75715e></span>} readyList;
</code></pre></div><p><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210712140713.png alt></p><ul><li>Redis主进程执行完<code>pushGenericCommand</code>函数后，继续调用<code>handleClientsBlockedOnLists</code>：<ol><li>如果<code>server.ready_keys</code>不为空，弹出表头元素，并取出元素中的<code>readyList</code>值</li><li>根据<code>readyList</code>在<code>server.blocking_keys</code>中查找因为<code>key</code>被阻塞的客户端（以链表形式保存）</li><li>如果<code>key</code>不为空，弹出一个元素，并弹出客户端链表的第一个客户端，然后将被弹出的元素返回给被弹出客户端作为阻塞原语的返回值</li><li>根据<code>readyList</code>结构的属性，删除<code>server.blocking_keys</code>中响应的客户端数据，取消客户端的阻塞状态</li><li>继续执行步骤3和4直到<code>key</code>没有元素可弹出，或者没有阻塞的客户端</li><li>继续执行步骤1，直到<code>server.ready_keys</code>链表所有的<code>readyList</code>都被处理完</li></ol></li></ul><h5 id=346-先阻塞先服务fbfs策略>3.4.6 先阻塞先服务（FBFS）策略<a hidden class=anchor aria-hidden=true href=#346-先阻塞先服务fbfs策略>#</a></h5><h5 id=347-阻塞因超过最大等待时间而被取消>3.4.7 阻塞因超过最大等待时间而被取消<a hidden class=anchor aria-hidden=true href=#347-阻塞因超过最大等待时间而被取消>#</a></h5><ul><li>每次Redis常规操作函数（server cron job）执行时，程序都会检查所有连接到服务器的客户端，查看哪些处于“正在阻塞”状态的客户端的最大阻塞时限是否已经过期</li><li>如果已经过期，给客户端返回空白回复，然后撤销对客户端阻塞</li></ul><h4 id=35-集合>3.5 集合<a hidden class=anchor aria-hidden=true href=#35-集合>#</a></h4><ul><li><code>REDIS_SET</code>是<code>SADD</code>、<code>SRANDMEMBER</code>等命令的操作对象，它使用<code>REDIS_ENCODING_INTSET</code>和<code>REDIS_ENCODING_HT</code>两种方式编码</li></ul><h5 id=351-编码的选择>3.5.1 编码的选择<a hidden class=anchor aria-hidden=true href=#351-编码的选择>#</a></h5><ul><li>第一个添加到集合的元素，决定了创建集合所使用的编码<ul><li>第一个元素可以表示成<code>long long</code>类型，集合初始编码为<code>REDIS_ENCODING_INTSET</code></li><li>否则，初始编码为<code>REDIS_ENCODING_HT</code></li></ul></li></ul><h5 id=352-编码的切换>3.5.2 编码的切换<a hidden class=anchor aria-hidden=true href=#352-编码的切换>#</a></h5><ul><li><code>REDIS_ENCODING_INTSET</code>切换到REDIS_ENCODING_HT。以下任一条件：<ul><li><code>intset</code>保存的整数值个数超过<code>server.set_max_intset_entries</code> （默认512）</li><li>试图往集合添加一个新元素，并且这个元素不能被表示为<code>long long</code>类型</li></ul></li></ul><h5 id=353-字典编码的集合>3.5.3 字典编码的集合<a hidden class=anchor aria-hidden=true href=#353-字典编码的集合>#</a></h5><ul><li>当使用<code>REDIS_ENCODING_HT</code>编码时，集合将元素保存在字典的键里面，值统一为NULL</li></ul><h5 id=354-集合命令的实现>3.5.4 集合命令的实现<a hidden class=anchor aria-hidden=true href=#354-集合命令的实现>#</a></h5><ul><li>主要对<code>intset</code>和<code>dict</code>两个数据结构的操作函数的包装，以及一些两种编码之间进行转换的函数</li></ul><h5 id=355-求交集算法>3.5.5 求交集算法<a hidden class=anchor aria-hidden=true href=#355-求交集算法>#</a></h5><ul><li><code>SINTER</code> <code>SINTERSTORE</code></li><li>O(n^2)</li></ul><h5 id=356-求并集算法>3.5.6 求并集算法<a hidden class=anchor aria-hidden=true href=#356-求并集算法>#</a></h5><ul><li><code>SUNION</code> <code>SUNIONSTORE</code></li><li>O(n)</li></ul><h5 id=357-求差集算法>3.5.7 求差集算法<a hidden class=anchor aria-hidden=true href=#357-求差集算法>#</a></h5><ul><li><code>SDIFF</code> <code>SDIFFSTORE</code></li><li>O(n^2)</li></ul><h4 id=36-有序集>3.6 有序集<a hidden class=anchor aria-hidden=true href=#36-有序集>#</a></h4><p><code>REDIS_SET</code>是<code>ZADD</code>、<code>ZCOUNT</code>等命令的操作对象，它使用<code>REDIS_ENCODING_ZIPLIST</code>和<code>REDIS_ENCODING_SKIPLIST</code>两种方式编码：</p><h5 id=361-编码的选择>3.6.1 编码的选择<a hidden class=anchor aria-hidden=true href=#361-编码的选择>#</a></h5><ul><li>通过<code>ZADD</code>添加第一个元素到空<code>key</code>时，决定<ul><li>满足以下条件，使用<code>REDIS_ENCODING_ZIPLIST</code><ul><li>服务器属性<code>server.zset_max_ziplist_entries</code>的值大于0 （默认128）</li><li>元素的<code>member</code>长度小于服务器属性<code>server.zset_max_ziplist_value</code>的值（默认64）</li></ul></li><li>否则，创建<code>REDIS_ENCODING_SKIPLIST</code>编码的有序集</li></ul></li></ul><h5 id=362-编码的转换>3.6.2 编码的转换<a hidden class=anchor aria-hidden=true href=#362-编码的转换>#</a></h5><ul><li><code>REDIS_ENCODING_ZIPLIST</code>转换为<code>REDIS_ENCODING_SKIPLIST</code>，满足以下任一条件：<ul><li><code>ziplist</code>所保存的元素超过<code>server.zset_max_ziplist_entries</code> （默认128）</li><li>新添加元素<code>member</code>的长度大于<code>server.zset_max_ziplist_value</code> （默认64）</li></ul></li></ul><h5 id=363-ziplist编码的有序集>3.6.3 ZIPLIST编码的有序集<a hidden class=anchor aria-hidden=true href=#363-ziplist编码的有序集>#</a></h5><ul><li>每个有序集元素以两个相邻的<code>ziplist</code>节点表示，第一个节点保存元素的<code>member</code>域，第二个元素保存元素的<code>score</code>域</li><li>多个元素之间按<code>score</code>值从小到大排序，如果两个元素的<code>score</code>相同，那么按字典序对<code>member</code>进行对比，决定元素顺序</li></ul><p><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210712145033.png alt></p><ul><li>查找复杂度O(n)</li><li>添加/删除/更新复杂度都不低于O(n)</li></ul><h5 id=364-skiplist编码的有序集>3.6.4 SKIPLIST编码的有序集<a hidden class=anchor aria-hidden=true href=#364-skiplist编码的有序集>#</a></h5><ul><li><p>当使用<code>REDIS_ENCODING_SKIPLIST</code>编码时，有序集元素由<code>redis.h/zset</code>结构来保存：</p><ul><li><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span>  zset {
  dict <span style=color:#f92672>*</span>dict; <span style=color:#75715e>// 字典
</span><span style=color:#75715e></span>  zskiplist <span style=color:#f92672>*</span>zsl; <span style=color:#75715e>// 跳跃表
</span><span style=color:#75715e></span>} zset;
</code></pre></div></li></ul></li><li><p><code>zset</code>同时使用字典和跳跃表两个数据结构来保存有序集元素</p></li><li><p>元素的成员由一个<code>redisObject</code>结构表示，元素的<code>score</code>则是一个<code>double</code>类型的浮点数，字典和跳跃表两个结构通过将指针共同指向这两个值来节约空间</p></li><li><p>字典结构：<code>member</code>作为键，<code>score</code>作为值，有序集可以在O(1)负责度内：</p><ul><li>检查<code>member</code>是否存在</li><li>取出<code>member</code>对应的<code>score</code>值 （<code>ZSCORE</code>）</li></ul></li><li><p>跳跃表：可以让有序集支持一下操作：</p><ul><li>O(logN)期望时间、O(n)最坏时间内根据<code>score</code>对<code>member</code>进行定位</li><li>范围行查找和处理操作 <code>ZRANGE</code> <code>ZRANK</code> <code>ZINTERSTORE</code>等</li></ul></li></ul><h3 id=4功能的实现>4、功能的实现<a hidden class=anchor aria-hidden=true href=#4功能的实现>#</a></h3><h4 id=41-事务>4.1 事务<a hidden class=anchor aria-hidden=true href=#41-事务>#</a></h4><ul><li>Redis通过<code>MULTI</code>、<code>DISCARD</code>、<code>EXEC</code>、<code>WATCH</code>四个命令来实现事务功能</li></ul><h5 id=411-事务>4.1.1 事务<a hidden class=anchor aria-hidden=true href=#411-事务>#</a></h5><ul><li><p>事务提供一种“将多个命令打包，然后一次性、按顺序地执行”的机制，并且事务在执行期间不会主动终端&mdash;服务器在执行完事务中所有的命令后，才会继续处理其他客户端的其他命令</p></li><li><p>事务执行阶段</p><ol><li>开始事务</li><li>命令入队</li><li>执行事务</li></ol></li></ul><h5 id=412-开始事务>4.1.2 开始事务<a hidden class=anchor aria-hidden=true href=#412-开始事务>#</a></h5><ul><li><code>WATCH</code>命令的执行标记着事务的开始</li><li>这个命令唯一做的，将客户端<code>REDIS_MULTI</code>选项打开，让客户端从非事务状态切换到事务状态</li></ul><h5 id=413-命令入队>4.1.3 命令入队<a hidden class=anchor aria-hidden=true href=#413-命令入队>#</a></h5><ul><li>当客户端处于<code>非事务状态</code>时，所有发送给服务端的命令都会立即被执行</li><li>当客户端处于<code>事务状态</code>时，服务器在收到客户端命令时，不会立即执行，而是将这些命令全部让如一个事务队列，然后返回<code>QUEUED</code>，表示命令已入队</li><li>事务队列是一个数组，每个元素包含三个属性<ul><li>要执行的命令（cmd）</li><li>命令的参数（argv）</li><li>参数的个数（argc）</li></ul></li></ul><h5 id=414-执行事务>4.1.4 执行事务<a hidden class=anchor aria-hidden=true href=#414-执行事务>#</a></h5><ul><li>不是所有命令都会被放入事务队列：<code>EXEC</code>、<code>DISCARD</code>、<code>MULTI</code>、<code>WATCH</code>这四个命令会被立即执行</li><li>当<code>EXEC</code>命令执行时<ul><li>服务器根据客户端所保存的事务队列，以先进先出（FIFO）方式执行</li></ul></li></ul><h5 id=415-在事务和非事务状态下执行命令>4.1.5 在事务和非事务状态下执行命令<a hidden class=anchor aria-hidden=true href=#415-在事务和非事务状态下执行命令>#</a></h5><ul><li>无论事务状态还是非事务状态，Redis命令都是由同一个函数执行，所以他们共享服务器一般配置，比如<code>AOF</code>配置、<code>RDB</code>配置以及内存限制等</li><li>事务中的命令和普通命令区别：<ul><li>非事务状态下的命令以单个命令为单位执行，前一个命令和后一个的客户端不一定是同一个；事务状态则是以事务为单位：除非当前事务执行完毕，否则服务器不会中断事务，也不会执行其他客户端的其他命令。</li><li>非事务状态下，执行命令结果立即返回给客户端；事务状态下所有命令的结果集合到回复队列，在做<code>EXEC</code>命令的结果返回客户端。</li></ul></li></ul><h5 id=416-事务状态下的discardmultiwatch>4.1.6 事务状态下的DISCARD、MULTI、WATCH<a hidden class=anchor aria-hidden=true href=#416-事务状态下的discardmultiwatch>#</a></h5><ul><li><code>DISCARD</code>用于取消一个事务，清空客户端的整个事务队列，然后将客户端从事务状态调整回非事务状态，最后返回OK</li><li>Redis的事务不可嵌套。事务状态下发送<code>MULTI</code>，服务器只是简繁返回错误，然后继续等待其他命令入队。不会造成事务失败或修改</li><li><code>WATCH</code>只能在客户端进入事务之前执行，否则会引发错误。但它不会造成事务失败，也不会修改事务队列已有数据。</li></ul><h5 id=417-带watch的事务>4.1.7 带WATCH的事务<a hidden class=anchor aria-hidden=true href=#417-带watch的事务>#</a></h5><ul><li><code>WATCH</code>命令用于在事务开始之前监视任意数量的键：当调用<code>EXEC</code>命令执行事务时，如果任意一个被监视的键已经被其他客户端修改了，那么整个事务不在执行，直接返回失败。</li></ul><h5 id=418-watch命令的实现>4.1.8 WATCH命令的实现<a hidden class=anchor aria-hidden=true href=#418-watch命令的实现>#</a></h5><ul><li>在每个数据库<code>redis.h/redisDb</code>的数据类型中，保存了一个<code>watched_keys</code>字典，字典的键时整个数据库被监视的键，字典的值则是一个链表，链表中保存了所有监视这个键的客户端。</li><li><code>WATCH</code>命令的作用就是：将当前客户端和要监视的键在<code>watched_keys</code>中进行关联</li></ul><h5 id=419-watch的触发>4.1.9 WATCH的触发<a hidden class=anchor aria-hidden=true href=#419-watch的触发>#</a></h5><ul><li>在任何对数据库键空间进行修改的命令成功执行之后，<code>multi.c/touchWatchKey</code>函数都会被调用，它检查数据库的<code>watched_keys</code>字典，看是否有客户端在监视已经被命令修改的键，如果有，程序将所有监视这个键的客户端的<code>REDIS_DIRTY_CAS</code>选项打开</li><li>当客户端发送<code>EXEC</code>命令、出发事务执行时，会对客户端状态进行检查<ul><li>如果<code>REDIS_DIRTY_CAS</code>被打开，直接返回空回复，表示事物执行失败</li><li>如果<code>REDIS_DIRTY_CAS</code>没有打开，说明安全，正式执行事务</li></ul></li><li>最后，当一个客户端结束他的事务时，无论事务成功失败，<code>watched_keys</code>字典中和这个客户端有关的资料都会别清除</li></ul><h5 id=4110-事务的acid性质>4.1.10 事务的ACID性质<a hidden class=anchor aria-hidden=true href=#4110-事务的acid性质>#</a></h5><ul><li>原子性（Atomicity）<ul><li>单个Redis命令的执行事原子性的，但Redis没有在事务上增加任何维持原子性的机制，所以Redis事务不是原子性的</li><li>如果一个事务队列所有命令都被成功执行，那么称这个事务执行成功</li><li>如果Redis服务器进程在执行事务过程中被停止，那么事务执行失败</li><li>事务失败时，Redis也不会进行任何的重试或者回滚操作</li></ul></li><li>一致性（Consistency）<ul><li>Redis的一致性：入队错误、执行错误、Redis进程被终结</li><li>入队错误<ul><li>在命令入队时，如果客户端发送错误的命令，服务端会向客户端返回一个出错信息，并且将客户端的事务状态设置为<code>REDIS_DIRTY_EXEC</code></li><li>当客户端执行<code>EXEC</code>时，Redis拒绝执行状态为<code>REDIS_DIRTY_EXEC</code>的事务，并返回失败信息</li><li>因此，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性</li></ul></li><li>执行错误<ul><li>如果命令在事务执行过程中发生错误，Redis只会将错误包含在事务的结果中，不会引起事务的中断或整个失败</li><li>不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令</li><li>所以它对事务的一致性没有影响</li></ul></li><li>Redis进程被终结<ul><li>根据Redis持久化模式：<ul><li>内存模式：没有任何持久化机制，重启后数据库总是空白，所以数据总是一致</li><li>RDB模式：事务进行中，不会中断Redis执行保存RDB保存工作，所以数据库是一致的</li><li>AOF模式：因为AOF后台进行：<ol><li>事务语句未被写入AOF文件，还原后是一致的</li><li>事务语句被写入AOF文件。重启Redis，程序会检测AOF文件并不完整，Redis会退出，并报告错误。需要使用<code>redis-check-aof</code>工具将部分成功事务命令移除之后，才能再次启动服务器。还原后是一致的</li></ol></li></ul></li></ul></li><li>隔离性（Isolation）<ul><li>Redis是单进程程序，并且保证执行事务时不会对事务进行中断，所以具有隔离性</li></ul></li><li>持久性（Durability）<ul><li>因为事务只是用队列包裹了一组Redis命令，没有提供任何额外的持久性功能，所以事务的持久性由Redis所使用的的持久化模式决定<ul><li>内存模式：不持久</li><li>RDB模式：不持久</li><li>AOF模式：异步保存有时间间隔，也不持久</li></ul></li></ul></li></ul></li></ul><h5 id=4111-小结>4.1.11 小结<a hidden class=anchor aria-hidden=true href=#4111-小结>#</a></h5><ul><li>事务提供一种将多个命令打包，然后一次性、有序地执行的机制</li><li>事务执行过程中不会被中断，所有事务命令执行完之后，事务才能结束</li><li>多个命令会被入队到事务队列中，然后按先进先出（<code>FIFO</code>）的顺序执行。</li><li>带<code>WATCH</code>命令的事务会将客户端和被监视的键在数据库的 <code>watched_keys</code> 字典中进行关 联，当键被修改时，程序会将所有监视被修改键的客户端的 <code>REDIS_DIRTY_CAS</code> 选项打开。</li><li>只有在客户端的 <code>REDIS_DIRTY_CAS</code> 选项未被打开时，才能执行事务，否则事务直接返回 失败。</li><li>Redis 的事务保证了 ACID 中的一致性（C）和隔离性（I），但并不保证原子性（A）和 持久性（D）。</li></ul><h4 id=42-订阅与发布>4.2 订阅与发布<a hidden class=anchor aria-hidden=true href=#42-订阅与发布>#</a></h4><ul><li>Redis通过<code>PUBLISH</code>、<code>SUBSCRIBE</code>等命令实现了订阅与发布模式</li></ul><h5 id=421-频道的订阅与信息发送>4.2.1 频道的订阅与信息发送<a hidden class=anchor aria-hidden=true href=#421-频道的订阅与信息发送>#</a></h5><ul><li><code>SUBSCRIBE</code>命令可以让客户端订阅任意数量的频道</li><li>当有消息通过<code>PUBLISH</code>命令发送给频道时，这个消息就会被发送给订阅他的所有客户端</li></ul><h5 id=422-订阅频道>4.2.2 订阅频道<a hidden class=anchor aria-hidden=true href=#422-订阅频道>#</a></h5><ul><li><p>每个Redis服务器进程都维持这个一个表示服务器状态的<code>redis.h/redisServer</code>结构，结构的<code>pubsub_channels</code>属性是一个字典，用于保存订阅频道的信息</p><ul><li><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> redisSercer {
  dict <span style=color:#f92672>*</span>pubsub_channels;
}
</code></pre></div></li><li><p>字典的键为正在被订阅的频道，值为一个链表，保存了所有订阅这个频道的客户端</p></li><li><p>当客户端调用<code>SUBSCRIBE</code>时，程序就将客户端和要订阅的频道在<code>pubsub_channels</code>字典中关联起来</p></li></ul></li></ul><h5 id=423-发送信息到频道>4.2.3 发送信息到频道<a hidden class=anchor aria-hidden=true href=#423-发送信息到频道>#</a></h5><ol><li>首先根据<code>channel</code>定位到字典的键</li><li>将信息发送给字典链表中的所有客户端</li></ol><h5 id=424-退订频道>4.2.4 退订频道<a hidden class=anchor aria-hidden=true href=#424-退订频道>#</a></h5><ul><li><code>UNSUBSCRIBE</code>，从<code>pubsub_channels</code>字典的给定频道（键）中，删除关于当前客户端的信息</li></ul><h5 id=425-模式的订阅与信息发送>4.2.5 模式的订阅与信息发送<a hidden class=anchor aria-hidden=true href=#425-模式的订阅与信息发送>#</a></h5><h5 id=426-订阅模式>4.2.6 订阅模式<a hidden class=anchor aria-hidden=true href=#426-订阅模式>#</a></h5><ul><li><p><code>redisServer.pubsub_patterns</code>属性是一个链表，保存着所有和模式先关的信息</p><ul><li><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> redisServer {
  list <span style=color:#f92672>*</span>pubsub_patterns;
}
</code></pre></div></li></ul></li><li><p>链表的每个节点都包含一个<code>redis.h/pubsubPattern</code>结构</p><ul><li><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> pubsubPattern {
  redisClient <span style=color:#f92672>*</span>client;  <span style=color:#75715e>// 订阅模式的客户端
</span><span style=color:#75715e></span>  robj <span style=color:#f92672>*</span>pattern;  <span style=color:#75715e>// 被订阅的模式
</span><span style=color:#75715e></span>} pubsubPattern;
</code></pre></div></li></ul></li><li><p>调用<code>PSUBSCRIBE</code>时，程序就创建一个包含客户端和被订阅模式的<code>pubsubPattern</code>结构，并将该结构添加到<code>redisServer.pubsub_patterns</code>链表中</p></li></ul><h5 id=427-发送信息到模式>4.2.7 发送信息到模式<a hidden class=anchor aria-hidden=true href=#427-发送信息到模式>#</a></h5><ul><li><code>PUBLISH</code></li></ul><h5 id=428-退订模式>4.2.8 退订模式<a hidden class=anchor aria-hidden=true href=#428-退订模式>#</a></h5><ul><li><code>PUNSUBSCRIBE</code></li></ul><h5 id=429-小结>4.2.9 小结<a hidden class=anchor aria-hidden=true href=#429-小结>#</a></h5><ul><li>订阅信息由服务器进程维持的<code>redisServer.pubsub_channels</code>字典保存，字典的键为被订阅的频道，字典的值为订阅频道的所有客户端</li><li>当有新消息发送到频道时，程序遍历频道所对应的所有客户端，然后将消息发送到订阅频道的客户端上</li><li>订阅模式的信息由服务器进程维持的<code>redisServer.pubsub_patterns</code>链表来保存，链表的每个节点都保存一个<code>pubsubPattern</code>结构。</li><li>当有新消息发送到频道时，除了订阅频道的客户端回收到消息之外，所有订阅了匹配频道的模式的客户端，也同样会收到消息</li><li>退订频道和退订模式分别的订阅频道和订阅模式的反操作</li></ul><h4 id=43-lua脚本>4.3 Lua脚本<a hidden class=anchor aria-hidden=true href=#43-lua脚本>#</a></h4><h5 id=431-初始化lua环境>4.3.1 初始化Lua环境<a hidden class=anchor aria-hidden=true href=#431-初始化lua环境>#</a></h5><ul><li>在初始化Redis服务器时</li><li>Redis对Lua环境进行了一系列修改，包括添加数据库、更换随机函数、保护全局变量等</li><li>初始化步骤<ol><li>调用<code>lua_open</code>函数，创建一个新的Lua环境</li><li>载入指定的Lua函数库，包括：<ul><li>基础库（<code>base lib</code>）</li><li>表格库（<code>table lib</code>）</li><li>字符串库（<code>string lib</code>）</li><li>数学库（<code>math lib</code>）</li><li>调试库（<code>debug lib</code>）</li><li>用于处理JSON的<code>cjson</code>库</li><li>在Lua值和C结构（<code>struct</code>）之间进行转换的<code>struct</code>库</li><li>处理<code>MessagePack</code>数据的<code>cmsgpack</code>库</li></ul></li><li>屏蔽一些可能对Lua环境产生安全问题的函数，比如<code>loadfile</code></li><li>创建一个Redis字典，保存Lua脚本，并在复制（<code>replication</code>）脚本时使用。字典的键为SHA1校验和，字典的值为Lua脚本</li><li>创建一个redis全局表格到Lua环境，表格中包含了各种对Redis进行操作的函数</li><li>用Redis自己定义的随机生成函数，替换<code>math</code>表原有的<code>math.random</code>函数和<code>math.randommseed</code>函数</li><li>创建一个对Redis多批量回复（<code>multi bulk reply</code>）进行排序的辅助函数</li><li>对Lua环境中的全局变量进行保护，以免被传入的脚本修改</li><li>因为Redis命令必须客户端执行，所以需要在服务器状态中创建一个无网络链接的伪客户端（<code>fake client</code>），专门用于执行Lua脚本中包含的Redis命令。</li><li>将Lua环境的指针记录到Redis服务器的全局状态中，等候Redis的调用。</li></ol></li></ul><h5 id=432-脚本的安全性>4.3.2 脚本的安全性<a hidden class=anchor aria-hidden=true href=#432-脚本的安全性>#</a></h5><ul><li>问题<ul><li>如果一段Lua脚本带有随机性质或作用，那么当这段脚本在附属节点运行时，或者从AOF文件载入重新运行时，带到的结果可能和之前运行的结果完全不同</li></ul></li><li>解决<ul><li>Redis对Lua环境所能执行的脚本做了一个严格的限制：所有的脚本都必须是无副作用的纯函数（<code>pure function</code>）</li></ul></li><li>策略<ul><li>不提供访问系统状态的库（比如系统时间库）</li><li>进制使用<code>loadfile</code>函数</li><li>阻止带有随机性质命令的脚本执行</li><li>如果脚本执行带有随机命令的读，会先被执行一个自动的字典序排序，保证输出结果有序</li><li>用Redis自己定义的随机生成函数，替换Lua环境中<code>math</code>表原有的随机函数。新函数性质：每次执行Lua脚本，除非显式地调用<code>math.randomseed</code>，否则<code>math.random</code> 生成的伪随机数序列总是相同的。</li></ul></li><li>保证：<ul><li>无副作用</li><li>没有有害的随机性</li><li>对于同样的输入参数和数据集，总是产生相同的写入命令</li></ul></li></ul><h5 id=433-脚本的执行>4.3.3 脚本的执行<a hidden class=anchor aria-hidden=true href=#433-脚本的执行>#</a></h5><ul><li><code>EVAL</code>、<code>EVALSHA</code> 执行Lua脚本</li><li><code>EVALSHA</code>基于<code>EVAL</code></li></ul><h5 id=434-eval命令的实现>4.3.4 EVAL命令的实现<a hidden class=anchor aria-hidden=true href=#434-eval命令的实现>#</a></h5><ul><li><p><code>EVAL</code>的执行分为以下步骤：</p><ul><li>为输入脚本定义一个Lua函数</li><li>执行这个Lua函数</li></ul></li><li><p>定义Lua函数</p><ul><li><p>函数名以<code>f_</code>为前缀，后跟脚本的<code>SHA1</code>校验和</p><ul><li><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// EVAL &#34;return &#39;hello world&#39;&#34; 0
</span><span style=color:#75715e></span>      
function f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91() 
  <span style=color:#66d9ef>return</span> <span style=color:#960050;background-color:#1e0010>&#39;</span>hello world<span style=color:#960050;background-color:#1e0010>&#39;</span> end
</code></pre></div></li></ul></li><li><p>好处：</p><ul><li>执行步骤简单，只要调用和脚本相对应的函数</li><li>Lua环境保持清洁，已有的脚本和新加入的脚本不会互相干扰，可以将重置Lua环境和调用Lua GC的次数降到最低</li><li>如果某个脚本对应的函数的Lua被定义过，只需要记得这个脚本的<code>SHA1</code>校验和</li></ul></li></ul></li><li><p>执行Lua函数</p><ol><li>将<code>EVAL</code>命令输入的<code>KEYS</code>参数和<code>ARGV</code>参数以全局数组的方式传入到Lua环境中</li><li>设置伪客户端的目标数据为调用者客户端的目标数据库</li><li>为Lua环境装载超时钩子，保证脚本执行超时可以杀死脚本，或者停止Redis服务器</li><li>执行脚本对应的Lua函数</li><li>如果脚本有<code>SELECT</code>命令，那么需要对调用者客户端的目标数据库进行更新</li><li>执行清理操作：清除钩子；清除指向调用者客户端的指针等</li><li>将Lua函数指定所得结果转换成Redis回复，传给客户端</li><li>对Lua环境进行一次单步的渐进式GC</li></ol></li></ul><h5 id=435-evalsha命令的实现>4.3.5 EVALSHA命令的实现<a hidden class=anchor aria-hidden=true href=#435-evalsha命令的实现>#</a></h5><ul><li>只要脚本对应的函数在Lua里定义过，即使用户不知道脚本的内容本身，也可以直接通过脚本的<code>SHA1</code>校验和来掉调用</li></ul><h5 id=436-小结>4.3.6 小结<a hidden class=anchor aria-hidden=true href=#436-小结>#</a></h5><ul><li>初始化Lua脚本环境需要一系列步骤</li><li>Redis通过一系列措施保证Lua脚本无副作用，也没有有害的写随机性</li><li><code>EVAL</code>命令为输入脚本定义一个Lua函数，然后通过函数执行脚本</li><li><code>EVALSHA</code>通过构建函数名，直接调用Lua中定义的函数，从而执行脚本</li></ul><h4 id=44-慢查询日志>4.4 慢查询日志<a hidden class=anchor aria-hidden=true href=#44-慢查询日志>#</a></h4><ul><li>慢查询日志是Redis提供的一个用于观察系统性能的功能</li></ul><h5 id=441-相关数据结构>4.4.1 相关数据结构<a hidden class=anchor aria-hidden=true href=#441-相关数据结构>#</a></h5><ul><li>慢日志结构定义：</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// slowlog.h/slowlogEntry
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> slowlogEntry {
  robj <span style=color:#f92672>**</span>argv; <span style=color:#75715e>// 命令参数
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> argc; <span style=color:#75715e>// 命令参数数量
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> id; <span style=color:#75715e>// 唯一标识符
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> duration; <span style=color:#75715e>// 执行消耗的时间，以纳秒为单位
</span><span style=color:#75715e></span>  time_t time; <span style=color:#75715e>// 命令执行时间
</span><span style=color:#75715e></span>} slowlogEntry;
</code></pre></div><ul><li><p>记录服务器状态的<code>redis.h/redisServer</code>结构</p><ul><li><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> redisServer {
  list <span style=color:#f92672>*</span>slowlog; <span style=color:#75715e>// 保存慢查询日志的链表
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> slowlog_entry_id; <span style=color:#75715e>// 慢查询日志当前id值
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> slowlog_log_slower_than; <span style=color:#75715e>// 慢查询时间限制
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> slowlog_max_len; <span style=color:#75715e>// 慢查询日志最大条目数量
</span><span style=color:#75715e></span>}
</code></pre></div></li><li><p><code>slowlog</code>从新到旧排序链表</p></li><li><p><code>slowlog_entry_id</code>在创建慢日志后加一，用于产生慢查询日志ID（<code>SLOW LOG</code>之后被重置）</p></li><li><p><code>slowlog_log_slower_than</code>：命令执行时间上限</p></li><li><p><code>slowlog_max_len</code>：日志数量等于这个值，添加新日志，最旧的日志会被删除</p></li></ul></li></ul><h5 id=442-慢查询日志的记录>4.4.2 慢查询日志的记录<a hidden class=anchor aria-hidden=true href=#442-慢查询日志的记录>#</a></h5><ul><li>Redis记录命令执行前的时间，执行完成后计算耗费时间<code>duration</code>，并传给<code>slowlogPushEntryIfNeed</code>函数</li><li>如果<code>duration</code>超过<code>server.slowlog_log_slower_than</code>，<code>slowlogPushEntryIfNeed</code>就会创建一条心的慢查询日志，加入慢查询日志链表</li></ul><h5 id=443-慢查询日志的操作>4.4.3 慢查询日志的操作<a hidden class=anchor aria-hidden=true href=#443-慢查询日志的操作>#</a></h5><ul><li>查看日志 O(n)</li><li>清空日志 O(n)</li><li>获取日志数量 O(1)</li></ul><h5 id=444-小结>4.4.4 小结<a hidden class=anchor aria-hidden=true href=#444-小结>#</a></h5><ul><li>Redis用一个链表以<code>FIFO</code>的顺序保存所有的慢查询日志</li><li>每条慢查询日志记录执行超时的命令、命令的参数、命令执行时间、命令所消耗的时间等信息</li></ul><h3 id=5内部运作机制>5、内部运作机制<a hidden class=anchor aria-hidden=true href=#5内部运作机制>#</a></h3><h4 id=51-数据库>5.1 数据库<a hidden class=anchor aria-hidden=true href=#51-数据库>#</a></h4><h5 id=511-数据库的结构>5.1.1 数据库的结构<a hidden class=anchor aria-hidden=true href=#511-数据库的结构>#</a></h5><ul><li><p>Redis中的每个数据库，都是由一个<code>redis.h/redisDb</code>结构表示：</p><ul><li><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> redisDb {
  <span style=color:#66d9ef>int</span> id; <span style=color:#75715e>// 保存着数据库以整数表示的号码
</span><span style=color:#75715e></span>  dict <span style=color:#f92672>*</span>dict; <span style=color:#75715e>// 保存着数据库中的所有键值对数据。也被称为键空间
</span><span style=color:#75715e></span>  dict <span style=color:#f92672>*</span>expires; <span style=color:#75715e>// 保存着键的过期信息
</span><span style=color:#75715e></span>  dict <span style=color:#f92672>*</span>blocking_keys; <span style=color:#75715e>// 实现列表阻塞原语
</span><span style=color:#75715e></span>  dict <span style=color:#f92672>*</span>ready_keys;
      
  dict <span style=color:#f92672>*</span>watched_keys; <span style=color:#75715e>// 用于MATCH命令。事务
</span><span style=color:#75715e></span>} redisDb;
</code></pre></div></li></ul></li></ul><h5 id=512-数据库的切换>5.1.2 数据库的切换<a hidden class=anchor aria-hidden=true href=#512-数据库的切换>#</a></h5><ul><li><code>redisDb</code>结构的<code>id</code>保存着数据库的号码</li><li>Redis初始化时，会创建<code>redis.h/REDIS_DEFAULT_DBNUM</code>个数据库，并将所有数据库保存到<code>redis.h/redisServer.db</code>数组中，每个数据库<code>id</code>从0到<code>REDIS_DEFAULT_DBNUM - 1</code></li><li>当执行<code>SELECT number</code>时，程序使用<code>redisServer.db[number]</code>来切换数据库</li></ul><h5 id=513-数据库键空间>5.1.3 数据库键空间<a hidden class=anchor aria-hidden=true href=#513-数据库键空间>#</a></h5><ul><li>Redis是键值对数据库，所以它的数据库本身也是一个字典(<code>key space</code>)<ul><li>字典的键是一个字符串对象</li><li>字典的值则可以使包括字符串、列表、哈希表、集合、有序集在内的任意一种Redsi类型对象</li></ul></li><li><code>redisDb</code>结构的<code>dict</code>属性，保存着数据库所有的键值对数据</li></ul><h5 id=514-键空间的操作>5.1.4 键空间的操作<a hidden class=anchor aria-hidden=true href=#514-键空间的操作>#</a></h5><ul><li><p>因为数据库本身是一个字典，所以对数据库的操作基本上都是对字典的操作，加上一些维护操作</p></li><li><p>添加新键</p></li><li><p>删除键</p></li><li><p>更新键</p></li><li><p>取值</p></li><li><p>其他操作</p><ul><li><code>FLUSHDB</code></li><li><code>RANDOMKEY</code></li><li><code>DBSIZE</code></li><li><code>EXISTS</code></li><li><code>RENAME</code></li></ul></li></ul><h5 id=515-键的过期时间>5.1.5 键的过期时间<a hidden class=anchor aria-hidden=true href=#515-键的过期时间>#</a></h5><ul><li><code>EXPIRE</code>、<code>PEXPIRE</code>、<code>EXPIREAT</code>、<code>PEXPIREAT</code></li></ul><h5 id=516-过期时间的保存>5.1.6 过期时间的保存<a hidden class=anchor aria-hidden=true href=#516-过期时间的保存>#</a></h5><ul><li><code>redisDb</code>结构的<code>expires</code>字典里<ul><li><code>expires</code>字典的键是一个执行<code>dict</code>字典里某个键的指针，字典的值是过期时间<code>long long</code>类型</li></ul></li></ul><h5 id=517-设置生存时间>5.1.7 设置生存时间<a hidden class=anchor aria-hidden=true href=#517-设置生存时间>#</a></h5><ul><li>Redis有四个命令设置键的生存时间和过期时间</li><li>但是，<code>expires</code>字典的值只保存“以毫秒为单位的过期UNIX时间戳”</li></ul><h5 id=518-过期键的判定>5.1.8 过期键的判定<a hidden class=anchor aria-hidden=true href=#518-过期键的判定>#</a></h5><ul><li>通过<code>expires</code>字典，通过以下步骤检查<ol><li>检查键是否在<code>expires</code>字典；如果存在，那么取出键的过期时间</li><li>通过与当前UNIX时间戳对比没判断是否过期</li></ol></li></ul><h5 id=519-过期键的清除>5.1.9 过期键的清除<a hidden class=anchor aria-hidden=true href=#519-过期键的清除>#</a></h5><ul><li>三种删除方式<ul><li>定时删除：在设置键的过期时间时，创建一个定时事件，当过期时间到达时，由事件处理器自动执行键的删除操作</li><li>惰性删除：放任键过期不管，但是在每次从<code>dict</code>字典取出键时，检查是否过期，过期则删除并返回空</li><li>定期删除：每隔一段时间，对<code>expires</code>字典进行检查，删除过期键</li></ul></li><li>定时删除<ul><li>对内存最友好：因为能保证过期键第一时间被删除</li><li>缺点：<ul><li>对CPU时间最不友好：因为删除操作可能会占用大量的CPU时间</li><li>目前Redis事件处理器对时间事件的实现方式&ndash;无序链表，查找复杂度O(n)，不适合用来处理大量时间事件</li></ul></li></ul></li><li>惰性删除<ul><li>对CPU最友好：只会在取出键时进行检查</li><li>缺点<ul><li>对内存最不友好：内存已知占用不被释放</li></ul></li></ul></li><li>定期删除<ul><li>上述两种的折中策略</li><li>每隔一段时间执行一次删除操作，并通过限制删除操作执行的时长和频率，来减少删除操作对CPU时间的影响</li><li>通过定期删除过期键，有效的减少内存浪费</li></ul></li><li>Redis使用的策略<ul><li>惰性删除 + 定期删除</li></ul></li></ul><h5 id=5110-过期键的惰性删除策略>5.1.10 过期键的惰性删除策略<a hidden class=anchor aria-hidden=true href=#5110-过期键的惰性删除策略>#</a></h5><ul><li><code>db.c/expireIfNeeded</code>函数。</li><li>所有命令在读取或写入数据库之前都会调用<code>expireIfNeeded</code>函数对键进行检查</li><li><code>expireIfNeeded</code>的作用是，如果输入键过期的话，将键、值、键保存在<code>expires</code>字典中的过期时间都删除掉</li></ul><h5 id=5111-过期键的定期删除策略>5.1.11 过期键的定期删除策略<a hidden class=anchor aria-hidden=true href=#5111-过期键的定期删除策略>#</a></h5><ul><li><code>redis.c/activeExpireCycle</code>函数。</li><li>每当Redis的例行处理程序<code>serverCron</code>执行时，<code>activeExpireCycle</code>都会被调用</li><li>这个函数在规定时间限制内，尽可能地遍历各个数据库的<code>expires</code>字典，随机的检查一部分键的过期时间，并删除其中的过期键</li></ul><h5 id=5112-过期键对aofrdb和复制的影响>5.1.12 过期键对AOF、RDB和复制的影响<a hidden class=anchor aria-hidden=true href=#5112-过期键对aofrdb和复制的影响>#</a></h5><ul><li>更新后的RDB文件<ul><li>在创建RDB文件时，程序会对键进行检查，过期的键不会被写入到更新后的RDB文件中</li></ul></li><li>AOF文件<ul><li>过期键在被惰性删除或定期删除之前，不会有任何影响，AOF不会被修改</li><li>过期键被删除后，程序会向AOF文件追加一条DEL命令</li></ul></li><li>AOF重写<ul><li>重写时，程序会检查键，过期的键不会被保存到重写后的AOF文件</li></ul></li><li>复制<ul><li>过期键的删除由主节点统一控制<ul><li>如果是主节点，它删除一个过期键后，会显式地向所有附属节点发送一个<code>DEL</code>命令</li><li>如果是附属节点，碰到过期键，会返回已过期的回复，但是不会删除。</li></ul></li></ul></li></ul><h5 id=5113-数据库空间的收缩和扩展>5.1.13 数据库空间的收缩和扩展<a hidden class=anchor aria-hidden=true href=#5113-数据库空间的收缩和扩展>#</a></h5><ul><li>字典的 扩展/收缩规则</li><li><code>redis.c/tryResizeHashTables</code>函数检查数据库是否需要收缩</li><li>每次<code>redis.c/serverCron</code>函数运行时，被调用</li></ul><h5 id=5114-小结>5.1.14 小结<a hidden class=anchor aria-hidden=true href=#5114-小结>#</a></h5><ul><li>数据库主要由<code>dict</code>和<code>expires</code>两个字典构成，<code>dict</code>保存键值对，<code>expires</code>保存键的过期时间</li><li>数据库的键总是一个字符串对象，值可以使任意一种Redis数据类型，包括字符串、哈希表、集合、列表、有序集</li><li><code>expires</code>的某个键和<code>dict</code>的某个键共同指向同一个字符串对象，而<code>expires</code>键的值则是该键以毫秒计算的UNIX过期时间戳</li><li>Redis使用惰性删除和定期删除两种策略来删除过期的键</li><li>更新后的RDB文件和重写后的AOF文件不会保留过期的键</li><li>当一个过期的键被删除之后，程序会追加一条新的<code>DEL</code>命令到AOF文件</li><li>当主节点删除一个过期键后，会显式的发送一条<code>DEL</code>命令到所有附属节点</li><li>附属节点发现过期键后，不会删除，而是等待主节点发来<code>DEL</code>命令，保证数据一致</li><li>数据库的<code>dict</code>和<code>expires</code>字典的扩展策略和普通字典一样。当填充百分比不足10%时，将可用节点数量减少至大于等于当前已用节点数量。</li></ul><h4 id=52-rdb>5.2 RDB<a hidden class=anchor aria-hidden=true href=#52-rdb>#</a></h4><ul><li>RDB核心是<code>rdbSave</code>和<code>rdbLoad</code>函数，前者用于生成RDB文件到磁盘，后者用于将RDB文件中的数据重新载入到内存</li></ul><h5 id=521-保存>5.2.1 保存<a hidden class=anchor aria-hidden=true href=#521-保存>#</a></h5><ul><li>如果RDB文件已存在，新的RDB文件会替换已有的</li><li>RDB保存文件期间，主进程会被阻塞，知道保存完成为止</li><li><code>SAVE</code>直接调用<code>rdbSave</code>，阻塞Redis主进程，知道保存完成为止</li><li><code>BGSAVE</code>则<code>fork</code>出一个子进程，子进程负责调用<code>rdbSave</code>，并在保存完成后向主进程发送信号，通知保存已完成。</li></ul><h5 id=522-savebgsaveaof写入bgrewritefof>5.2.2 SAVE、BGSAVE、AOF写入、BGREWRITEFOF<a hidden class=anchor aria-hidden=true href=#522-savebgsaveaof写入bgrewritefof>#</a></h5><ul><li><p>SAVE</p><ul><li><code>SAVE</code>执行时，新的<code>SAVE</code>、<code>BGSAVE</code>、<code>BGREWRITEAOF</code>调用不会产生任何多用</li><li>AOF写入是后台线程完成，<code>BGREWRITEAOF</code>由子进程完成，所以<code>SAVE</code>执行过程中，AOF写入、<code>BGREWRITEAOF</code>可以同时进行</li></ul></li><li><p>BGSAVE</p><ul><li>在指向<code>SAVE</code>之前，服务器会检查<code>BGSAVE</code>是否正在执行，如果是，不调用<code>rdbSave</code>，向客户端返回出错信息</li><li>当<code>BGSAVE</code>执行时，调用新的<code>BGSAVE</code>的客户端也会收到出错信息</li><li><code>BGSAVE</code>执行时，<code>BGREWRITEAOF</code>的重写请求会被延迟到<code>BGSAVE</code>执行完毕</li><li><code>BGREWRITEAOF</code>执行时，调用<code>BGSAVE</code>的客户端将收到出错信息</li><li><code>BGREWRITEAOF</code>和<code>BGSAVE</code>不同时执行时处于性能考虑<ul><li>并发两个子进程，并且两个子进程都同时进行大量的磁盘写入，性能问题</li></ul></li></ul></li></ul><h5 id=523-载入>5.2.3 载入<a hidden class=anchor aria-hidden=true href=#523-载入>#</a></h5><ul><li>Redis服务器启动时，<code>rdbLoad</code>函数就会被执行，它读取RDB文件，将文件中的数据库数据载入到内存中</li><li>在载入期间， 服务器每载入 1000 个键就处理一次所有已到达的请求， 不过只有 <code>PUBLISH</code> 、 <code>SUBSCRIBE</code> 、<code>PSUBSCRIBE</code> 、<code>UNSUBSCRIBE </code>、<code>PUNSUBSCRIBE</code> 五个命令的请求会被正确地处理， 其他命令一律返回错误。等到载入完成之后，服务器才会开始正常处理所有命令。<ul><li>发布与订阅功能和其他数据库功能是完全隔离的，前者不写入也不读取数据库，所以 在服务器载入期间，订阅与发布功能仍然可以正常使用，而不必担心对载入数据的完整性产生 影响。</li></ul></li><li>AOF保存频率通常高于RDB。如果AOF功能打开会优先使用AOF文件还原数据</li></ul><h5 id=524-rdb文件结构>5.2.4 RDB文件结构<a hidden class=anchor aria-hidden=true href=#524-rdb文件结构>#</a></h5><p><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210713154641.png alt></p><ul><li>REDIS<ul><li>文件开头保存REDIS五个字符，表示RDB文件的开始</li></ul></li><li>RDB-VERSION<ul><li>四字节长</li><li>记录RDB版本号（目前为0006）</li><li>因为不同版本的RDB文件不兼容，所以需要根据版本来选择不同的读入方式</li></ul></li><li>DB-DATA<ul><li>重复多次出现</li><li>每一个<code>DB-DATA</code>部分保存着服务器上一个非空数据库的所有数据数据</li></ul></li><li>SELECT-DB<ul><li>保存着跟在后面的键值对所属的数据库号码</li></ul></li><li>KEY-VALUE-PAIRS<ul><li>因为空数据库不会被保存到RDB文件，所以这部分至少包含一个键值对的数据</li><li>键值对数据结构<ul><li><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210713155253.png alt></li><li><code>OPTIONAL-EXPIRE-TIME</code>：记录着过期时间。可选，没有过期时间，该域不出现</li><li><code>KEY</code>：键。格式和<code>REDIS_ENCODING_RAW</code>编码的字符串对象一样。</li><li><code>TYPE-OF-VALUE</code>：记录<code>VALUE</code>域的值所使用的的编码</li><li><code>VALUE</code>：不同类型格式不同</li></ul></li></ul></li><li>EOF<ul><li>标志着数据库内容的结尾，值为<code>rdb.h/EDIS_RDB_OPCODE_EOF</code></li></ul></li><li>CHECK-SUM<ul><li>校验和。<code>uint_64t</code>类型值</li><li>如果为0，表示Redis关闭了校验和功能</li></ul></li></ul><h5 id=525-小结>5.2.5 小结<a hidden class=anchor aria-hidden=true href=#525-小结>#</a></h5><ul><li><code>rdbSave</code> 会将数据库数据保存到 RDB 文件，并在保存完成之前阻塞调用者。</li><li><code>SAVE</code> 命令直接调用 <code>rdbSave</code> ，阻塞 Redis 主进程；<code>BGSAVE</code> 用子进程调用 <code>rdbSave </code>， 主进程仍可继续处理命令请求。</li><li><code>SAVE</code> 执行期间，AOF 写入可以在后台线程进行，<code>BGREWRITEAOF</code> 可以在子进程进行，所以这三种操作可以同时进行。</li><li>为了避免产生竞争条件，<code>BGSAVE</code>执行时，<code>SAVE</code> 命令不能执行。</li><li>为了避免性能问题，<code>BGSAVE</code> 和 <code>BGREWRITEAOF</code> 不能同时执行。</li><li>调用 <code>rdbLoad</code> 函数载入 RDB 文件时，不能进行任何和数据库相关的操作，不过订阅与 发布方面的命令可以正常执行，因为它们和数据库不相关联。</li><li>RDB 文件的组织方式</li><li>键值对在 RDB 文件中的组织方式<ul><li>RDB 文件使用不同的格式来保存不同类型的值。</li></ul></li></ul><h4 id=53-aof>5.3 AOF<a hidden class=anchor aria-hidden=true href=#53-aof>#</a></h4><ul><li>RDB将数据库的快照以二进制方式保存到磁盘</li><li>AOF以协议文本方式，将所有对数据库进行过的写入命令（及参数）记录到AOF文件</li></ul><h5 id=531--aof命令同步>5.3.1 AOF命令同步<a hidden class=anchor aria-hidden=true href=#531--aof命令同步>#</a></h5><ul><li>同步命令到AOF文件的过程<ol><li>命令传播：Redis将执行完的命令、参数、参数个数等信息发送到AOF程序中</li><li>缓存追加：AOF程序根据接收到的命令数据，将命令转换为网络通讯协议的格式，然后将协议内容追加到服务器的AOF缓存中</li><li>文件写入和保存：AOF缓存中的内容被写入AOF文件末尾，如果设定的AOF保存条件被满足的话，<code>fsync</code>函数或者<code>fdatasync</code>函数会被调用，将写入的内容真正地保存到磁盘中。</li></ol></li></ul><h5 id=532-命令传播>5.3.2 命令传播<a hidden class=anchor aria-hidden=true href=#532-命令传播>#</a></h5><h5 id=533-缓存追加>5.3.3 缓存追加<a hidden class=anchor aria-hidden=true href=#533-缓存追加>#</a></h5><ul><li>协议文本生成之后，会被追加到<code>redis.h/redisServer</code>结构的<code>aof_buf</code>末尾</li><li><code>aof_buf</code>保存着所有等待写入AOF文件的协议文本</li><li>缓存追加步骤<ol><li>接受命令、命令的参数、参数个数、所使用的数据库等信息</li><li>将命令还原成Redis网络通讯协议</li><li>将协议文本追加到<code>aof_buf</code>末尾</li></ol></li></ul><h5 id=534-文件写入和保存>5.3.4 文件写入和保存<a hidden class=anchor aria-hidden=true href=#534-文件写入和保存>#</a></h5><ul><li>每当服务器常规任务函数被执行或者时间处理器被执行时，<code>aof.c/flushAppendOnlyFile</code>函数都会被调用，进行：<ul><li><code>WRITE</code>：根据条件，将<code>aof_buf</code>中的缓存写入到AOF文件</li><li><code>SAVE</code>：根据条件，调用<code>fsync</code>、<code>fdatastnc</code>函数，将AOF文件保存到磁盘中</li></ul></li></ul><h5 id=535-aof保存模式>5.3.5 AOF保存模式<a hidden class=anchor aria-hidden=true href=#535-aof保存模式>#</a></h5><ul><li><p>Redis目前支持三种AOF保存模式：</p><ul><li><code>AOF_FSYNC_NO</code>：不保存</li><li><code>AOF_FSYNC_EVERYSEC</code>：每秒保存</li><li><code>AOF_FSYNC_ALWAYS</code>：每次执行命令保存</li></ul></li><li><p>不保存</p><ul><li>每次调用<code>flushAppendOnlyFile</code>函数，<code>WRITE</code>都会被执行，<code>SAVE</code>会被略过</li><li><code>SAVE</code>只会在一下任意一种情况下被执行<ul><li>Redis被关闭</li><li>AOF功能被关闭</li><li>系统的写缓存被刷新（缓存满，或者定期保存操作）</li></ul></li></ul></li><li><p>每秒保存</p><ul><li>每次调用<code>flushAppendOnlyFile</code>，有四种情况：<ul><li>子进程正在执行<code>SAVE</code><ol><li>这个<code>SAVE</code>的执行时间未超过2秒，程序直接返回，并不执行<code>WRITE</code>或新的<code>SAVE</code></li><li>这个<code>SAVE</code>已经执行超过2秒，那么程序执行<code>WRITE</code>但不执行<code>SAVE</code>，此时的<code>WRITE</code>必须等待子线程先完成<code>SAVE</code></li></ol></li><li>子进程没有执行<code>SAVE</code><ol><li>上次成功执行<code>SAVE</code>距今不超过1秒，那么程序执行<code>WRITE</code>不执行<code>SAVE</code></li><li>上次成功执行<code>SAVE</code>距今超过1秒，那么程序执行<code>WRITE</code>和<code>SAVE</code></li></ol></li></ul></li></ul></li><li><p>每次执行命令保存</p><ul><li>每次执行一个命令后，<code>WRITE</code>和<code>SAVE</code>都会被执行</li><li><code>SAVE</code>是由Redis主进程执行，所以<code>SAVE</code>执行期间，主进程会被阻塞</li></ul></li></ul><h5 id=536-aof保存模式对性能和安全的影响>5.3.6 AOF保存模式对性能和安全的影响<a hidden class=anchor aria-hidden=true href=#536-aof保存模式对性能和安全的影响>#</a></h5><ul><li>对主进程的阻塞<ul><li><code>不保存</code>：写入和保存都是由主进程执行，阻塞主进程</li><li><code>每秒保存</code>：写入由主进程执行，阻塞主进程。保存由子线程执行，不阻塞，但保存操作完成的快嘛会影响写入操作的阻塞时长</li><li><code>每次执行命令保存</code>：类似<code>不保存</code></li></ul></li><li>安全性<ul><li>模式1最差</li><li>模式2兼顾性能和安全性</li><li>模式3安全性最高，性能最差</li></ul></li></ul><p><img loading=lazy src=https://note-site-pic-1259606004.cos.ap-beijing.myqcloud.com/img/20210713163333.png alt></p><h5 id=537-aof文件的读取和数据还原>5.3.7 AOF文件的读取和数据还原<a hidden class=anchor aria-hidden=true href=#537-aof文件的读取和数据还原>#</a></h5><ul><li>根据AOF文件里的协议，重新执行一遍里面指示的所有命令</li><li>读取AOF文件并还原步骤：<ol><li>创建一个不带网络连接的伪客户端</li><li>读取AOF所保存文本，还原出命令、参数、参数个数</li><li>使用伪客户端完执行命令</li><li>执行2、3，直到AOF所有命令被执行完毕</li></ol></li><li>为了避免对数据的完整性产生影响，在服务器载入数据的过程中，只有和数据库无关 的订阅与发布功能可以正常使用，其他命令一律返回错误。</li></ul><h5 id=538-aof重写>5.3.8 AOF重写<a hidden class=anchor aria-hidden=true href=#538-aof重写>#</a></h5><ul><li>为了解决AOF越来越大的问题</li><li>创建一个新的AOF文件来代替原有的AOF文件，新AOF文件和原有AOF文件保存的数据库状态完全一样，但新的AOF文件的体积小于等于原有AOF文件的体积</li></ul><h5 id=539-aof重写的实现>5.3.9 AOF重写的实现<a hidden class=anchor aria-hidden=true href=#539-aof重写的实现>#</a></h5><ul><li>AOF重写并不需要对原有的AOF文件进行任何写入和读取，它针对的是数据库中键的当前值</li><li>根据键的类型，使用适当的写入命令来重现键的当前值</li></ul><h5 id=5310-aof后台重写>5.3.10 AOF后台重写<a hidden class=anchor aria-hidden=true href=#5310-aof后台重写>#</a></h5><ul><li><p>好处</p><ul><li>不阻塞主进程</li><li>子进程带有主进程的数据副本，使用子进程而不是线程，可以在避免锁的情况下，保证数据的安全性</li></ul></li><li><p>子进程重写期间，主进程还需要继续处理，造成数据不一致</p><ul><li>Redis增加了AOF重写缓存，这个缓存在<code>fork</code>出子进程之后启用</li><li>Redis主进程在接到新的写命令后，除了将这个写命令追加到现有的AOF文件，还会追加到这个缓存中<ul><li>保证AOF功能继续，即使停机也不会丢失数据</li><li>所有对数据库的修改都会被记录到AOF重写缓存中</li></ul></li></ul></li><li><p>子进程完成AOF重写后，向父进程发送一个完成信号，父进程：</p><ul><li>将AOF重写缓存中的内容全部写入新的AOF文件</li><li>对新的AOF文件改名，覆盖原有的AOF文件</li></ul></li><li><p>以上是AOF后台重写，也即是<code>BGREWRITEAOF</code>命令的工作原理</p></li></ul><h5 id=5311-aof后台重写的出发条件>5.3.11 AOF后台重写的出发条件<a hidden class=anchor aria-hidden=true href=#5311-aof后台重写的出发条件>#</a></h5><ul><li>通过调用<code>BGREWRITEAOF</code>手动触发</li><li>服务器在AOF开启后会维持三个变量<ul><li>记录当前AOF文件大小的变量<code>aof_current_size</code></li><li>记录最后一次AOF重写后的AOF文件大小<code>aof_rewirte_base_size</code></li><li>增长百分比 <code>aof_rewirte_perc</code></li></ul></li><li>每次<code>serverCron</code>函数执行时，检查以下条件是否全部满足，是的话，会触发自动的AOF重写：<ul><li>没有<code>BGSAVE</code>命令在执行</li><li>没有<code>BGREWRITEAOF</code>在执行</li><li>当前AOF文件大小大于<code>server.aof_rewrite_min_size</code> （默认1MB）</li><li>当前AOF文件大小和最后一次AOF重写后的大小之前比率大于等于指定的增长百分比（默认100%）</li></ul></li></ul><h5 id=5312-小结>5.3.12 小结<a hidden class=anchor aria-hidden=true href=#5312-小结>#</a></h5><ul><li>AOF文件通过保存所有修改数据库的命令来记录数据库的状态</li><li>AOF文件的所有保存命令都以Redis通讯协议的格式保存</li><li>不同的AOF保存模式对数据的安全性、已经Redis的性能有很大的影响</li><li>AOF重写的目的是用更小的体积保存AOF文件，整个重写过程基本上不影响Redis主进程处理命令请求</li><li>AOF重写的实际重写工作是针对数据库的当前值来进行的，程序既不读写也不使用原有的AOF文件</li><li>AOF可以手动触发或自动触发</li></ul><h4 id=54-事件>5.4 事件<a hidden class=anchor aria-hidden=true href=#54-事件>#</a></h4><ul><li>事件是Redis的核心，处理两项重要的任务：<ul><li>处理文件事件：在多个客户端中实现多路复用，接受它们发来的命令请求，并将命令的执行结果返回给客户端</li><li>时间事件：实现服务器常规操作（<code>server cron job</code>）</li></ul></li></ul><h5 id=541-文件事件>5.4.1 文件事件<a hidden class=anchor aria-hidden=true href=#541-文件事件>#</a></h5><ul><li>Redis通过在多个客户端之间进行多路复用，从而实现高效的命令请求处理<ul><li>多个客户端通过套接字连接Redis服务器，但只有在套接字可以无阻塞地进行读或者写时，服务器才会和这些客户端进行交互</li><li>Redis将这些因为套接字进行多路复用而产生的事件称为文件事件（<code>file event</code>），文件事件可以分为读事件和写事件两类</li></ul></li><li>读事件<ul><li>读事件标志着客户端命令请求的发送状态</li><li>当一个新客户端连接到服务器时，服务器会给该客户端绑定读事件，直到客户端断开连接之后，这个读事件才会被移除</li><li>读事件在整个网络连接的生命期内，都会在等待和就绪两种状态直接切换<ul><li>当客户端连接到服务器，但并没有向服务器发送命令时，读事件处于等待状态</li><li>客户端发送命令，并且请求已到达（套接字可以无阻塞地执行读操作），读事件处于就绪状态</li></ul></li></ul></li><li>写事件<ul><li>写事件标志着客户端对命令结果的接受状态</li><li>客户端自始至终都关联着读事件。服务端只会在有命令结果需要传回给客户端时，才会为客户端关联写事件</li><li>写事件会在两种状态之间切换：<ul><li>当服务器有结果需要返回给客户端时，但客户端还未能执行无阻塞写，那么写事件处于等待状态</li><li>当服务器有结果需要返回给客户端时，并且客户端可以无阻塞写，那么写事件处于就绪状态</li></ul></li></ul></li></ul><h5 id=542-时间事件>5.4.2 时间事件<a hidden class=anchor aria-hidden=true href=#542-时间事件>#</a></h5><ul><li>事件事件记录着那些要在指定时间点运行的时间</li><li>多个时间事件以无序链表的形式保存在服务器状态中</li><li>每个时间事件主要由三个属性组成：<ul><li><code>when</code>：以毫秒格式的UNIX时间戳为单位，记录执行的时间</li><li><code>timeProc</code>：时间处理函数</li><li><code>next</code>：指向下一个时间事件，形成链表</li></ul></li><li>根据<code>timeProc</code>函数的返回值，可以将时间事件划分为两类：<ul><li>返回<code>ae.h/AE_NOMORE</code>，该事件为单词执行事件：处理一次后被删除，不再执行</li><li>如果返回非<code>AE_NOMORE</code>的整数，为循环执行事件：根据返回值更新<code>when</code>属性，一直更新运行下去</li></ul></li></ul><h5 id=543-时间事件应用实例服务器常规操作>5.4.3 时间事件应用实例：服务器常规操作<a hidden class=anchor aria-hidden=true href=#543-时间事件应用实例服务器常规操作>#</a></h5><ul><li>服务器定期自检，这类操作成为常规操作（<code>cron job</code>）</li><li>由<code>redis.c/serverCron</code>实现，包括：<ul><li>更新服务器各类统计时间，比如时间、内存占用、数据库占用情况等</li><li>清理数据库中的过期键值对</li><li>对不合理的数据库进行大小调整</li><li>关闭和清理链接失效的客户端</li><li>尝试进行AOF或RDB持久化操作</li><li>如果服务器时主节点的话，对附属节点进行定期同步</li><li>如果处于集群模式的话，对集群进行定期同步和链接测试</li></ul></li><li>Redis将<code>serverCron</code>作为时间事件来运行，循环执行</li></ul><h5 id=544-事件的执行与调度>5.4.4 事件的执行与调度<a hidden class=anchor aria-hidden=true href=#544-事件的执行与调度>#</a></h5><ul><li>Redis中两种时间呈合作关系：<ul><li>一种事件等待另一种事件执行完毕之后，才开始执行，事件之间不会出现抢占</li><li>时间处理器先处理文件事件（命令请求），在执行时间事件（调用<code>serverCron</code>）</li><li>文件时间的等待时间（类<code>poll</code>函数的最大阻塞时间），由距离到达时间最短的时间事件决定</li></ul></li></ul><h5 id=545-小结>5.4.5 小结<a hidden class=anchor aria-hidden=true href=#545-小结>#</a></h5><ul><li>Redis事件分为时间事件和文件事件</li><li>文件时间分读事件和写事件：读事件实现命令请求的接收，写事件实现了命令结果的返回</li><li>时间时间分为单词执行事件和循环执行时间，服务器常规操作<code>serverCron</code>就是循环事件</li><li>文件事件和时间事件之间是合作关系：一种事件会等待另一种事件完成后在执行，不会出现抢占情况</li><li>时间事件的实际执行时间通常比预定时间晚一些</li></ul><h4 id=55-服务器与客户端>5.5 服务器与客户端<a hidden class=anchor aria-hidden=true href=#55-服务器与客户端>#</a></h4><h5 id=551-初始化服务器>5.5.1 初始化服务器<a hidden class=anchor aria-hidden=true href=#551-初始化服务器>#</a></h5><ul><li>初始化过程：<ol><li>初始化服务器全局状态</li><li>载入配置文件</li><li>创建<code>daemon</code>进程</li><li>初始化服务器功能模块</li><li>载入数据</li><li>开始时间循环</li></ol></li><li>初始化服务器全局状态<ul><li><code>redis.h/redisServer</code>记录了和服务器相关的所有数据</li></ul></li><li>载入配置文件<ul><li>Redis在初始完<code>server</code>变量之后，会读入配置文件和选项，根据这些配置来对<code>server</code> 变量的属性值做相应的修改</li></ul></li><li>创建<code>daemon</code>进程<ul><li>Redis默认以<code>daemon</code>进程方式运行，并创建相应的<code>pid</code>文件</li></ul></li><li>初始化服务器功能模块<ul><li>为<code>server</code>变量的数据结构子属性分配内存</li><li>初始化这些数据结构</li></ul></li><li>载入数据<ul><li>将RDB或AOF数据载入到服务器进程。AOF优先被使用</li></ul></li><li>开始时间循环</li></ul><h5 id=552-客户端连接到服务器>5.5.2 客户端连接到服务器<a hidden class=anchor aria-hidden=true href=#552-客户端连接到服务器>#</a></h5><ul><li><p>当服务器完成初始化之后，就准备好接受客户端连接</p></li><li><p>客户端通过套接字函数<code>connect</code>到服务器，步骤：</p><ol><li>服务器通过文件事件无阻塞地<code>accept</code>客户端连接，并返回一个套接字描述符<code>fd</code></li><li>服务器为<code>fd</code>创建一个对应的<code>redis.h/redisClient</code>结构实例，并将该实例加入到服务器的已连接客户端链表中</li><li>服务器在事件处理器为该<code>fd</code>关联读文件请求</li></ol></li><li><p>Redis以多路复用的方式来处理多个客户端，为每个已连接客户端维持一个<code>redisClient</code>结构：</p><ul><li>套接字描述符</li><li>客户端正在使用的数据库指针和数据库号码</li><li>客户端的查询缓存和回复缓存</li><li>一个指向命令函数的指针，以及字符串形式的命令、命令参数、命令个数</li><li>客户端状态：<code>SLAVE</code>、<code>MONITOR</code>、事务状态</li><li>实现事务功能（<code>MULTI</code>、<code>WATCH</code>）所需的数据结构</li><li>实现阻塞功能（<code>BLPOP</code>、<code>BRPOPLPUSH</code>）所需的数据结构</li><li>实现订阅与发布功能（<code>PUBLISH</code>、<code>SUBSCRIBE</code>）所需的数据结构</li><li>统计数据和选项：客户端创建时间，和服务端最后交互时间，缓存大小等</li></ul></li></ul><h5 id=553-命令的请求处理和结果返回>5.5.3 命令的请求、处理和结果返回<a hidden class=anchor aria-hidden=true href=#553-命令的请求处理和结果返回>#</a></h5><ul><li>客户端连上服务器之后，客户端就可以向服务器发送命令请求了</li><li>服务器处理客户端请求过程：<ol><li>客户端通过套接字向服务器传送命令协议数据</li><li>服务器通过读事件来传入数据，并将数据保存在客户端对应的<code>redisClient</code>结构的查询缓存</li><li>根据客户端查询缓存中的内容，程序从命令表中查找响应命令的实现函数</li><li>程序执行实现函数，修改服务器的全局状态<code>server</code>变量，并将命令的执行结果保存到客户端<code>redisClient</code>结构的回复缓存，然后为该客户端的<code>fd</code>关联写事件</li><li>当客户端<code>fd</code>的写事件就绪时，将回复缓存中的命令结果传回给客户端</li></ol></li></ul><h5 id=554-命令请求实例set的执行过程>5.5.4 命令请求实例：SET的执行过程<a hidden class=anchor aria-hidden=true href=#554-命令请求实例set的执行过程>#</a></h5><h5 id=555-小结>5.5.5 小结<a hidden class=anchor aria-hidden=true href=#555-小结>#</a></h5><ul><li>服务器经过初始化之后，才能开始接受命令</li><li>服务器初始化可以分为6个步骤</li><li>服务器为每个已连接的客户端维持一个客户端结构，保存这个客户端的所有状态信息</li><li>服务器处理客户端请求流程</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.cuiks.top/tags/redis/>redis</a></li><li><a href=https://www.cuiks.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Redis设计与实现 on twitter" href="https://twitter.com/intent/tweet/?text=Redis%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0&url=https%3a%2f%2fwww.cuiks.top%2fposts%2fredis_design_and_implement%2f&hashtags=redis%2c%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Redis设计与实现 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.cuiks.top%2fposts%2fredis_design_and_implement%2f&title=Redis%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0&summary=Redis%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0&source=https%3a%2f%2fwww.cuiks.top%2fposts%2fredis_design_and_implement%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Redis设计与实现 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.cuiks.top%2fposts%2fredis_design_and_implement%2f&title=Redis%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Redis设计与实现 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.cuiks.top%2fposts%2fredis_design_and_implement%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Redis设计与实现 on whatsapp" href="https://api.whatsapp.com/send?text=Redis%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0%20-%20https%3a%2f%2fwww.cuiks.top%2fposts%2fredis_design_and_implement%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Redis设计与实现 on telegram" href="https://telegram.me/share/url?text=Redis%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0&url=https%3a%2f%2fwww.cuiks.top%2fposts%2fredis_design_and_implement%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><span id=/posts/redis_design_and_implement/ class=leancloud_visitors data-flag-title=Redis设计与实现><span class=post-meta-item-text>文章阅读量</span>
<span class=leancloud-visitors-count>1000000</span><p></p></span><div id=vcomments></div><script src=//cdn1.lncld.net/static/js/3.0.4/av-min.js></script><script src=//unpkg.com/valine/dist/Valine.min.js></script><script type=text/javascript>new Valine({el:'#vcomments',appId:'qawpEGaIhzxE9qCJm9hisTxW-gzGzoHsz',appKey:'FkncojWQwaOzzkHjlvW0vH3b',notify:false,verify:false,avatar:'',placeholder:'说点什么吧...',visitor:true});</script></article></main><footer class=footer><span>&copy; 2021 <a href=https://www.cuiks.top>Note Site</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>